# 16 Games in C++

Bem-vindo √† documenta√ß√£o do projeto 16 Games in C++! üéÆ

Este projeto √© uma cole√ß√£o de 16 jogos cl√°ssicos implementados em C++ utilizando a biblioteca SFML (Simple and Fast Multimedia Library). Cada jogo √© completo e funcional, perfeito para aprender conceitos de programa√ß√£o de jogos e C++.

## üéØ Sobre o Projeto

O projeto 16 Games in C++ foi criado com o objetivo de demonstrar diferentes t√©cnicas de programa√ß√£o de jogos, desde jogos simples como Tetris at√© jogos mais complexos como Chess e Asteroids. Todos os jogos utilizam:

* C++17 como linguagem de programa√ß√£o

* SFML 2.5+ para gr√°ficos, √°udio e entrada

* CMake para build system

* Estrutura modular e c√≥digo limpo

## üéÆ Jogos Inclu√≠dos

1. Tetris - O cl√°ssico jogo de blocos

2. Doodle Jump - Pule o mais alto poss√≠vel

3. Arkanoid - Quebre todos os blocos

4. Snake - A serpente cl√°ssica

5. Minesweeper - Campo minado

6. Fifteen Puzzle - Quebra-cabe√ßa num√©rico

7. Racing (Top Down) - Corrida vista de cima

8. Outrun - Corrida em perspectiva

9. Xonix - Conquiste territ√≥rio

10. Bejeweled - Combine joias

11. NetWalk - Conecte os canos

12. Mahjong Solitaire - Paci√™ncia mahjong

13. Tron - Batalha de luz

14. Chess - Xadrez completo

15. Volleyball - V√¥lei arcade

16. Asteroids - Destrua os asteroides

## üöÄ In√≠cio R√°pido

Para come√ßar rapidamente:

1. [Configure o ambiente](configuracao-ambiente.html)

2. Clone o reposit√≥rio

3. Execute o script de setup: `./setup.sh`

4. Compile e jogue: `make all_games`

## üìö Estrutura da Documenta√ß√£o

Esta documenta√ß√£o est√° organizada nas seguintes se√ß√µes:

* [Configura√ß√£o do Ambiente](configuracao-ambiente.html) - Como instalar e configurar tudo que voc√™ precisa

* [Compila√ß√£o](compilacao.html) - Guias de build e execu√ß√£o

* [Estrutura do Projeto](estrutura-projeto.html) - Como o c√≥digo est√° organizado

* [Jogos](jogos.html) - Documenta√ß√£o espec√≠fica de cada jogo

* [Troubleshooting](troubleshooting-setup.html) - Solu√ß√µes para problemas comuns

## üõ†Ô∏è Requisitos do Sistema

* Sistema Operacional: Linux, macOS ou Windows

* Compilador: GCC 7+ ou Clang 6+ com suporte a C++17

* CMake: 3.10 ou superior

* SFML: 2.5 ou superior

## ü§ù Contribuindo

Este projeto √© open source! Voc√™ pode:

* Reportar bugs

* Sugerir melhorias

* Contribuir com c√≥digo

* Melhorar a documenta√ß√£o

## üìÑ Licen√ßa

Este projeto √© distribu√≠do sob a licen√ßa MIT. Veja o arquivo LICENSE para mais detalhes.

Pronto para come√ßar? V√° para [Configura√ß√£o do Ambiente](configuracao-ambiente.html) e configure seu sistema para executar os jogos!



# Configura√ß√£o do Ambiente

Este guia te ajudar√° a configurar completamente o ambiente de desenvolvimento para executar os 16 jogos em C++. üõ†Ô∏è

## üìã Vis√£o Geral

Para executar este projeto, voc√™ precisar√° instalar e configurar:

1. [Requisitos do Sistema](system-requirements.html) - Verificar compatibilidade

2. [SFML](sfml-installation.html) - Biblioteca gr√°fica principal

3. [SQLite3](null) - Biblioteca de banco de dados para persist√™ncia

4. [CMake](cmake-installation.html) - Sistema de build

5. [IDE](ide-setup.html) - Ambiente de desenvolvimento (opcional)

6. [Configura√ß√£o Final](environment-setup.html) - Testes e valida√ß√£o

## üöÄ Setup Autom√°tico (Recomendado)

O projeto inclui um script de configura√ß√£o autom√°tica que verifica e configura tudo para voc√™:

```BASH
# Clone o reposit√≥rio
git clone <repository-url>
cd 16Games-in-Cpp

# Execute o script de setup
chmod +x setup.sh
./setup.sh
```

O script `setup.sh` ir√°:

* ‚úÖ Verificar se o SFML est√° instalado

* ‚úÖ Verificar se o CMake est√° dispon√≠vel

* ‚úÖ Verificar se h√° um compilador C++ v√°lido

* ‚úÖ Configurar o projeto com CMake

* ‚úÖ Compilar um jogo de teste

* ‚úÖ Mostrar instru√ß√µes de uso

## üîß Setup Manual

Se preferir instalar manualmente ou se o script autom√°tico falhar, siga os guias espec√≠ficos:

### 1. Requisitos do Sistema

Primeiro, verifique se seu sistema atende aos [requisitos m√≠nimos](system-requirements.html).

### 2. Instalar SFML

A biblioteca SFML √© essencial para gr√°ficos, √°udio e entrada. Veja o [guia de instala√ß√£o do SFML](sfml-installation.html).

### 3. Instalar CMake

O CMake √© usado para gerenciar o build do projeto. Veja o [guia de instala√ß√£o do CMake](cmake-installation.html).

### 4. Configurar IDE (Opcional)

Para uma melhor experi√™ncia de desenvolvimento, configure sua [IDE preferida](ide-setup.html).

### 5. Configura√ß√£o Final

Complete a [configura√ß√£o do ambiente](environment-setup.html) e teste tudo.

## ‚ö° Verifica√ß√£o R√°pida

Ap√≥s a instala√ß√£o, execute estes comandos para verificar se tudo est√° funcionando:

```BASH
# Verificar SFML
pkg-config --exists sfml-all && echo "‚úÖ SFML OK" || echo "‚ùå SFML n√£o encontrado"

# Verificar SQLite3
pkg-config --exists sqlite3 && echo "‚úÖ SQLite3 OK" || echo "‚ùå SQLite3 n√£o encontrado"

# Verificar CMake
cmake --version && echo "‚úÖ CMake OK" || echo "‚ùå CMake n√£o encontrado"

# Verificar compilador
g++ --version && echo "‚úÖ G++ OK" || echo "‚ùå G++ n√£o encontrado"
```

## üéØ Pr√≥ximos Passos

Ap√≥s configurar o ambiente:

1. V√° para [Compila√ß√£o](compilacao.html) para aprender a compilar os jogos

2. Ou v√° direto para [Build and Run](build-and-run.html) para executar rapidamente

## ‚ùó Problemas?

Se encontrar algum problema durante a configura√ß√£o:

1. Consulte o [Troubleshooting](troubleshooting-setup.html)

2. Verifique se seguiu todos os passos corretamente

3. Confirme se seu sistema atende aos requisitos m√≠nimos

Dica: O script `setup.sh` √© a forma mais r√°pida e confi√°vel de configurar o ambiente. Use-o sempre que poss√≠vel!



# Requisitos do Sistema

Antes de instalar o projeto 16 Games in C++, verifique se seu sistema atende aos requisitos m√≠nimos. üíª

## üñ•Ô∏è Sistemas Operacionais Suportados

### Linux (Recomendado)

* Ubuntu: 18.04 LTS ou superior

* Debian: 10 (Buster) ou superior

* Fedora: 30 ou superior

* Arch Linux: Vers√£o atual

* openSUSE: Leap 15.2 ou superior

* CentOS/RHEL: 8 ou superior

### macOS

* macOS: 10.14 (Mojave) ou superior

* Xcode: 10 ou superior (para compilador)

### Windows

* Windows: 10 ou superior

* Visual Studio: 2019 ou superior

* MinGW-w64: Como alternativa ao Visual Studio

## üîß Compilador C++

### Requisitos M√≠nimos

* Suporte ao C++17: Obrigat√≥rio

* Vers√µes m√≠nimas: * GCC: 7.0 ou superior * Clang: 6.0 ou superior * MSVC: Visual Studio 2019 ou superior

### Verifica√ß√£o do Compilador

#### Linux/macOS

```BASH
# Verificar GCC
g++ --version
# Deve mostrar vers√£o 7.0+

# Verificar Clang (se dispon√≠vel)
clang++ --version
# Deve mostrar vers√£o 6.0+
```

#### Windows

```
# Visual Studio
cl
# Deve mostrar MSVC 19.20+

# MinGW
g++ --version
# Deve mostrar vers√£o 7.0+
```

## üì¶ Depend√™ncias Principais

### CMake

* Vers√£o m√≠nima: 3.10

* Recomendada: 3.16 ou superior

### SFML

* Vers√£o m√≠nima: 2.5.0

* Recomendada: 2.5.1 ou superior

* M√≥dulos necess√°rios: * sfml-system * sfml-window * sfml-graphics * sfml-audio * sfml-network (opcional)

### SQLite3

* Vers√£o m√≠nima: 3.0.0

* Recomendada: Mais recente est√°vel

* M√≥dulos necess√°rios: * sqlite3

### Bibliotecas do Sistema (Linux)

```BASH
# Ubuntu/Debian
sudo apt-get install libsfml-dev cmake build-essential libsqlite3-dev

# Fedora
sudo dnf install SFML-devel cmake gcc-c++ sqlite-devel

# Arch Linux
sudo pacman -S sfml cmake gcc sqlite
```

## üíæ Espa√ßo em Disco

### Requisitos de Espa√ßo

* C√≥digo fonte: ~50 MB

* Depend√™ncias: ~200 MB (SFML + CMake)

* Build completo: ~100 MB

* Total recomendado: ~500 MB livre

### Estrutura de Diret√≥rios

```
16Games-in-Cpp/
‚îú‚îÄ‚îÄ build/          # ~100 MB (arquivos compilados)
‚îú‚îÄ‚îÄ Writerside/     # ~10 MB (documenta√ß√£o)
‚îú‚îÄ‚îÄ games/          # ~40 MB (c√≥digo fonte dos jogos)
‚îî‚îÄ‚îÄ assets/         # ~5 MB (imagens, sons, fonts)
```

## üñ±Ô∏è Hardware Recomendado

### M√≠nimo

* CPU: Dual-core 2.0 GHz

* RAM: 4 GB

* GPU: Integrada com OpenGL 2.1

* Resolu√ß√£o: 1024x768

### Recomendado

* CPU: Quad-core 2.5 GHz ou superior

* RAM: 8 GB ou superior

* GPU: Dedicada com OpenGL 3.3+

* Resolu√ß√£o: 1920x1080 ou superior

## üîç Verifica√ß√£o Autom√°tica

Use o script de verifica√ß√£o inclu√≠do no projeto:

```BASH
# Executar verifica√ß√£o de requisitos
./setup.sh

# Ou verificar manualmente
./check_requirements.sh  # Se dispon√≠vel
```

O script verificar√°:

* ‚úÖ Sistema operacional compat√≠vel

* ‚úÖ Compilador C++ com suporte ao C++17

* ‚úÖ CMake vers√£o adequada

* ‚úÖ SFML instalado e funcional

* ‚úÖ Espa√ßo em disco suficiente

## ‚ö†Ô∏è Problemas Comuns

### Compilador Muito Antigo

```BASH
# Ubuntu 18.04 - instalar GCC mais novo
sudo apt update
sudo apt install gcc-9 g++-9
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 90
```

### SFML N√£o Encontrado

```BASH
# Verificar instala√ß√£o
pkg-config --exists sfml-all
pkg-config --modversion sfml-all

# Se n√£o encontrado, reinstalar
sudo apt-get install --reinstall libsfml-dev
```

### CMake Muito Antigo

```BASH
# Ubuntu - instalar vers√£o mais nova
wget https://github.com/Kitware/CMake/releases/download/v3.20.0/cmake-3.20.0-Linux-x86_64.sh
chmod +x cmake-3.20.0-Linux-x86_64.sh
sudo ./cmake-3.20.0-Linux-x86_64.sh --prefix=/usr/local --skip-license
```

## üéØ Pr√≥ximos Passos

Se seu sistema atende aos requisitos:

1. Prossiga para [Instala√ß√£o do SFML](sfml-installation.html)

2. Ou execute o [setup autom√°tico](configuracao-ambiente.html)

Se encontrou problemas:

1. Consulte o [Troubleshooting](troubleshooting-setup.html)

2. Atualize seu sistema e tente novamente

Dica: Na d√∫vida, execute `./setup.sh` - o script detectar√° automaticamente se h√° algum problema com os requisitos!



# Instala√ß√£o do SFML

O SFML (Simple and Fast Multimedia Library) √© a biblioteca principal usada por todos os 16 jogos. Este guia mostra como instal√°-la em diferentes sistemas operacionais. üéÆ

## üìö O que √© SFML?

SFML √© uma biblioteca C++ que fornece:

* Gr√°ficos 2D - Desenho de sprites, formas, texto

* √Åudio - Reprodu√ß√£o de sons e m√∫sica

* Janelas - Cria√ß√£o e gerenciamento de janelas

* Eventos - Captura de teclado, mouse e joystick

* Rede - Comunica√ß√£o TCP/UDP (n√£o usado neste projeto)

## üêß Linux

### Ubuntu/Debian

```BASH
# Atualizar reposit√≥rios
sudo apt update

# Instalar SFML e depend√™ncias de desenvolvimento
sudo apt install libsfml-dev

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

### Fedora/CentOS/RHEL

```BASH
# Fedora
sudo dnf install SFML-devel

# CentOS/RHEL (com EPEL)
sudo yum install epel-release
sudo yum install SFML-devel

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

### Arch Linux

```BASH
# Instalar SFML
sudo pacman -S sfml

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

### openSUSE

```BASH
# openSUSE Leap/Tumbleweed
sudo zypper install libsfml2-devel

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

## üçé macOS

### Usando Homebrew (Recomendado)

```BASH
# Instalar Homebrew se n√£o tiver
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Instalar SFML
brew install sfml

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

### Usando MacPorts

```BASH
# Instalar SFML
sudo port install sfml

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

### Instala√ß√£o Manual

1. Baixe SFML do [site oficial](https://www.sfml-dev.org/download.php)

2. Extraia para `/usr/local/`

3. Configure as vari√°veis de ambiente:

```BASH
export SFML_ROOT=/usr/local/SFML-2.5.1
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$SFML_ROOT/lib/pkgconfig
```

## ü™ü Windows

### Visual Studio (Recomendado)

#### 1. Baixar SFML

* Acesse [SFML Downloads](https://www.sfml-dev.org/download.php)

* Baixe a vers√£o para Visual Studio (ex: `SFML-2.5.1-windows-vc15-64-bit.zip`)

#### 2. Extrair e Configurar

```
# Extrair para C:\SFML
# Estrutura deve ficar:
C:\SFML\
‚îú‚îÄ‚îÄ bin\
‚îú‚îÄ‚îÄ include\
‚îú‚îÄ‚îÄ lib\
‚îî‚îÄ‚îÄ examples\
```

#### 3. Configurar Projeto Visual Studio

No seu projeto CMake ou Visual Studio:

```CMAKE
set(SFML_ROOT "C:/SFML")
find_package(SFML 2.5 COMPONENTS system window graphics audio REQUIRED)
```

### MinGW-w64

```BASH
# Usando MSYS2
pacman -S mingw-w64-x86_64-sfml

# Verificar instala√ß√£o
pkg-config --modversion sfml-all
```

### vcpkg (Alternativa)

```
# Instalar vcpkg
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
.\bootstrap-vcpkg.bat

# Instalar SFML
.\vcpkg install sfml:x64-windows
```

## üîß Compila√ß√£o desde o C√≥digo Fonte

Se os pacotes pr√©-compilados n√£o funcionarem, compile o SFML:

### Linux/macOS

```BASH
# Baixar c√≥digo fonte
git clone https://github.com/SFML/SFML.git
cd SFML

# Criar diret√≥rio de build
mkdir build
cd build

# Configurar com CMake
cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local

# Compilar
make -j$(nproc)

# Instalar (pode precisar de sudo)
sudo make install

# Atualizar cache de bibliotecas (Linux)
sudo ldconfig
```

### Windows (Visual Studio)

```
# No Developer Command Prompt
git clone https://github.com/SFML/SFML.git
cd SFML
mkdir build
cd build

cmake .. -G "Visual Studio 16 2019" -A x64
cmake --build . --config Release
cmake --install . --prefix C:\SFML
```

## ‚úÖ Verifica√ß√£o da Instala√ß√£o

### Teste B√°sico

Crie um arquivo `test_sfml.cpp`:

```CPP
#include <SFML/Graphics.hpp>
#include <iostream>

int main() {
    // Tentar criar uma janela
    sf::RenderWindow window(sf::VideoMode(200, 200), "SFML Test");
    
    if (!window.isOpen()) {
        std::cout << "‚ùå Erro ao criar janela SFML\n";
        return 1;
    }
    
    std::cout << "‚úÖ SFML funcionando corretamente!\n";
    
    // Fechar imediatamente
    window.close();
    return 0;
}
```

### Compilar Teste

```BASH
# Linux/macOS
g++ -o test_sfml test_sfml.cpp $(pkg-config --cflags --libs sfml-all)

# Windows (MinGW)
g++ -o test_sfml.exe test_sfml.cpp -lsfml-graphics -lsfml-window -lsfml-system

# Executar
./test_sfml
```

### Usando CMake (Recomendado)

Crie um `CMakeLists.txt`:

```CMAKE
cmake_minimum_required(VERSION 3.10)
project(TestSFML)

set(CMAKE_CXX_STANDARD 17)

find_package(PkgConfig REQUIRED)
pkg_check_modules(SFML REQUIRED sfml-all>=2.5)

add_executable(test_sfml test_sfml.cpp)
target_link_libraries(test_sfml ${SFML_LIBRARIES})
target_compile_options(test_sfml PRIVATE ${SFML_CFLAGS})
```

```BASH
mkdir build
cd build
cmake ..
make
./test_sfml
```

## üîç Verifica√ß√£o com pkg-config

```BASH
# Verificar se SFML est√° dispon√≠vel
pkg-config --exists sfml-all
echo $?  # Deve retornar 0

# Ver vers√£o instalada
pkg-config --modversion sfml-all

# Ver flags de compila√ß√£o
pkg-config --cflags sfml-all

# Ver flags de link
pkg-config --libs sfml-all

# Informa√ß√µes completas
pkg-config --cflags --libs sfml-all
```

## ‚ùó Solu√ß√£o de Problemas

### Erro: "sfml-all not found"

```BASH
# Verificar se pkg-config est√° instalado
pkg-config --version

# Listar todos os pacotes dispon√≠veis
pkg-config --list-all | grep -i sfml

# Verificar caminhos do pkg-config
echo $PKG_CONFIG_PATH

# Linux: SFML pode estar em /usr/lib/pkgconfig/
ls /usr/lib/pkgconfig/ | grep sfml
```

### Erro de Linking

```BASH
# Verificar se bibliotecas est√£o instaladas
ldconfig -p | grep sfml  # Linux
find /usr -name "*sfml*" 2>/dev/null  # Linux/macOS

# Windows: verificar PATH
echo %PATH%
```

### Vers√£o Incompat√≠vel

```BASH
# Desinstalar vers√£o antiga
sudo apt remove libsfml-dev  # Ubuntu
brew uninstall sfml          # macOS

# Limpar cache
sudo apt autoremove
brew cleanup

# Reinstalar vers√£o correta
sudo apt install libsfml-dev
brew install sfml
```

## üéØ Pr√≥ximos Passos

Ap√≥s instalar o SFML com sucesso:

1. Prossiga para [Instala√ß√£o do CMake](cmake-installation.html)

2. Ou volte para [Configura√ß√£o do Ambiente](configuracao-ambiente.html)

Se ainda tiver problemas:

1. Consulte o [Troubleshooting](troubleshooting-setup.html)

2. Execute o script autom√°tico: `./setup.sh`

Dica: O comando `pkg-config --cflags --libs sfml-all` mostra exatamente como compilar com SFML. Guarde essa informa√ß√£o!



# Instala√ß√£o do CMake

O CMake √© o sistema de build usado pelo projeto 16 Games in C++. Este guia mostra como instal√°-lo em diferentes sistemas operacionais. üî®

## üìö O que √© CMake?

CMake √© uma ferramenta multiplataforma que:

* Gera arquivos de build para diferentes sistemas (Make, Visual Studio, Xcode)

* Gerencia depend√™ncias de forma autom√°tica

* Configura compila√ß√£o com diferentes op√ß√µes

* Simplifica builds em m√∫ltiplas plataformas

## üìã Vers√µes Suportadas

* M√≠nima: 3.10

* Recomendada: 3.16 ou superior

* Ideal: 3.20 ou superior (melhor suporte ao C++17)

## üêß Linux

### Ubuntu/Debian

#### Vers√£o dos Reposit√≥rios (Mais Simples)

```BASH
# Atualizar reposit√≥rios
sudo apt update

# Instalar CMake
sudo apt install cmake

# Verificar vers√£o
cmake --version
```

#### Vers√£o Mais Recente (Recomendado)

```BASH
# Adicionar reposit√≥rio Kitware (oficial)
wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | gpg --dearmor - | sudo tee /etc/apt/trusted.gpg.d/kitware.gpg >/dev/null

# Ubuntu 20.04
sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ focal main'

# Ubuntu 22.04
sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ jammy main'

# Instalar
sudo apt update
sudo apt install cmake

# Verificar vers√£o
cmake --version
```

### Fedora/CentOS/RHEL

```BASH
# Fedora
sudo dnf install cmake

# CentOS/RHEL 8+
sudo dnf install cmake

# Verificar vers√£o
cmake --version
```

### Arch Linux

```BASH
# Instalar CMake
sudo pacman -S cmake

# Verificar vers√£o
cmake --version
```

### openSUSE

```BASH
# openSUSE Leap/Tumbleweed
sudo zypper install cmake

# Verificar vers√£o
cmake --version
```

## üçé macOS

### Usando Homebrew (Recomendado)

```BASH
# Instalar Homebrew se n√£o tiver
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Instalar CMake
brew install cmake

# Verificar vers√£o
cmake --version
```

### Usando MacPorts

```BASH
# Instalar CMake
sudo port install cmake

# Verificar vers√£o
cmake --version
```

### Instala√ß√£o Manual

```BASH
# Baixar bin√°rio
curl -L -O https://github.com/Kitware/CMake/releases/download/v3.25.1/cmake-3.25.1-macos-universal.tar.gz

# Extrair
tar -xzf cmake-3.25.1-macos-universal.tar.gz

# Mover para aplica√ß√µes
sudo mv cmake-3.25.1-macos-universal/CMake.app /Applications/

# Criar link simb√≥lico
sudo ln -s /Applications/CMake.app/Contents/bin/cmake /usr/local/bin/cmake

# Verificar vers√£o
cmake --version
```

## ü™ü Windows

### Usando winget (Windows 10/11)

```
# Instalar CMake
winget install Kitware.CMake

# Verificar vers√£o (reiniciar terminal)
cmake --version
```

### Usando Chocolatey

```
# Instalar Chocolatey se n√£o tiver
# Ver: https://chocolatey.org/install

# Instalar CMake
choco install cmake

# Verificar vers√£o
cmake --version
```

### Instala√ß√£o Manual

1. Acesse [CMake Downloads](https://cmake.org/download/)

2. Baixe o instalador Windows (`.msi`)

3. Execute o instalador

4. Importante: Marque "Add CMake to system PATH"

5. Verificar instala√ß√£o:

```
cmake --version
```

### Visual Studio

O Visual Studio 2019/2022 j√° inclui CMake:

* Est√° em `C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe`

* Pode ser necess√°rio adicionar ao PATH manualmente

## üîß Compila√ß√£o desde o C√≥digo Fonte

Se precisar de uma vers√£o espec√≠fica ou os pacotes n√£o funcionarem:

### Linux/macOS

```BASH
# Baixar c√≥digo fonte
wget https://github.com/Kitware/CMake/releases/download/v3.25.1/cmake-3.25.1.tar.gz
tar -xzf cmake-3.25.1.tar.gz
cd cmake-3.25.1

# Configurar (bootstrap)
./bootstrap --prefix=/usr/local

# Compilar
make -j$(nproc)

# Instalar
sudo make install

# Verificar vers√£o
cmake --version
```

### Compila√ß√£o R√°pida (Sem Bootstrap)

```BASH
# Se j√° tiver CMake instalado (vers√£o mais antiga)
mkdir build
cd build
cmake ..
make -j$(nproc)
sudo make install
```

## ‚úÖ Verifica√ß√£o da Instala√ß√£o

### Teste B√°sico

```BASH
# Verificar vers√£o
cmake --version

# Deve mostrar algo como:
# cmake version 3.25.1
```

### Teste de Funcionalidade

Crie um projeto de teste:

#### CMakeLists.txt

```CMAKE
cmake_minimum_required(VERSION 3.10)
project(TestCMake)

set(CMAKE_CXX_STANDARD 17)

add_executable(test_cmake main.cpp)
```

#### main.cpp

```CPP
#include <iostream>
int main() {
    std::cout << "‚úÖ CMake funcionando!\n";
    return 0;
}
```

#### Compilar e Testar

```BASH
mkdir build
cd build
cmake ..
make  # ou cmake --build .
./test_cmake
```

## üéØ Configura√ß√µes √öteis

### Configurar CMake Globalmente

```BASH
# Criar arquivo de configura√ß√£o
mkdir -p ~/.cmake
cat > ~/.cmake/CMakeCache.txt << EOF
CMAKE_BUILD_TYPE:STRING=Release
CMAKE_CXX_STANDARD:STRING=17
CMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON
EOF
```

### Aliases √öteis

Adicione ao seu `.bashrc` ou `.zshrc`:

```BASH
# Aliases para CMake
alias cb='cmake --build .'
alias cc='cmake ..'
alias cr='cmake .. && make'
alias ctest='ctest --output-on-failure'
```

## üîß Ferramentas Complementares

### CMake GUI (Opcional)

```BASH
# Linux
sudo apt install cmake-qt-gui  # Ubuntu/Debian
sudo dnf install cmake-gui     # Fedora

# macOS
brew install --cask cmake

# Windows - inclu√≠do no instalador
```

### ccmake (Curses Interface)

```BASH
# Linux - geralmente inclu√≠do
ccmake ..

# Navegar com setas, Enter para editar, 'c' para configurar, 'g' para gerar
```

## üìä Verifica√ß√£o de Recursos

```BASH
# Ver todas as op√ß√µes do CMake
cmake --help

# Ver geradores dispon√≠veis
cmake --help | grep "Generators"

# Informa√ß√µes do sistema
cmake --system-information

# Verificar vari√°veis dispon√≠veis
cmake --help-variable-list | head -20
```

## ‚ùó Solu√ß√£o de Problemas

### CMake N√£o Encontrado

```BASH
# Verificar PATH
echo $PATH

# Linux/macOS - onde est√° o CMake?
which cmake
whereis cmake

# Windows
where cmake
```

### Vers√£o Muito Antiga

```BASH
# Desinstalar vers√£o antiga
sudo apt remove cmake      # Ubuntu
brew uninstall cmake       # macOS

# Instalar vers√£o mais recente (ver se√ß√µes acima)
```

### Erro de Permiss√£o

```BASH
# Linux - problemas de permiss√£o
sudo chown -R $USER:$USER ~/.cmake
sudo chmod -R 755 ~/.cmake
```

### Conflito de Vers√µes

```BASH
# Ver todas as vers√µes instaladas
ls /usr/bin/cmake*
ls /usr/local/bin/cmake*

# Usar vers√£o espec√≠fica
/usr/local/bin/cmake --version
```

## üéØ CMake no Projeto 16 Games

No nosso projeto, o CMake:

* Detecta SFML automaticamente

* Configura compila√ß√£o para C++17

* Gerencia assets (copia imagens, sons, etc.)

* Cria targets para cada jogo

* Oferece comandos de build e execu√ß√£o

### Comandos Principais

```BASH
# Configurar projeto
cmake ..

# Compilar todos os jogos
make all_games

# Compilar jogo espec√≠fico
make tetris

# Executar jogo
make run_tetris
```

## üéØ Pr√≥ximos Passos

Ap√≥s instalar o CMake com sucesso:

1. Prossiga para [Configura√ß√£o da IDE](ide-setup.html)

2. Ou pule para [Configura√ß√£o Final](environment-setup.html)

3. Ou volte para [Configura√ß√£o do Ambiente](configuracao-ambiente.html)

Se tiver problemas:

1. Consulte o [Troubleshooting](troubleshooting-setup.html)

2. Execute o script autom√°tico: `./setup.sh`

Dica: Use sempre `cmake --build .` em vez de `make` para m√°xima compatibilidade entre plataformas!



# Configura√ß√£o da IDE

Embora voc√™ possa compilar e executar os jogos apenas com terminal, usar uma IDE melhora significativamente a experi√™ncia de desenvolvimento. Este guia mostra como configurar diferentes IDEs para o projeto. üíª

## üéØ IDEs Recomendadas

### Para Iniciantes

* [Visual Studio Code](#visual-studio-code) - Leve, extens√≠vel, gratuito

* [Code::Blocks]() - Simples, focado em C++

### Para Desenvolvedores Experientes

* [CLion](#clion) - Profissional, JetBrains

* [Visual Studio](#visual-studio) - Windows, Microsoft

* [Qt Creator](#qt-creator) - Multiplataforma, excelente CMake

### Editores Avan√ßados

* [Vim/Neovim](#vim-neovim) - Para usu√°rios experientes

* [Emacs](#emacs) - Altamente customiz√°vel

## üÜö Visual Studio Code

### Instala√ß√£o

```BASH
# Linux (Ubuntu/Debian)
sudo apt update
sudo apt install code

# macOS
brew install --cask visual-studio-code

# Windows - baixar do site oficial
# https://code.visualstudio.com/
```

### Extens√µes Essenciais

Instale essas extens√µes (Ctrl+Shift+X):

1. C/C++ (Microsoft) - Suporte b√°sico ao C++

2. CMake Tools (Microsoft) - Integra√ß√£o com CMake

3. CMake (twxs) - Syntax highlighting para CMake

4. C++ Intellisense (austin) - Melhor autocomplete

5. GitLens (GitKraken) - Integra√ß√£o Git avan√ßada

### Configura√ß√£o do Projeto

#### 1. Abrir Projeto

```BASH
cd 16Games-in-Cpp
code .
```

#### 2. Configurar CMake Tools

Pressione `Ctrl+Shift+P` e digite "CMake: Configure":

```JSON
// .vscode/settings.json
{
    "cmake.configureSettings": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_CXX_STANDARD": "17"
    },
    "cmake.buildDirectory": "${workspaceFolder}/build",
    "cmake.generator": "Unix Makefiles",
    "C_Cpp.default.configurationProvider": "ms-vscode.cmake-tools"
}
```

#### 3. Configurar Tarefas de Build

```JSON
// .vscode/tasks.json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "CMake Configure",
            "type": "shell",
            "command": "cmake",
            "args": ["..", "-DCMAKE_BUILD_TYPE=Debug"],
            "options": {
                "cwd": "${workspaceFolder}/build"
            },
            "group": "build"
        },
        {
            "label": "Build All Games",
            "type": "shell",
            "command": "make",
            "args": ["all_games"],
            "options": {
                "cwd": "${workspaceFolder}/build"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            }
        }
    ]
}
```

#### 4. Configurar Launch (Debug)

```JSON
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug Tetris",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/build/games/tetris/tetris",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}/build/games/tetris",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ]
        }
    ]
}
```

## üî∑ CLion

### Configura√ß√£o

1. Abrir Projeto: File ‚Üí Open ‚Üí Selecionar pasta do projeto

2. CMake ser√° detectado automaticamente

3. Configurar Build Types:

* File ‚Üí Settings ‚Üí Build, Execution, Deployment ‚Üí CMake

* Adicionar Debug e Release profiles

### Configura√ß√µes Recomendadas

#### CMake Settings

```
Debug Profile:
- Build type: Debug
- CMake options: -DCMAKE_BUILD_TYPE=Debug
- Build directory: build/Debug

Release Profile:
- Build type: Release  
- CMake options: -DCMAKE_BUILD_TYPE=Release
- Build directory: build/Release
```

#### Run Configurations

CLion criar√° automaticamente configura√ß√µes para cada jogo. Voc√™ pode:

* Executar: Ctrl+Shift+F10

* Debug: Shift+F9

* Configurar: Run ‚Üí Edit Configurations

### Plugins √öteis

* Valgrind Memcheck - Detec√ß√£o de vazamentos

* CPU Usage Indicator - Monitor de performance

* Rainbow Brackets - Melhor visualiza√ß√£o

## ü™ü Visual Studio (Windows)

### Configura√ß√£o

1. Instalar: Visual Studio Community (gratuito)

2. Workloads: Marcar "Desktop development with C++"

3. Componentes: Incluir CMake tools

### Abrir Projeto

1. File ‚Üí Open ‚Üí CMake...

2. Selecionar `CMakeLists.txt` na raiz do projeto

3. Visual Studio configurar√° automaticamente

### Configura√ß√µes CMake

```JSON
// CMakeSettings.json (criado automaticamente)
{
  "configurations": [
    {
      "name": "x64-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "buildRoot": "${projectDir}\\build\\${name}",
      "installRoot": "${projectDir}\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    }
  ]
}
```

## üõ†Ô∏è Qt Creator

### Instala√ß√£o

```BASH
# Linux
sudo apt install qtcreator

# macOS
brew install --cask qt-creator

# Windows - baixar do site Qt
```

### Configura√ß√£o

1. Abrir: File ‚Üí Open File or Project ‚Üí CMakeLists.txt

2. Kit Selection: Escolher kit apropriado (GCC/Clang)

3. Build Directory: Configurar diret√≥rio de build

### Vantagens

* Excelente suporte CMake

* Debugger integrado

* Profiler built-in

* Git integration

## üìù Code::Blocks

### Instala√ß√£o

```BASH
# Linux
sudo apt install codeblocks

# Windows/macOS - baixar do site oficial
```

### Importar Projeto CMake

1. File ‚Üí Import ‚Üí Import CMake Project

2. Selecionar CMakeLists.txt

3. Configurar compilador e op√ß√µes

## üé≠ Vim/Neovim

### Plugins Recomendados (com vim-plug)

```VIM
" .vimrc ou init.vim
call plug#begin()

" LSP e Completions
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'clangd/coc-clangd'

" CMake
Plug 'cdelledonne/vim-cmake'
Plug 'vhdirk/vim-cmake'

" Syntax
Plug 'vim-syntastic/syntastic'
Plug 'octol/vim-cpp-enhanced-highlight'

" Git
Plug 'tpope/vim-fugitive'

call plug#end()
```

### Configura√ß√£o CMake

```VIM
" Keybindings para CMake
nnoremap <leader>cc :CMake<CR>
nnoremap <leader>cb :CMakeBuild<CR>
nnoremap <leader>cr :CMakeRun<CR>
```

## üé® Emacs

### Configura√ß√£o com use-package

```
;; init.el
(use-package cmake-mode
  :ensure t)

(use-package cmake-ide
  :ensure t
  :config
  (cmake-ide-setup))

(use-package company
  :ensure t
  :config
  (global-company-mode))

(use-package lsp-mode
  :ensure t
  :init
  (setq lsp-keymap-prefix "C-c l")
  :hook ((c++-mode . lsp))
  :commands lsp)
```

## ‚öôÔ∏è Configura√ß√£o Geral para Todas IDEs

### Formata√ß√£o de C√≥digo

Crie `.clang-format` na raiz do projeto:

```YAML
BasedOnStyle: Google
IndentWidth: 4
TabWidth: 4
UseTab: Never
ColumnLimit: 100
AllowShortFunctionsOnASingleLine: Empty
```

### EditorConfig

Crie `.editorconfig`:

```INI
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.{cpp,hpp,h}]
indent_style = space
indent_size = 4

[CMakeLists.txt,*.cmake]
indent_style = space
indent_size = 2
```

### Git Ignore para IDEs

Adicione ao `.gitignore`:

```GITIGNORE
# IDEs
.vscode/
.idea/
*.user
*.pro.user*
.cproject
.project
.settings/
*.cbp
```

## üöÄ Comandos √öteis por IDE

### VS Code

* Build: `Ctrl+Shift+P` ‚Üí "CMake: Build"

* Run: `Ctrl+F5`

* Debug: `F5`

* Terminal: `Ctrl+``` (backtick)

### CLion

* Build: `Ctrl+F9`

* Run: `Shift+F10`

* Debug: `Shift+F9`

* Terminal: `Alt+F12`

### Visual Studio

* Build: `Ctrl+Shift+B`

* Run: `Ctrl+F5`

* Debug: `F5`

* Terminal: View ‚Üí Terminal

## üéØ Dicas Gerais

### Performance

* Use SSD para diret√≥rio de build

* Configure RAM adequada (m√≠nimo 8GB)

* Feche programas desnecess√°rios durante compila√ß√£o

### Produtividade

* Configure atalhos personalizados

* Use templates para novos arquivos

* Configure snippets para c√≥digo comum

* Use git integration

### Debug

* Configure breakpoints nos pontos cr√≠ticos

* Use watch variables para monitorar estado

* Ative optimiza√ß√£o apenas em release

## üéØ Pr√≥ximos Passos

Ap√≥s configurar sua IDE:

1. Prossiga para [Configura√ß√£o Final](environment-setup.html)

2. Ou teste com [Build and Run](build-and-run.html)

3. Volte para [Configura√ß√£o do Ambiente](configuracao-ambiente.html)

Se tiver problemas:

1. Consulte o [Troubleshooting](troubleshooting-setup.html)

2. Verifique se SFML e CMake est√£o funcionando

Dica: Se √© iniciante, comece com VS Code. Se quer m√°xima produtividade, use CLion. Para projetos simples, Code::Blocks √© suficiente!



# Configura√ß√£o Final do Ambiente

Este √© o √∫ltimo passo da configura√ß√£o do ambiente. Aqui vamos integrar tudo o que foi instalado e fazer os testes finais. üèÅ

## üìã Checklist Pr√©-Requisitos

Antes de continuar, confirme que voc√™ j√° tem:

* ‚úÖ [Sistema compat√≠vel](system-requirements.html)

* ‚úÖ [SFML instalado](sfml-installation.html)

* ‚úÖ [SQLite3 instalado](null)

* ‚úÖ [CMake instalado](cmake-installation.html)

* ‚úÖ [IDE configurada](ide-setup.html) (opcional)

## üöÄ Setup Autom√°tico (Recomendado)

O m√©todo mais r√°pido e confi√°vel:

```BASH
# Clonar o reposit√≥rio
git clone <repository-url>
cd 16Games-in-Cpp

# Executar script de configura√ß√£o
chmod +x setup.sh
./setup.sh
```

O script far√°:

1. ‚úÖ Verifica√ß√£o de depend√™ncias

2. ‚úÖ Configura√ß√£o do CMake

3. ‚úÖ Compila√ß√£o de teste

4. ‚úÖ Valida√ß√£o do ambiente

Se o script executar sem erros, seu ambiente est√° pronto! üéâ

## üîß Setup Manual

Se preferir fazer manualmente ou se o script autom√°tico falhar:

### 1. Clonar e Preparar Projeto

```BASH
# Clonar reposit√≥rio
git clone <repository-url>
cd 16Games-in-Cpp

# Criar diret√≥rio de build
mkdir -p build
cd build
```

### 2. Configurar CMake

```BASH
# Configurar projeto
cmake ..

# Verificar se n√£o houve erros
echo $?  # Deve retornar 0
```

Sa√≠da esperada:

```
-- The CXX compiler identification is GNU 9.4.0
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Found PkgConfig: /usr/bin/pkg-config (found version "0.29.2")
-- Checking for modules 'sfml-all>=2.5'
--   Found sfml-all, version 2.5.1
-- Configuring done
-- Generating done
-- Build files have been written to: /path/to/16Games-in-Cpp/build
```

### 3. Teste de Compila√ß√£o

```BASH
# Compilar um jogo de teste
make tetris

# Verificar se o execut√°vel foi criado
ls games/tetris/
# Deve mostrar: tetris (e possivelmente images/)
```

### 4. Teste de Execu√ß√£o

```BASH
# Executar o jogo
cd games/tetris
./tetris

# Ou usar o target cmake
cd ../../  # voltar para build/
make run_tetris
```

Se o jogo abrir uma janela e funcionar, tudo est√° perfeito! üéÆ

## ‚úÖ Valida√ß√£o Completa

### Teste Todos os Componentes

#### 1. Verificar Todas as Depend√™ncias

```BASH
# Script de verifica√ß√£o completa
cat > check_all.sh << 'EOF'
#!/bin/bash

echo "üîç Verifica√ß√£o Completa do Ambiente"
echo "=================================="

# Verificar compilador
if g++ --version &>/dev/null; then
    echo "‚úÖ G++ - $(g++ --version | head -n1)"
else
    echo "‚ùå G++ n√£o encontrado"
    exit 1
fi

# Verificar CMake
if cmake --version &>/dev/null; then
    echo "‚úÖ CMake - $(cmake --version | head -n1)"
else
    echo "‚ùå CMake n√£o encontrado"
    exit 1
fi

# Verificar SFML
if pkg-config --exists sfml-all; then
    echo "‚úÖ SFML - $(pkg-config --modversion sfml-all)"
else
    echo "‚ùå SFML n√£o encontrado"
    exit 1
fi

# Verificar SQLite3
if pkg-config --exists sqlite3; then
    echo "‚úÖ SQLite3 - $(pkg-config --modversion sqlite3)"
else
    echo "‚ùå SQLite3 n√£o encontrado"
    exit 1
fi

# Verificar espa√ßo em disco
SPACE=$(df -BG . | tail -1 | awk '{print $4}' | sed 's/G//')
if [ $SPACE -gt 1 ]; then
    echo "‚úÖ Espa√ßo em disco - ${SPACE}GB dispon√≠vel"
else
    echo "‚ö†Ô∏è  Pouco espa√ßo em disco - ${SPACE}GB dispon√≠vel"
fi

echo ""
echo "üéâ Todos os componentes verificados com sucesso!"
EOF

chmod +x check_all.sh
./check_all.sh
```

#### 2. Compilar Todos os Jogos

```BASH
# No diret√≥rio build/
make all_games

# Verificar se todos foram compilados
ls games/
# Deve mostrar todos os 16 diret√≥rios de jogos
```

#### 3. Teste R√°pido de M√∫ltiplos Jogos

```BASH
# Script para testar v√°rios jogos
cat > test_games.sh << 'EOF'
#!/bin/bash

games=("tetris" "snake" "arkanoid" "doodle_jump")

for game in "${games[@]}"; do
    echo "üéÆ Testando $game..."
    cd "games/$game"
    timeout 3s "./$game" &>/dev/null
    if [ $? -eq 124 ]; then  # timeout (esperado)
        echo "‚úÖ $game - OK"
    else
        echo "‚ùå $game - ERRO"
    fi
    cd "../.."
done
EOF

chmod +x test_games.sh
./test_games.sh
```

## üéõÔ∏è Configura√ß√µes Opcionais

### Vari√°veis de Ambiente √öteis

Adicione ao seu `.bashrc` ou `.zshrc`:

```BASH
# Alias para o projeto 16 Games
alias games-build='cd ~/16Games-in-Cpp/build && make all_games'
alias games-clean='cd ~/16Games-in-Cpp && rm -rf build && mkdir build'
alias games-run='cd ~/16Games-in-Cpp/build'

# Vari√°veis para desenvolvimento
export GAMES_PROJECT_ROOT="$HOME/16Games-in-Cpp"
export GAMES_BUILD_DIR="$GAMES_PROJECT_ROOT/build"

# Fun√ß√£o para executar jogos rapidamente
play_game() {
    if [ -z "$1" ]; then
        echo "Uso: play_game <nome_do_jogo>"
        echo "Jogos dispon√≠veis: tetris, snake, arkanoid, etc."
        return 1
    fi
    
    cd "$GAMES_BUILD_DIR/games/$1" && "./$1"
}
```

### Configura√ß√£o de Performance

```BASH
# Para compila√ß√£o mais r√°pida
export CMAKE_BUILD_PARALLEL_LEVEL=$(nproc)
export MAKEFLAGS="-j$(nproc)"

# Para debug mais detalhado
export CMAKE_VERBOSE_MAKEFILE=ON
```

## üéÆ Testando Todos os Jogos

### Script de Teste Completo

```BASH
# Criar script de teste abrangente
cat > full_test.sh << 'EOF'
#!/bin/bash

cd "$(dirname "$0")/build"

echo "üéÆ Teste Completo dos 16 Games in C++"
echo "======================================="

games=(
    "tetris" "doodle_jump" "arkanoid" "snake" "minesweeper"
    "fifteen_puzzle" "racing" "outrun" "xonix" "bejeweled"
    "netwalk" "mahjong" "tron" "chess" "volleyball" "asteroids"
)

success=0
total=${#games[@]}

for game in "${games[@]}"; do
    echo -n "Testando $game... "
    
    if [ -f "games/$game/$game" ]; then
        echo "‚úÖ Compilado"
        ((success++))
    else
        echo "‚ùå N√£o encontrado"
    fi
done

echo ""
echo "üìä Resultado: $success/$total jogos compilados com sucesso"

if [ $success -eq $total ]; then
    echo "üéâ Todos os jogos est√£o funcionando perfeitamente!"
    echo ""
    echo "üïπÔ∏è Comandos para jogar:"
    echo "  cd build/games/tetris && ./tetris"
    echo "  make run_tetris"
    echo "  # ... e assim por diante"
else
    echo "‚ö†Ô∏è Alguns jogos n√£o foram compilados. Execute 'make all_games' novamente."
fi
EOF

chmod +x full_test.sh
./full_test.sh
```

## üìÅ Estrutura Final Esperada

Ap√≥s a configura√ß√£o completa, sua estrutura deve estar assim:

```
16Games-in-Cpp/
‚îú‚îÄ‚îÄ build/                  # Arquivos compilados
‚îÇ   ‚îú‚îÄ‚îÄ games/             # Execut√°veis dos jogos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tetris/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tetris     # Execut√°vel
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ images/    # Assets copiados
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ snake/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ... (16 jogos)
‚îÇ   ‚îî‚îÄ‚îÄ CMakeCache.txt     # Cache do CMake
‚îú‚îÄ‚îÄ 01  Tetris/            # C√≥digo fonte
‚îú‚îÄ‚îÄ 02  Doodle Jump/
‚îú‚îÄ‚îÄ ... (c√≥digo dos jogos)
‚îú‚îÄ‚îÄ CMakeLists.txt         # Configura√ß√£o CMake
‚îú‚îÄ‚îÄ setup.sh              # Script de configura√ß√£o
‚îî‚îÄ‚îÄ README.md
```

## üîß Comandos de Manuten√ß√£o

### Limpeza e Reconstru√ß√£o

```BASH
# Limpar build completo
rm -rf build
mkdir build
cd build
cmake ..
make all_games

# Ou usando script
../setup.sh
```

### Atualizar Depend√™ncias

```BASH
# Ubuntu/Debian
sudo apt update && sudo apt upgrade libsfml-dev cmake

# Fedora
sudo dnf update SFML-devel cmake

# macOS
brew update && brew upgrade sfml cmake
```

### Verifica√ß√£o de Integridade

```BASH
# Verificar arquivos corrompidos
find . -name "*.cpp" -exec g++ -fsyntax-only {} \;

# Verificar links das bibliotecas
ldd build/games/tetris/tetris  # Linux
otool -L build/games/tetris/tetris  # macOS
```

## ‚ùó Troubleshooting Final

### Problema: CMake n√£o encontra SFML

```BASH
# Verificar onde SFML est√° instalado
find /usr -name "*sfml*" 2>/dev/null

# Definir manualmente se necess√°rio
cmake .. -DSFML_ROOT=/usr/local
```

### Problema: Jogos n√£o executam

```BASH
# Verificar depend√™ncias
ldd games/tetris/tetris

# Verificar se assets foram copiados
ls games/tetris/images/

# Executar com debug
gdb games/tetris/tetris
```

### Problema: Performance ruim

```BASH
# Compilar em modo Release
cmake .. -DCMAKE_BUILD_TYPE=Release
make all_games
```

## üéØ Pr√≥ximos Passos

Ambiente configurado com sucesso! Agora voc√™ pode:

1. Jogar: Execute `make run_tetris` para testar

2. Compilar: V√° para [Guia de Compila√ß√£o](compilation-guide.html)

3. Desenvolver: Explore a [Estrutura do Projeto](estrutura-projeto.html)

4. Documentar: Veja os [Jogos](jogos.html) individuais

## üéâ Parab√©ns!

Se chegou at√© aqui com sucesso, voc√™ tem:

* ‚úÖ Ambiente completamente configurado

* ‚úÖ Todos os 16 jogos compilados

* ‚úÖ Ferramentas de desenvolvimento prontas

* ‚úÖ Scripts de manuten√ß√£o configurados

Divirta-se jogando e explorando o c√≥digo! üéÆ

Dica: Mantenha os scripts `setup.sh` e `full_test.sh` √† m√£o. Eles ser√£o √∫teis para manuten√ß√£o futura do ambiente!



# Compila√ß√£o

Este guia completo mostra como compilar, executar e gerenciar o build dos 16 jogos em C++. üî®

## üéØ Vis√£o Geral

O projeto usa CMake como sistema de build, que oferece:

* Detec√ß√£o autom√°tica de depend√™ncias

* Build multiplataforma (Linux, macOS, Windows)

* Gerenciamento de assets (imagens, sons, fonts)

* Targets individuais para cada jogo

* Comandos simplificados de execu√ß√£o

## ‚ö° Compila√ß√£o R√°pida

### Primeiro Build

```BASH
# Configurar e compilar tudo
./setup.sh

# Ou manualmente:
mkdir build && cd build
cmake ..
make all_games
```

### Builds Subsequentes

```BASH
cd build
make all_games
```

## üéÆ Compila√ß√£o por Jogo

### Jogos Dispon√≠veis

```BASH
# Listar todos os targets dispon√≠veis
make help | grep -E "(tetris|snake|arkanoid)"

# Targets dos jogos:
tetris, doodle_jump, arkanoid, snake, minesweeper
fifteen_puzzle, racing, outrun, xonix, bejeweled
netwalk, mahjong, tron, chess, volleyball, asteroids
```

### Compilar Jogo Espec√≠fico

```BASH
# Compilar apenas o Tetris
make tetris

# Compilar Snake
make snake

# Compilar Arkanoid
make arkanoid
```

### Executar Jogos

```BASH
# M√©todo 1: Target CMake (recomendado)
make run_tetris
make run_snake
make run_arkanoid

# M√©todo 2: Executar diretamente
cd games/tetris && ./tetris
cd games/snake && ./snake

# M√©todo 3: A partir do build/
./games/tetris/tetris
./games/snake/snake
```

## üîß Op√ß√µes de Build

### Tipos de Build

#### Debug (Padr√£o)

```BASH
cmake .. -DCMAKE_BUILD_TYPE=Debug
make all_games

# Caracter√≠sticas:
# - S√≠mbolos de debug inclu√≠dos
# - Otimiza√ß√µes desabilitadas  
# - Assertions habilitadas
# - Execut√°veis maiores
```

#### Release

```BASH
cmake .. -DCMAKE_BUILD_TYPE=Release
make all_games

# Caracter√≠sticas:
# - M√°xima otimiza√ß√£o (-O3)
# - Sem s√≠mbolos de debug
# - Execut√°veis menores
# - Melhor performance
```

#### RelWithDebInfo

```BASH
cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo
make all_games

# Caracter√≠sticas:
# - Otimizado + s√≠mbolos debug
# - Bom para profiling
# - Compromisso entre debug e performance
```

### Compila√ß√£o Paralela

```BASH
# Usar todos os cores dispon√≠veis
make -j$(nproc)  # Linux/macOS
make -j%NUMBER_OF_PROCESSORS%  # Windows

# Ou definir permanentemente
export MAKEFLAGS="-j$(nproc)"
make all_games
```

### Compila√ß√£o Verbose

```BASH
# Ver comandos completos de compila√ß√£o
make VERBOSE=1

# Ou configurar permanentemente
cmake .. -DCMAKE_VERBOSE_MAKEFILE=ON
make
```

## üéõÔ∏è Configura√ß√µes Avan√ßadas

### Compilador Espec√≠fico

```BASH
# Usar GCC espec√≠fico
cmake .. -DCMAKE_CXX_COMPILER=g++-9

# Usar Clang
cmake .. -DCMAKE_CXX_COMPILER=clang++

# Windows - Visual Studio
cmake .. -G "Visual Studio 16 2019"
```

### Flags de Compila√ß√£o Customizadas

```BASH
# Adicionar flags extras
cmake .. -DCMAKE_CXX_FLAGS="-Wall -Wextra -Wpedantic"

# Debug com sanitizers
cmake .. -DCMAKE_BUILD_TYPE=Debug \
         -DCMAKE_CXX_FLAGS="-fsanitize=address -fsanitize=undefined"
```

### Configurar SFML Manualmente

```BASH
# Se SFML n√£o for encontrado automaticamente
cmake .. -DSFML_ROOT=/usr/local/SFML

# Ou especificar bibliotecas
cmake .. -DSFML_LIBRARIES="sfml-system;sfml-window;sfml-graphics;sfml-audio"
```

## üìÅ Estrutura de Build

### Diret√≥rios Gerados

```
build/
‚îú‚îÄ‚îÄ CMakeCache.txt          # Cache do CMake
‚îú‚îÄ‚îÄ CMakeFiles/             # Arquivos internos do CMake
‚îú‚îÄ‚îÄ Makefile               # Makefile principal
‚îú‚îÄ‚îÄ games/                 # Execut√°veis e assets
‚îÇ   ‚îú‚îÄ‚îÄ tetris/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tetris         # Execut√°vel
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ images/        # Assets copiados
‚îÇ   ‚îú‚îÄ‚îÄ snake/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ snake
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ images/
‚îÇ   ‚îî‚îÄ‚îÄ ... (para cada jogo)
‚îî‚îÄ‚îÄ cmake_install.cmake    # Script de instala√ß√£o
```

### Assets Automaticamente Gerenciados

O CMake copia automaticamente:

* images/ ‚Üí `build/games/<jogo>/images/`

* fonts/ ‚Üí `build/games/<jogo>/fonts/`

* files/ ‚Üí `build/games/<jogo>/files/`

## üöÄ Scripts √öteis

### Build Script Personalizado

```BASH
# Criar script de build personalizado
cat > quick_build.sh << 'EOF'
#!/bin/bash

GAME="$1"
BUILD_TYPE="${2:-Debug}"

if [ -z "$GAME" ]; then
    echo "Uso: $0 <jogo> [Debug|Release]"
    echo "Jogos: tetris, snake, arkanoid, etc."
    echo "Exemplo: $0 tetris Release"
    exit 1
fi

echo "üî® Compilando $GAME em modo $BUILD_TYPE..."

# Criar/limpar build se necess√°rio
if [ ! -d "build" ]; then
    mkdir build
fi

cd build

# Configurar se necess√°rio
if [ ! -f "CMakeCache.txt" ] || [ "$BUILD_TYPE" != "$(cat CMakeCache.txt | grep CMAKE_BUILD_TYPE | cut -d'=' -f2)" ]; then
    echo "‚öôÔ∏è Configurando CMake..."
    cmake .. -DCMAKE_BUILD_TYPE="$BUILD_TYPE"
fi

# Compilar jogo espec√≠fico
echo "üîß Compilando..."
make "$GAME" -j$(nproc)

if [ $? -eq 0 ]; then
    echo "‚úÖ $GAME compilado com sucesso!"
    echo "üéÆ Para executar: make run_$GAME"
else
    echo "‚ùå Erro na compila√ß√£o!"
    exit 1
fi
EOF

chmod +x quick_build.sh

# Usar o script
./quick_build.sh tetris Debug
./quick_build.sh snake Release
```

### Clean Build Script

```BASH
# Script para limpeza completa
cat > clean_build.sh << 'EOF'
#!/bin/bash

echo "üßπ Limpando build anterior..."
rm -rf build

echo "üìÅ Criando diret√≥rio build..."
mkdir build
cd build

echo "‚öôÔ∏è Configurando CMake..."
cmake ..

echo "üî® Compilando todos os jogos..."
make all_games -j$(nproc)

echo "‚úÖ Build limpo conclu√≠do!"
EOF

chmod +x clean_build.sh
./clean_build.sh
```

## üêõ Debug e Profiling

### Compilar para Debug

```BASH
# Build com informa√ß√µes de debug
cmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="-g3 -O0"
make tetris

# Executar com GDB
gdb ./games/tetris/tetris
```

### Profiling com Valgrind

```BASH
# Compilar com s√≠mbolos de debug
cmake .. -DCMAKE_BUILD_TYPE=Debug
make tetris

# Executar com Valgrind
valgrind --tool=memcheck --leak-check=full ./games/tetris/tetris
```

### An√°lise de Performance

```BASH
# Compilar otimizado com s√≠mbolos
cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo
make tetris

# Profiling com perf (Linux)
perf record ./games/tetris/tetris
perf report
```

## üîç Troubleshooting de Compila√ß√£o

### Erro: SFML n√£o encontrado

```BASH
# Verificar instala√ß√£o
pkg-config --exists sfml-all
pkg-config --modversion sfml-all

# Limpar cache e reconfigurar
rm CMakeCache.txt
cmake .. -DSFML_ROOT=/usr/local
```

### Erro: Compilador n√£o suporta C++17

```BASH
# Verificar vers√£o do compilador
g++ --version

# Usar compilador mais novo
cmake .. -DCMAKE_CXX_COMPILER=g++-9
```

### Erro: Assets n√£o encontrados

```BASH
# Verificar se assets foram copiados
ls build/games/tetris/images/

# Recompilar para for√ßar c√≥pia
make clean
make tetris
```

### Erro: "make: command not found"

```BASH
# Linux - instalar build-essential
sudo apt install build-essential

# macOS - instalar Xcode Command Line Tools
xcode-select --install

# Windows - usar cmake --build
cmake --build . --target all_games
```

## üìä Monitoramento de Build

### Tempo de Compila√ß√£o

```BASH
# Medir tempo total
time make all_games

# Medir por jogo
time make tetris
```

### Uso de Recursos

```BASH
# Monitor durante build
htop  # Em outro terminal

# Compila√ß√£o com limite de CPU
make -j2 all_games  # Usar apenas 2 cores
```

### Tamanho dos Execut√°veis

```BASH
# Ver tamanho de todos os jogos
du -sh games/*/

# Detalhes de um jogo espec√≠fico
ls -lah games/tetris/tetris
file games/tetris/tetris
```

## üéØ Comandos de Refer√™ncia R√°pida

```BASH
# Setup inicial
./setup.sh

# Compilar tudo
make all_games

# Compilar jogo espec√≠fico
make <nome_do_jogo>

# Executar jogo
make run_<nome_do_jogo>

# Limpar e reconstruir
rm -rf build && mkdir build && cd build && cmake .. && make all_games

# Build otimizado
cmake .. -DCMAKE_BUILD_TYPE=Release && make all_games

# Build paralelo
make -j$(nproc) all_games

# Ver comandos dispon√≠veis
make help
```

## üéØ Pr√≥ximos Passos

Agora que voc√™ domina a compila√ß√£o:

1. Explore [Build and Run](build-and-run.html) para execu√ß√£o pr√°tica

2. Veja [Running Games](running-games.html) para mais op√ß√µes de execu√ß√£o

3. Consulte [Estrutura do Projeto](estrutura-projeto.html) para entender o c√≥digo

Se encontrar problemas:

1. Verifique [Troubleshooting](troubleshooting-setup.html)

2. Confirme que seguiu [Configura√ß√£o do Ambiente](configuracao-ambiente.html)

Dica: Use `make -j$(nproc)` para compila√ß√£o mais r√°pida, e `make run_<jogo>` para executar diretamente!



# Guia de Compila√ß√£o

Este guia explica como compilar os jogos do projeto "16 Games in C++". Vamos abordar desde os conceitos b√°sicos at√© t√©cnicas avan√ßadas de compila√ß√£o.

## O que √© Compila√ß√£o

Compila√ß√£o √© o processo de transformar o c√≥digo fonte que escrevemos (em C++) em um programa execut√°vel que o computador consegue entender e executar. √â como traduzir um texto do portugu√™s para uma linguagem que o computador entende.

## Pr√©-requisitos

Antes de compilar os jogos, voc√™ precisa ter algumas ferramentas instaladas no seu sistema:

### Ferramentas Necess√°rias

```MERMAID
graph TB
    A[Ferramentas de Compila√ß√£o] --> B[Compilador C++]
    A --> C[CMake]
    A --> D[SFML]
    A --> E[Make]
    
    B --> B1[GCC ou Clang]
    C --> C1[Vers√£o 3.10+]
    D --> D1[Vers√£o 2.5+]
    E --> E1[GNU Make]
```

### 1. Compilador C++

Um compilador √© o programa que converte seu c√≥digo C++ em c√≥digo execut√°vel.

Op√ß√µes dispon√≠veis:

* GCC (GNU Compiler Collection): O compilador mais comum no Linux

* Clang: Compilador alternativo com √≥timas mensagens de erro

* MSVC: Compilador da Microsoft para Windows

Como verificar se est√° instalado:

```BASH
g++ --version      # Para GCC
clang++ --version  # Para Clang
```

### 2. CMake

CMake √© uma ferramenta que facilita o processo de compila√ß√£o de projetos complexos. Ele gera automaticamente os arquivos necess√°rios para compilar seu projeto.

Por que usar CMake:

* Funciona em diferentes sistemas operacionais

* Gerencia depend√™ncias automaticamente

* Configura op√ß√µes de compila√ß√£o

* Organiza projetos com m√∫ltiplos arquivos

Como verificar se est√° instalado:

```BASH
cmake --version
```

### 3. SFML (Simple and Fast Multimedia Library)

SFML √© a biblioteca que usamos para criar os jogos. Ela fornece funcionalidades para:

* Criar janelas e interfaces gr√°ficas

* Desenhar sprites e formas

* Reproduzir sons

* Capturar entrada do teclado e mouse

Como verificar se est√° instalado:

```BASH
pkg-config --exists sfml-all && echo "SFML instalado" || echo "SFML n√£o encontrado"
```

## Sistema de Compila√ß√£o do Projeto

Nosso projeto usa um sistema de compila√ß√£o em duas camadas:

```MERMAID
flowchart TD
    A[Makefile Simplificado] --> B[CMake Sistema]
    B --> C[Compilador C++]
    C --> D[Execut√°veis dos Jogos]
    
    A1[make build] --> A
    A2[make run-tetris] --> A
    A3[make clean] --> A
    
    B1[CMakeLists.txt] --> B
    B2[Configura√ß√£o Autom√°tica] --> B
    B3[C√≥pia de Assets] --> B
    
    C1[Linkagem com SFML] --> C
    C2[Otimiza√ß√µes] --> C
```

### Camada 1: Makefile Simplificado

O Makefile fornece comandos f√°ceis de usar:

```BASH
make setup          # Configura√ß√£o inicial
make build          # Compilar todos os jogos
make build-tetris   # Compilar apenas o Tetris
make run-tetris     # Executar o Tetris
make clean          # Limpar arquivos tempor√°rios
```

### Camada 2: CMake

O CMake gerencia a compila√ß√£o real:

* Encontra as bibliotecas necess√°rias (SFML)

* Configura op√ß√µes de compila√ß√£o

* Cria execut√°veis para cada jogo

* Copia assets (imagens, fontes) para os locais corretos

## Processo de Compila√ß√£o Passo a Passo

### Configura√ß√£o Inicial

```BASH
# 1. Executar o script de configura√ß√£o
./setup.sh
```

Este script:

1. Verifica se todas as depend√™ncias est√£o instaladas

2. Cria o diret√≥rio `build`

3. Configura o CMake

4. Testa a compila√ß√£o com o jogo Tetris

### Compila√ß√£o Individual

Para compilar um jogo espec√≠fico:

```BASH
# M√©todo 1: Usando Makefile (mais simples)
make build-tetris

# M√©todo 2: Usando CMake diretamente
cd build
make tetris
```

### Compila√ß√£o de Todos os Jogos

```BASH
# M√©todo 1: Usando Makefile
make build

# M√©todo 2: Usando CMake diretamente
cd build
make all_games
```

## Estrutura de Arquivos de Compila√ß√£o

Quando voc√™ compila um jogo, o CMake organiza os arquivos assim:

```
build/
‚îú‚îÄ‚îÄ games/
‚îÇ   ‚îú‚îÄ‚îÄ tetris/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tetris              # Execut√°vel
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ images/             # Assets copiados
‚îÇ   ‚îú‚îÄ‚îÄ doodle_jump/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ doodle_jump         # Execut√°vel
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images/             # Assets copiados
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fonts/              # Fontes copiadas
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ CMakeFiles/                 # Arquivos internos do CMake
‚îî‚îÄ‚îÄ Makefile                    # Makefile gerado pelo CMake
```

### Por que Essa Estrutura?

1. Organiza√ß√£o: Cada jogo tem sua pr√≥pria pasta

2. Assets Isolados: Imagens e recursos ficam junto ao execut√°vel

3. Execu√ß√£o Simples: Cada jogo pode ser executado de sua pr√≥pria pasta

4. Facilita Debug: Problemas ficam isolados por jogo

## Entendendo o CMakeLists.txt

O arquivo `CMakeLists.txt` √© o "manual de instru√ß√µes" para o CMake. Vamos entender as partes principais:

### Configura√ß√£o B√°sica

```CMAKE
cmake_minimum_required(VERSION 3.10)  # Vers√£o m√≠nima do CMake
project(16Games LANGUAGES CXX)        # Nome do projeto e linguagem
set(CMAKE_CXX_STANDARD 17)            # Usar C++17
```

### Encontrar Depend√™ncias

```CMAKE
find_package(PkgConfig REQUIRED)           # Ferramenta para encontrar bibliotecas
pkg_check_modules(SFML REQUIRED sfml-all)  # Encontrar SFML
```

### Fun√ß√£o para Criar Jogos

```CMAKE
function(add_game GAME_NAME GAME_DIR)
    # Encontrar arquivos .cpp e .hpp
    file(GLOB_RECURSE GAME_SOURCES "${GAME_DIR}/*.cpp" "${GAME_DIR}/*.hpp")
    
    # Criar execut√°vel
    add_executable(${GAME_NAME} ${GAME_SOURCES})
    
    # Linkar com SFML
    target_link_libraries(${GAME_NAME} ${SFML_LIBRARIES})
    
    # Copiar assets
    # ...
endfunction()
```

## Tipos de Compila√ß√£o

### Debug vs Release

Debug Mode (Modo de Depura√ß√£o):

* C√≥digo mais lento

* Inclui informa√ß√µes para debugging

* Facilita encontrar erros

Release Mode (Modo de Lan√ßamento):

* C√≥digo otimizado e mais r√°pido

* Menor tamanho de arquivo

* Sem informa√ß√µes de debug

```BASH
# Compilar em modo debug (padr√£o)
cmake ..

# Compilar em modo release
cmake -DCMAKE_BUILD_TYPE=Release ..
```

### Compila√ß√£o Paralela

Para acelerar a compila√ß√£o, use m√∫ltiplos cores do processador:

```BASH
# Usar 4 cores para compilar
make -j4

# Usar todos os cores dispon√≠veis
make -j$(nproc)
```

## Resolvendo Problemas de Compila√ß√£o

### Erro: SFML n√£o encontrado

```
‚ùå Erro: Package 'sfml-all' not found
```

Solu√ß√£o:

```BASH
# Ubuntu/Debian
sudo apt-get install libsfml-dev

# Fedora
sudo dnf install SFML-devel

# Arch Linux
sudo pacman -S sfml
```

### Erro: CMake muito antigo

```
‚ùå Erro: CMake 3.10 or higher is required
```

Solu√ß√£o:

```BASH
# Ubuntu/Debian
sudo apt-get install cmake

# Ou instalar vers√£o mais nova
sudo snap install cmake --classic
```

### Erro: Compilador n√£o encontrado

```
‚ùå Erro: No CMAKE_CXX_COMPILER could be found
```

Solu√ß√£o:

```BASH
# Ubuntu/Debian
sudo apt-get install build-essential

# Fedora
sudo dnf group install "Development Tools"
```

### Erro: Arquivo n√£o encontrado durante execu√ß√£o

```
‚ùå Erro: Failed to load images/background.png
```

Solu√ß√£o:

* Verificar se os assets foram copiados corretamente

* Executar o jogo do diret√≥rio correto:

```BASH
cd build/games/tetris
./tetris
```

## Compila√ß√£o Customizada

### Adicionando Flags de Compila√ß√£o

Para adicionar op√ß√µes especiais de compila√ß√£o, edite o `CMakeLists.txt`:

```CMAKE
# Adicionar flags de warning
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra")

# Adicionar otimiza√ß√µes espec√≠ficas
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -march=native")
```

### Compila√ß√£o Condicional

```CMAKE
# Compilar apenas jogos funcionais
if(EXISTS "${CMAKE_SOURCE_DIR}/${GAME_DIR}/main.cpp")
    add_game(${GAME_NAME} ${GAME_DIR})
endif()
```

## Scripts de Automa√ß√£o

### Script de Teste R√°pido

```BASH
#!/bin/bash
echo "Testando compila√ß√£o de todos os jogos..."
make clean
make build

if [ $? -eq 0 ]; then
    echo "‚úÖ Todos os jogos compilaram com sucesso!"
else
    echo "‚ùå Erro na compila√ß√£o"
    exit 1
fi
```

### Script de Deploy

```BASH
#!/bin/bash
echo "Criando pacote de distribui√ß√£o..."
make clean
cmake -DCMAKE_BUILD_TYPE=Release ..
make all_games

# Criar arquivo tar com todos os jogos
tar -czf 16games-release.tar.gz build/games/
```

## Otimiza√ß√£o de Performance

### Compila√ß√£o Otimizada

```BASH
# Configurar para m√°xima performance
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-O3 -march=native" ..
```

### Profile-Guided Optimization (PGO)

Para jogos com alta performance:

```BASH
# 1. Compilar com instrumenta√ß√£o
cmake -DCMAKE_CXX_FLAGS="-fprofile-generate" ..
make tetris

# 2. Executar para coletar dados
./games/tetris/tetris

# 3. Recompilar com otimiza√ß√µes baseadas no perfil
cmake -DCMAKE_CXX_FLAGS="-fprofile-use" ..
make tetris
```

## Integra√ß√£o com IDEs

### CLion

1. Abrir o diret√≥rio do projeto

2. CLion detectar√° automaticamente o CMakeLists.txt

3. Configurar build profiles (Debug/Release)

4. Usar os targets autom√°ticos para compilar e executar

### Visual Studio Code

1. Instalar extens√µes: C/C++, CMake Tools

2. Abrir o projeto

3. Configurar kit de compila√ß√£o

4. Usar paleta de comandos: "CMake: Build"

### Code::Blocks

1. Criar projeto vazio

2. Adicionar arquivos fonte

3. Configurar linker para SFML

4. Configurar diret√≥rios de include

## Conclus√£o

A compila√ß√£o √© um processo fundamental no desenvolvimento de jogos. Nosso projeto usa um sistema robusto que:

* Automatiza tarefas repetitivas

* Organiza arquivos de forma l√≥gica

* Facilita a manuten√ß√£o e debugging

* Funciona em diferentes sistemas operacionais

Dominar esses conceitos te permitir√° n√£o apenas compilar os jogos existentes, mas tamb√©m modific√°-los, criar novos jogos e entender como projetos maiores s√£o organizados.

Pr√≥ximos passos:

1. Pratique com diferentes jogos

2. Experimente modificar op√ß√µes de compila√ß√£o

3. Tente adicionar novos arquivos a um jogo existente

4. Aprenda a usar ferramentas de debugging como GDB



# Compilar e Executar Jogos

Este guia mostra como compilar e executar os jogos de forma pr√°tica e eficiente. Aprenda desde comandos b√°sicos at√© t√©cnicas avan√ßadas de execu√ß√£o.

## Compila√ß√£o R√°pida

### Configura√ß√£o Inicial (Apenas Uma Vez)

Antes de compilar qualquer jogo, execute a configura√ß√£o inicial:

```BASH
# Na pasta raiz do projeto
./setup.sh
```

Este comando:

* Verifica se todas as depend√™ncias est√£o instaladas

* Configura o ambiente de compila√ß√£o

* Testa a compila√ß√£o com um jogo simples

* Prepara o sistema para uso

```MERMAID
graph TD
    A[./setup.sh] --> B{Verificar SFML}
    B -->|‚úÖ OK| C{Verificar CMake}
    B -->|‚ùå Erro| D[Instalar SFML]
    C -->|‚úÖ OK| E{Verificar Compilador}
    C -->|‚ùå Erro| F[Instalar CMake]
    E -->|‚úÖ OK| G[Configurar CMake]
    E -->|‚ùå Erro| H[Instalar GCC/Clang]
    G --> I[Testar Tetris]
    I --> J[‚úÖ Pronto para usar]
```

## M√©todos de Compila√ß√£o

### M√©todo 1: Makefile Simplificado (Recomendado)

O m√©todo mais f√°cil para iniciantes:

```BASH
# Compilar todos os jogos
make build

# Compilar um jogo espec√≠fico
make build-tetris
make build-doodle_jump
make build-snake

# Executar diretamente
make run-tetris
make run-doodle_jump
make run-snake
```

### M√©todo 2: CMake Direto

Para usu√°rios mais avan√ßados:

```BASH
# Entrar na pasta de build
cd build

# Compilar todos os jogos
make all_games

# Compilar um jogo espec√≠fico
make tetris
make doodle_jump
make snake

# Executar um jogo
make run_tetris
make run_doodle_jump
make run_snake
```

### M√©todo 3: Execu√ß√£o Direta

Ap√≥s compilar, voc√™ pode executar diretamente:

```BASH
# Navegar para o jogo
cd build/games/tetris

# Executar
./tetris
```

## Compila√ß√£o por Categoria

### Jogos de Puzzle

```BASH
# Tetris - O cl√°ssico jogo de blocos
make build-tetris && make run-tetris

# Fifteen Puzzle - Quebra-cabe√ßa num√©rico  
make build-fifteen_puzzle && make run-fifteen_puzzle

# Minesweeper - Campo minado
make build-minesweeper && make run-minesweeper

# NetWalk - Conectar tubula√ß√µes
make build-netwalk && make run-netwalk

# Mahjong Solitaire - Paci√™ncia com pe√ßas
make build-mahjong && make run-mahjong
```

### Jogos de A√ß√£o

```BASH
# Doodle Jump - Pular nas plataformas
make build-doodle_jump && make run-doodle_jump

# Snake - A serpente cl√°ssica
make build-snake && make run-snake

# Arkanoid - Quebrar blocos com a bola
make build-arkanoid && make run-arkanoid

# Asteroids - Destruir asteroides no espa√ßo
make build-asteroids && make run-asteroids
```

### Jogos de Estrat√©gia

```BASH
# Chess - Xadrez com IA
make build-chess && make run-chess

# Bejeweled - Combinar joias
make build-bejeweled && make run-bejeweled

# Xonix - Conquistar territ√≥rio
make build-xonix && make run-xonix
```

## Verifica√ß√£o de Compila√ß√£o

### Status dos Jogos

Nem todos os jogos podem estar funcionais. Vamos verificar o status:

```BASH
# Tentar compilar todos e ver quais funcionam
make build 2>&1 | grep -E "(‚úÖ|‚ùå|Error|error)"
```

### Teste Individual

Para testar se um jogo espec√≠fico funciona:

```BASH
# Testar Tetris
echo "Testando Tetris..."
if make build-tetris; then
    echo "‚úÖ Tetris compilou com sucesso!"
    make run-tetris
else
    echo "‚ùå Erro na compila√ß√£o do Tetris"
fi
```

### Script de Teste Automatizado

Crie um script para testar todos os jogos:

```BASH
#!/bin/bash
# Salve como test_all_games.sh

games=("tetris" "doodle_jump" "arkanoid" "snake" "minesweeper" 
       "fifteen_puzzle" "racing" "xonix" "bejeweled" "netwalk")

echo "Testando compila√ß√£o de todos os jogos..."
echo "======================================="

for game in "${games[@]}"; do
    echo -n "Testando $game... "
    if make build-$game &>/dev/null; then
        echo "‚úÖ"
    else
        echo "‚ùå"
    fi
done
```

## Execu√ß√£o Avan√ßada

### Execu√ß√£o com Par√¢metros

Alguns jogos podem aceitar par√¢metros de linha de comando:

```BASH
# Executar com resolu√ß√£o espec√≠fica (se suportado)
cd build/games/tetris
./tetris --width=800 --height=600

# Executar em modo fullscreen (se suportado)
./tetris --fullscreen
```

### Execu√ß√£o com Debugging

Para investigar problemas:

```BASH
# Executar com GDB (debugger)
cd build/games/tetris
gdb ./tetris

# Comandos no GDB:
# (gdb) run          # Executar o programa
# (gdb) bt           # Ver stack trace se houver crash
# (gdb) quit         # Sair do GDB
```

### Execu√ß√£o com Profiling

Para medir performance:

```BASH
# Medir tempo de execu√ß√£o
cd build/games/tetris
time ./tetris

# Profiling detalhado com valgrind
valgrind --tool=callgrind ./tetris
```

## Gerenciamento de Assets

### Verificar Assets

Os jogos dependem de arquivos de imagem e som. Para verificar se est√£o corretos:

```BASH
# Verificar se as imagens foram copiadas
ls build/games/tetris/images/

# Verificar se as fontes foram copiadas (Doodle Jump)
ls build/games/doodle_jump/fonts/
```

### Recopiar Assets

Se algum asset n√£o foi copiado corretamente:

```BASH
# Limpar build e recompilar
make clean
make build-tetris
```

### Assets Customizados

Para usar seus pr√≥prios assets:

1. Substituir arquivos na pasta original:

```BASH
# Exemplo: trocar a imagem de fundo do Tetris
cp minha_imagem.png "01  Tetris/images/background.png"
```

1. Recompilar o jogo:

```BASH
make clean
make build-tetris
```

## Compila√ß√£o em Lote

### Compilar Jogos Funcionais

Script para compilar apenas jogos que funcionam:

```BASH
#!/bin/bash
# Lista de jogos que compilam sem erro
working_games=("tetris" "doodle_jump" "arkanoid" "snake" "minesweeper")

echo "Compilando jogos funcionais..."
for game in "${working_games[@]}"; do
    echo "Compilando $game..."
    make build-$game
done

echo "‚úÖ Jogos funcionais compilados!"
```

### Compila√ß√£o Paralela

Para acelerar a compila√ß√£o usando m√∫ltiplos cores:

```BASH
# Usar 4 cores
cd build
make -j4 all_games

# Usar todos os cores dispon√≠veis
make -j$(nproc) all_games
```

## Resolu√ß√£o de Problemas

### Problemas Comuns de Compila√ß√£o

#### Erro: SFML n√£o encontrado

```
error: Package 'sfml-all' not found
```

Solu√ß√£o:

```BASH
# Ubuntu/Debian
sudo apt-get install libsfml-dev

# Reconfigurar
make clean
./setup.sh
```

#### Erro: Arquivos n√£o encontrados na execu√ß√£o

```
Failed to load images/background.png
```

Solu√ß√µes:

1. Verificar diret√≥rio de execu√ß√£o:

```BASH
# Sempre executar da pasta do jogo
cd build/games/tetris
./tetris
```

1. Recompilar para recopiar assets:

```BASH
make clean
make build-tetris
```

#### Erro: Permiss√£o negada

```
bash: ./tetris: Permission denied
```

Solu√ß√£o:

```BASH
# Dar permiss√£o de execu√ß√£o
chmod +x build/games/tetris/tetris
```

### Debugging de Problemas

#### Verificar Depend√™ncias

```BASH
# Verificar se o execut√°vel foi linkado corretamente
ldd build/games/tetris/tetris

# Deve mostrar libsfml-* nas depend√™ncias
```

#### Verificar Assets

```BASH
# Verificar se todos os assets est√£o presentes
find build/games/tetris/ -name "*.png" -o -name "*.jpg" -o -name "*.ttf"
```

#### Log de Execu√ß√£o

```BASH
# Executar com output detalhado
cd build/games/tetris
./tetris 2>&1 | tee tetris.log

# Verificar o log
cat tetris.log
```

## Automa√ß√£o com Scripts

### Script Completo de Build e Test

```BASH
#!/bin/bash
# build_and_test.sh

set -e  # Parar se houver erro

echo "üéÆ Build e Test Automatizado"
echo "============================="

# Configura√ß√£o inicial
echo "1Ô∏è‚É£ Configurando ambiente..."
./setup.sh

# Lista de jogos para testar
games=("tetris" "doodle_jump" "snake" "arkanoid" "minesweeper")

echo "2Ô∏è‚É£ Compilando jogos..."
for game in "${games[@]}"; do
    echo "   Compilando $game..."
    make build-$game
done

echo "3Ô∏è‚É£ Testando execu√ß√£o (5 segundos cada)..."
for game in "${games[@]}"; do
    echo "   Testando $game..."
    cd build/games/$game
    timeout 5s ./$game || echo "   (Fechado automaticamente)"
    cd - > /dev/null
done

echo "‚úÖ Build e teste conclu√≠dos!"
```

### Script de Limpeza

```BASH
#!/bin/bash
# clean_all.sh

echo "üßπ Limpando arquivos de build..."

# Remover diret√≥rio build
rm -rf build

# Remover arquivos tempor√°rios
find . -name "*.o" -delete
find . -name "*.so" -delete
find . -name "core" -delete

echo "‚úÖ Limpeza conclu√≠da!"
```

## Performance e Otimiza√ß√£o

### Compila√ß√£o Otimizada

```BASH
# Compilar em modo Release (otimizado)
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
make all_games
```

### Medi√ß√£o de Performance

```BASH
# Medir tempo de compila√ß√£o
time make all_games

# Medir uso de mem√≥ria durante compila√ß√£o
/usr/bin/time -v make tetris
```

### Compila√ß√£o Incremental

Para desenvolvimento, compile apenas o que mudou:

```BASH
# Depois de modificar c√≥digo, apenas:
cd build
make tetris  # S√≥ recompila se necess√°rio
```

## Integra√ß√£o com Editor/IDE

### Visual Studio Code

Configurar tasks.json para compila√ß√£o r√°pida:

```JSON
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build Tetris",
            "type": "shell",
            "command": "make",
            "args": ["build-tetris"],
            "group": "build"
        },
        {
            "label": "Run Tetris", 
            "type": "shell",
            "command": "make",
            "args": ["run-tetris"],
            "group": "test"
        }
    ]
}
```

### CLion

1. Abrir projeto (CLion detecta CMakeLists.txt automaticamente)

2. Configurar targets de build

3. Usar bot√µes de Run/Debug diretamente na IDE

## Conclus√£o

Compilar e executar jogos √© um processo que envolve v√°rias etapas, mas com os m√©todos corretos torna-se simples e eficiente. O projeto oferece m√∫ltiplas formas de abordar a compila√ß√£o:

* Para iniciantes: Use `make build` e `make run-nome_do_jogo`

* Para desenvolvimento: Use compila√ß√£o incremental e debugging

* Para distribui√ß√£o: Use compila√ß√£o otimizada em modo Release

Dominar essas t√©cnicas permitir√° que voc√™ n√£o apenas execute os jogos existentes, mas tamb√©m modifique e crie novos jogos com confian√ßa.



# Executando os Jogos

Este guia completo mostra como executar cada um dos 16 jogos, incluindo controles, objetivos e dicas para cada jogo.

## Formas de Executar

### M√©todo R√°pido (Recomendado)

```BASH
# Compilar e executar em um comando
make run-tetris
make run-doodle_jump
make run-snake
make run-arkanoid
```

### M√©todo Manual

```BASH
# 1. Compilar primeiro
make build-tetris

# 2. Navegar para a pasta do jogo  
cd build/games/tetris

# 3. Executar
./tetris
```

### M√©todo Direto (Ap√≥s compila√ß√£o)

```BASH
# Se j√° compilou antes, pode executar diretamente
cd build/games/tetris && ./tetris
```

## Jogos Dispon√≠veis

### Status de Funcionamento

```MERMAID
graph TD
    A[16 Jogos] --> B[Funcionais ‚úÖ]
    A --> C[Em Desenvolvimento üöß]
    A --> D[Com Problemas ‚ùå]
    
    B --> B1[Tetris]
    B --> B2[Doodle Jump]
    B --> B3[Snake]
    B --> B4[Arkanoid]
    B --> B5[Minesweeper]
    B --> B6[Fifteen Puzzle]
    B --> B7[Racing]
    B --> B8[Xonix]
    B --> B9[Bejeweled]
    B --> B10[NetWalk]
    B --> B11[Mahjong]
    B --> B12[Asteroids]
    
    C --> C1[Outrun]
    C --> C2[Chess]
    C --> C3[Volleyball]
    C --> C4[Tron]
```

## Guia Individual dos Jogos

### 1. Tetris

Como executar:

```BASH
make run-tetris
```

Controles:

* Setas Esquerda/Direita: Mover pe√ßa

* Seta Baixo: Acelerar queda

* Seta Cima: Rotacionar pe√ßa

* Espa√ßo: Drop instant√¢neo

Objetivo: Completar linhas horizontais para elimin√°-las. O jogo acelera conforme voc√™ progride.

Dicas:

* Deixe espa√ßos para pe√ßas longas (I-tetromino)

* N√£o acumule pe√ßas muito alto

* Use o drop instant√¢neo para pontua√ß√£o extra

### 2. Doodle Jump

Como executar:

```BASH
make run-doodle_jump
```

Controles:

* Setas Esquerda/Direita: Mover personagem

* Espa√ßo: Iniciar jogo (no menu)

* R: Reiniciar (game over)

* M: Voltar ao menu

Objetivo: Pule de plataforma em plataforma, alcan√ßando a maior altura poss√≠vel.

Dicas:

* Use o movimento horizontal para alcan√ßar plataformas distantes

* O personagem "atravessa" a tela (sai de um lado, aparece do outro)

* Quanto mais alto, mais pontos voc√™ ganha

### 3. Snake

Como executar:

```BASH
make run-snake
```

Controles:

* Setas: Dire√ß√£o da serpente

* N√£o pode voltar na dire√ß√£o contr√°ria

Objetivo: Comer comida para crescer, evitando colidir com as bordas ou com o pr√≥prio corpo.

Dicas:

* Planeje sua rota com anteced√™ncia

* Evite criar "armadilhas" para si mesmo

* Use as bordas da tela estrategicamente

### 4. Arkanoid

Como executar:

```BASH
make run-arkanoid
```

Controles:

* Setas Esquerda/Direita: Mover raquete

* Espa√ßo: Iniciar jogo/Lan√ßar bola

Objetivo: Quebrar todos os blocos rebatendo a bola com a raquete.

Dicas:

* Mantenha a bola sempre em movimento

* Use os √¢ngulos da raquete para controlar a dire√ß√£o

* Mire nos cantos dos blocos para √¢ngulos interessantes

### 5. Minesweeper (Campo Minado)

Como executar:

```BASH
make run-minesweeper
```

Controles:

* Click Esquerdo: Revelar c√©lula

* Click Direito: Marcar/desmarcar bandeira

* (Pode variar dependendo da implementa√ß√£o)

Objetivo: Revelar todas as c√©lulas sem bombas, usando n√∫meros como pistas.

Dicas:

* N√∫meros indicam quantas bombas est√£o adjacentes

* Comece pelos cantos e bordas

* Use bandeiras para marcar bombas conhecidas

### 6. Fifteen Puzzle

Como executar:

```BASH
make run-fifteen_puzzle
```

Controles:

* Setas: Mover pe√ßas

* Mouse: Clicar em pe√ßas adjacentes ao espa√ßo vazio

Objetivo: Organizar n√∫meros de 1 a 15 em ordem, deixando o espa√ßo vazio no canto inferior direito.

Dicas:

* Resolva linha por linha, de cima para baixo

* Use o espa√ßo vazio estrategicamente

* √öltimas duas linhas requerem t√©cnica especial

### 7. Racing (Top Down)

Como executar:

```BASH
make run-racing
```

Controles:

* Setas: Dire√ß√£o do carro

* Acelerar/Freiar (dependendo da implementa√ß√£o)

Objetivo: Completar voltas na pista no menor tempo poss√≠vel.

Dicas:

* Freie antes das curvas

* Use a pista inteira nas curvas

* Mantenha velocidade constante nas retas

### 8. Xonix

Como executar:

```BASH
make run-xonix
```

Controles:

* Setas: Mover personagem

Objetivo: Conquistar territ√≥rio desenhando linhas, evitando inimigos.

Dicas:

* Fa√ßa movimentos r√°pidos para evitar inimigos

* Conquiste pequenas √°reas por vez

* Cuidado com inimigos que seguem sua trilha

### 9. Bejeweled

Como executar:

```BASH
make run-bejeweled
```

Controles:

* Mouse: Selecionar e trocar joias

* Setas: Navegar (se implementado)

Objetivo: Formar grupos de 3 ou mais joias iguais para elimin√°-las.

Dicas:

* Procure por grupos de 4 ou 5 para power-ups

* Planeje v√°rias jogadas em sequ√™ncia

* Observe oportunidades de cascata

### 10. NetWalk

Como executar:

```BASH
make run-netwalk
```

Controles:

* Mouse: Clicar para rotacionar pe√ßas

* Setas: Navegar pelo grid

Objetivo: Conectar todas as pe√ßas de tubula√ß√£o para formar uma rede completa.

Dicas:

* Comece pelas pe√ßas de canto (menos op√ß√µes)

* Identifique o caminho principal primeiro

* Rotacione pe√ßas sistematicamente

### 11. Mahjong Solitaire

Como executar:

```BASH
make run-mahjong
```

Controles:

* Mouse: Selecionar pe√ßas

* Scroll: Rotacionar visualiza√ß√£o (se 3D)

Objetivo: Remover todas as pe√ßas combinando pares iguais que estejam livres.

Dicas:

* Uma pe√ßa est√° "livre" se n√£o h√° pe√ßas em cima ou dos lados

* Procure por pe√ßas √∫nicas primeiro

* Planeje para n√£o bloquear pe√ßas necess√°rias

### 12. Asteroids

Como executar:

```BASH
make run-asteroids
```

Controles:

* Setas: Rotacionar e acelerar nave

* Espa√ßo: Atirar

* Shift/Ctrl: Escudo/Hiper-espa√ßo (se implementado)

Objetivo: Destruir todos os asteroides sem ser atingido.

Dicas:

* Asteroides grandes se dividem em menores

* Use o impulso com cuidado (sem atrito no espa√ßo)

* Aten√ß√£o √†s bordas da tela (wraparound)

## Jogos em Desenvolvimento

### 13. Outrun

Status: üöß Em desenvolvimento
Problema comum: Renderiza√ß√£o 3D complexa

### 14. Chess

Status: üöß Em desenvolvimento
Problema comum: IA e valida√ß√£o de movimentos

### 15. Volleyball

Status: üöß Em desenvolvimento
Problema comum: F√≠sica da bola e multiplayer

### 16. Tron

Status: üöß Em desenvolvimento
Problema comum: Trail rendering e IA

## Solu√ß√£o de Problemas na Execu√ß√£o

### Jogo n√£o inicia

```BASH
# Verificar se foi compilado
ls build/games/tetris/tetris

# Verificar permiss√µes
chmod +x build/games/tetris/tetris

# Tentar executar com debug
cd build/games/tetris
gdb ./tetris
```

### Erro "Failed to load image"

```BASH
# Verificar se assets est√£o presentes
ls build/games/tetris/images/

# Recompilar para recopiar assets
make clean
make build-tetris
```

### Jogo executa mas tela preta

Poss√≠veis causas:

* Assets n√£o encontrados

* Problema com drivers gr√°ficos

* Resolu√ß√£o incompat√≠vel

Solu√ß√µes:

```BASH
# Verificar se SFML funciona
pkg-config --exists sfml-all && echo "OK" || echo "Problema"

# Testar com jogo mais simples
make run-snake  # Snake usa menos recursos gr√°ficos
```

### Performance ruim

```BASH
# Compilar em modo otimizado
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
make tetris

# Verificar uso de recursos
top -p $(pgrep tetris)
```

## Scripts √öteis

### Testar Todos os Jogos

```BASH
#!/bin/bash
# test_all.sh

games=("tetris" "doodle_jump" "snake" "arkanoid" "minesweeper" 
       "fifteen_puzzle" "racing" "xonix" "bejeweled" "netwalk" 
       "mahjong" "asteroids")

for game in "${games[@]}"; do
    echo "Testando $game..."
    if make run-$game &>/dev/null & then
        PID=$!
        sleep 3
        kill $PID 2>/dev/null
        echo "‚úÖ $game funciona"
    else
        echo "‚ùå $game tem problemas"
    fi
done
```

### Menu Interativo

```BASH
#!/bin/bash
# game_menu.sh

echo "üéÆ Seletor de Jogos"
echo "=================="
echo "1) Tetris"
echo "2) Doodle Jump" 
echo "3) Snake"
echo "4) Arkanoid"
echo "5) Minesweeper"
echo "0) Sair"

read -p "Escolha um jogo (0-5): " choice

case $choice in
    1) make run-tetris ;;
    2) make run-doodle_jump ;;
    3) make run-snake ;;
    4) make run-arkanoid ;;
    5) make run-minesweeper ;;
    0) echo "Tchau!" ;;
    *) echo "Op√ß√£o inv√°lida" ;;
esac
```

## Dicas Gerais de Execu√ß√£o

### Controles Universais

A maioria dos jogos usa:

* ESC: Sair do jogo

* Enter: Confirmar/Pausar

* Espa√ßo: A√ß√£o principal

* Setas: Navega√ß√£o/Movimento

### Resolu√ß√£o de Tela

Alguns jogos podem ter resolu√ß√£o fixa. Se a janela ficar muito pequena ou grande:

1. Modificar c√≥digo fonte (avan√ßado):

```CPP
// Procurar por linhas como:
RenderWindow window(VideoMode(800, 600), "Nome do Jogo");
```

1. Usar modo janela:

* A maioria dos jogos abre em janela

* Pode ser poss√≠vel redimensionar manualmente

### Performance

Para melhor performance:

* Feche outros programas

* Use modo Release quando compilar

* Verifique drivers de v√≠deo atualizados

### Salvamento

A maioria dos jogos n√£o salva progresso automaticamente:

* High scores podem ser perdidos ao fechar

* Anote suas melhores pontua√ß√µes manualmente

* Alguns jogos podem criar arquivos de save

## Conclus√£o

Executar os jogos √© a parte mais divertida do projeto! Cada jogo oferece uma experi√™ncia √∫nica e demonstra diferentes conceitos de programa√ß√£o de jogos. Use este guia como refer√™ncia para:

* Descobrir novos jogos para jogar

* Aprender diferentes mec√¢nicas de jogo

* Solucionar problemas de execu√ß√£o

* Comparar implementa√ß√µes diferentes

Divirta-se explorando todos os 16 jogos e descobrindo suas mec√¢nicas e segredos!



# Estrutura do Projeto

Este guia explica como o projeto "16 Games in C++" est√° organizado, facilitando a navega√ß√£o, compreens√£o e modifica√ß√£o do c√≥digo.

## Vis√£o Geral da Estrutura

O projeto segue uma organiza√ß√£o l√≥gica que separa jogos, documenta√ß√£o, scripts e configura√ß√µes:

```
16Games-in-Cpp/
‚îú‚îÄ‚îÄ 01  Tetris/                 # Jogo 1: Tetris
‚îú‚îÄ‚îÄ 02  Doodle Jump/            # Jogo 2: Doodle Jump  
‚îú‚îÄ‚îÄ 03  Arkanoid/               # Jogo 3: Arkanoid
‚îú‚îÄ‚îÄ ...                         # Jogos 4-16
‚îú‚îÄ‚îÄ Writerside/                 # Documenta√ß√£o
‚îú‚îÄ‚îÄ scripts/                    # Scripts de automa√ß√£o
‚îú‚îÄ‚îÄ build/                      # Arquivos compilados (gerado)
‚îú‚îÄ‚îÄ CMakeLists.txt              # Configura√ß√£o de build
‚îú‚îÄ‚îÄ Makefile                    # Comandos simplificados
‚îú‚îÄ‚îÄ setup.sh                    # Script de configura√ß√£o
‚îî‚îÄ‚îÄ README.md                   # Informa√ß√µes b√°sicas
```

## Estrutura Detalhada

### Diret√≥rios dos Jogos

Cada jogo tem sua pr√≥pria pasta seguindo o padr√£o `NN Nome/`:

```MERMAID
graph TD
    A[Projeto Raiz] --> B[01  Tetris/]
    A --> C[02  Doodle Jump/]
    A --> D[03  Arkanoid/]
    A --> E[... outros jogos]
    
    B --> B1[main.cpp]
    B --> B2[images/]
    
    C --> C1[main.cpp]
    C --> C2[images/]
    C --> C3[fonts/]
    
    D --> D1[main.cpp]
    D --> D2[images/]
```

#### Estrutura T√≠pica de um Jogo

```
01  Tetris/
‚îú‚îÄ‚îÄ main.cpp              # C√≥digo principal do jogo
‚îú‚îÄ‚îÄ images/               # Assets visuais
‚îÇ   ‚îú‚îÄ‚îÄ tiles.png         # Sprites dos blocos
‚îÇ   ‚îú‚îÄ‚îÄ background.png    # Imagem de fundo
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ fonts/               # Fontes (quando necess√°rio)
‚îÇ   ‚îî‚îÄ‚îÄ arial.ttf
‚îî‚îÄ‚îÄ files/               # Outros recursos (sons, configs)
    ‚îî‚îÄ‚îÄ config.txt
```

### Arquivos de Configura√ß√£o

#### CMakeLists.txt

O arquivo principal de configura√ß√£o do sistema de build:

```CMAKE
# Configura√ß√£o b√°sica
cmake_minimum_required(VERSION 3.10)
project(16Games LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 17)

# Fun√ß√£o para adicionar jogos automaticamente
function(add_game GAME_NAME GAME_DIR)
    # Encontra arquivos fonte
    # Configura compila√ß√£o
    # Copia assets
    # Cria targets de execu√ß√£o
endfunction()

# Lista de todos os jogos
add_game(tetris "01  Tetris")
add_game(doodle_jump "02  Doodle Jump")
# ... outros jogos
```

#### Makefile

Interface simplificada para comandos comuns:

```
# Comandos b√°sicos
setup:    # Configura√ß√£o inicial
build:    # Compilar todos os jogos  
clean:    # Limpar arquivos tempor√°rios
test:     # Testar compila√ß√£o

# Comandos espec√≠ficos por jogo
build-%:  # Compilar jogo espec√≠fico
run-%:    # Executar jogo espec√≠fico
```

### Diret√≥rio de Build

Quando voc√™ compila o projeto, √© criada a estrutura `build/`:

```
build/
‚îú‚îÄ‚îÄ games/                    # Execut√°veis organizados
‚îÇ   ‚îú‚îÄ‚îÄ tetris/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tetris           # Execut√°vel
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ images/          # Assets copiados
‚îÇ   ‚îú‚îÄ‚îÄ doodle_jump/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ doodle_jump      # Execut√°vel
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images/          # Assets copiados
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fonts/           # Fontes copiadas
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ CMakeFiles/              # Arquivos internos do CMake
‚îú‚îÄ‚îÄ Makefile                 # Makefile gerado
‚îî‚îÄ‚îÄ cmake_install.cmake     # Script de instala√ß√£o
```

## Organiza√ß√£o por Categoria

### Jogos de Puzzle

```
Puzzle Games/
‚îú‚îÄ‚îÄ 01  Tetris/              # Blocos que caem
‚îú‚îÄ‚îÄ 05  Minesweeper/         # Campo minado
‚îú‚îÄ‚îÄ 06  Fifteen-Puzzle/      # Quebra-cabe√ßa deslizante
‚îú‚îÄ‚îÄ 11  NetWalk/             # Conectar tubula√ß√µes
‚îî‚îÄ‚îÄ 12  Mahjong Solitaire/   # Paci√™ncia com pe√ßas
```

### Jogos de A√ß√£o

```
Action Games/
‚îú‚îÄ‚îÄ 02  Doodle Jump/         # Pular plataformas
‚îú‚îÄ‚îÄ 03  Arkanoid/            # Quebrar blocos
‚îú‚îÄ‚îÄ 04  Snake/               # Serpente cl√°ssica
‚îú‚îÄ‚îÄ 09  Xonix/               # Conquistar territ√≥rio
‚îî‚îÄ‚îÄ 16  Asteroids/           # Nave espacial
```

### Jogos de Corrida/Esporte

```
Racing/Sports Games/
‚îú‚îÄ‚îÄ 07  Racing (Top Down)/   # Corrida vista de cima
‚îú‚îÄ‚îÄ 08  Outrun/              # Corrida 3D
‚îî‚îÄ‚îÄ 15  Volleyball/          # V√¥lei multiplayer
```

### Jogos de Estrat√©gia

```
Strategy Games/
‚îú‚îÄ‚îÄ 10  Bejeweled/           # Combinar joias
‚îú‚îÄ‚îÄ 13  Tron/                # Batalha de motos
‚îî‚îÄ‚îÄ 14  Chess/               # Xadrez com IA
```

## Padr√µes de C√≥digo

### Estrutura T√≠pica do main.cpp

```CPP
#include <SFML/Graphics.hpp>
#include <iostream>
// ... outras includes

using namespace sf;

// 1. Estruturas e vari√°veis globais
struct GameData {
    // dados do jogo
};

// 2. Fun√ß√µes auxiliares
void initializeGame() {
    // inicializa√ß√£o
}

void updateGame() {
    // l√≥gica do jogo
}

void renderGame() {
    // desenhar na tela
}

// 3. Fun√ß√£o principal
int main() {
    // Configura√ß√£o inicial
    RenderWindow window(VideoMode(800, 600), "Nome do Jogo");
    
    // Loop principal
    while (window.isOpen()) {
        // Processar eventos
        Event event;
        while (window.pollEvent(event)) {
            // tratar entrada do usu√°rio
        }
        
        // Atualizar l√≥gica
        updateGame();
        
        // Renderizar
        window.clear();
        renderGame();
        window.display();
    }
    
    return 0;
}
```

### Conven√ß√µes de Nomenclatura

#### Arquivos

* Execut√°veis: Nome do jogo em min√∫sculas com underscore * `tetris`, `doodle_jump`, `fifteen_puzzle`

* Diret√≥rios: N√∫mero + nome em mai√∫sculas * `01 Tetris`, `12 Mahjong Solitaire`

* Assets: Nomes descritivos em min√∫sculas * `background.png`, `player_sprite.png`, `block_01.png`

#### C√≥digo

* Vari√°veis: camelCase * `gameState`, `playerPosition`, `currentScore`

* Constantes: UPPER_CASE * `SCREEN_WIDTH`, `MAX_PLAYERS`, `GRAVITY_FORCE`

* Fun√ß√µes: camelCase com verbos * `initializeGame()`, `handleInput()`, `drawSprites()`

## Sistema de Assets

### Organiza√ß√£o de Imagens

```
images/
‚îú‚îÄ‚îÄ sprites/              # Personagens e objetos
‚îÇ   ‚îú‚îÄ‚îÄ player.png
‚îÇ   ‚îú‚îÄ‚îÄ enemy_01.png
‚îÇ   ‚îî‚îÄ‚îÄ powerup.png
‚îú‚îÄ‚îÄ backgrounds/          # Fundos
‚îÇ   ‚îú‚îÄ‚îÄ menu_bg.png
‚îÇ   ‚îî‚îÄ‚îÄ game_bg.png
‚îú‚îÄ‚îÄ ui/                   # Interface
‚îÇ   ‚îú‚îÄ‚îÄ button.png
‚îÇ   ‚îú‚îÄ‚îÄ health_bar.png
‚îÇ   ‚îî‚îÄ‚îÄ score_panel.png
‚îî‚îÄ‚îÄ tiles/               # Elementos de cen√°rio
    ‚îú‚îÄ‚îÄ wall.png
    ‚îú‚îÄ‚îÄ floor.png
    ‚îî‚îÄ‚îÄ platform.png
```

### Gerenciamento de Assets

O CMake automaticamente copia assets durante a compila√ß√£o:

```CMAKE
# Copiar imagens
if(EXISTS "${CMAKE_SOURCE_DIR}/${GAME_DIR}/images")
    file(COPY "${CMAKE_SOURCE_DIR}/${GAME_DIR}/images/" 
         DESTINATION "${CMAKE_BINARY_DIR}/games/${GAME_NAME}/images")
endif()

# Copiar fontes
if(EXISTS "${CMAKE_SOURCE_DIR}/${GAME_DIR}/fonts")
    file(COPY "${CMAKE_SOURCE_DIR}/${GAME_DIR}/fonts/" 
         DESTINATION "${CMAKE_BINARY_DIR}/games/${GAME_NAME}/fonts")
endif()
```

## Scripts e Automa√ß√£o

### Scripts Principais

```
scripts/
‚îú‚îÄ‚îÄ main.sh                    # Script principal de automa√ß√£o
‚îú‚îÄ‚îÄ push_remote_repo.sh        # Deploy/publica√ß√£o
‚îî‚îÄ‚îÄ unzip_writerside.sh        # Processamento de documenta√ß√£o
```

### Scripts na Raiz

```
./
‚îú‚îÄ‚îÄ setup.sh                   # Configura√ß√£o inicial do ambiente
‚îú‚îÄ‚îÄ fix_games.sh              # Corre√ß√£o de problemas comuns
‚îî‚îÄ‚îÄ test_games.sh             # Teste automatizado dos jogos
```

#### Exemplo: setup.sh

```BASH
#!/bin/bash
echo "üéÆ Configurando ambiente para 16 Games in C++"

# Verificar depend√™ncias
echo "üìã Verificando depend√™ncias..."
check_sfml() { ... }
check_cmake() { ... }

# Configurar build
echo "üî® Configurando projeto..."
mkdir -p build
cd build && cmake ..

# Testar compila√ß√£o
echo "üéØ Testando compila√ß√£o..."
make tetris
```

## Documenta√ß√£o

### Estrutura do Writerside

```
Writerside/
‚îú‚îÄ‚îÄ cfg/                      # Configura√ß√µes do Writerside
‚îú‚îÄ‚îÄ images/                   # Imagens da documenta√ß√£o
‚îú‚îÄ‚îÄ topics/                   # Arquivos de documenta√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ inicio.md            # P√°gina inicial
‚îÇ   ‚îú‚îÄ‚îÄ system-requirements.md
‚îÇ   ‚îú‚îÄ‚îÄ compilation-guide.md
‚îÇ   ‚îú‚îÄ‚îÄ tetris.md           # Tutorial do Tetris
‚îÇ   ‚îú‚îÄ‚îÄ doodle-jump.md      # Tutorial do Doodle Jump
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ gc.tree                  # Estrutura de navega√ß√£o
‚îî‚îÄ‚îÄ writerside.cfg          # Configura√ß√£o principal
```

### Organiza√ß√£o de T√≥picos

A documenta√ß√£o est√° organizada hierarquicamente:

```MERMAID
graph TD
    A[In√≠cio] --> B[Configura√ß√£o do Ambiente]
    A --> C[Compila√ß√£o]
    A --> D[Estrutura do Projeto]
    A --> E[Jogos]
    A --> F[Troubleshooting]
    
    B --> B1[Requisitos do Sistema]
    B --> B2[Instala√ß√£o SFML]
    B --> B3[Configura√ß√£o IDE]
    
    C --> C1[Guia de Compila√ß√£o]
    C --> C2[Build e Execu√ß√£o]
    C --> C3[Executando Jogos]
    
    E --> E1[Tetris]
    E --> E2[Doodle Jump]
    E --> E3[...outros jogos]
```

## Boas Pr√°ticas

### Organiza√ß√£o de C√≥digo

1. Separa√ß√£o de Responsabilidades

* Um arquivo main.cpp por jogo

* Fun√ß√µes espec√≠ficas para cada aspecto (input, update, render)

* Estruturas de dados bem definidas

2. Gerenciamento de Recursos

* Assets organizados por tipo

* Verifica√ß√£o de carregamento de arquivos

* Libera√ß√£o adequada de mem√≥ria

3. Configura√ß√£o Flex√≠vel

* Constantes para valores importantes

* Separa√ß√£o entre l√≥gica e configura√ß√£o

* Facilidade de modifica√ß√£o

### Extensibilidade

Para adicionar um novo jogo:

1. Criar diret√≥rio seguindo o padr√£o `NN Nome/`

2. Implementar main.cpp com estrutura padr√£o

3. Adicionar assets na pasta images/

4. Registrar no CMakeLists.txt:

```CMAKE
add_game(novo_jogo "17 Novo Jogo")
```

5. Atualizar lista no Makefile se necess√°rio

### Manuten√ß√£o

1. Backup Regular

* Versionar c√≥digo com Git

* Backup de assets importantes

* Documentar mudan√ßas significativas

2. Testes Regulares

* Verificar compila√ß√£o de todos os jogos

* Testar funcionalidade b√°sica

* Validar assets e depend√™ncias

3. Documenta√ß√£o Atualizada

* Manter tutoriais sincronizados com c√≥digo

* Documentar mudan√ßas na estrutura

* Atualizar guias de instala√ß√£o

## Navega√ß√£o Eficiente

### Comandos de Terminal

```BASH
# Navegar rapidamente para um jogo
cd "01  Tetris"            # Usar aspas por causa do espa√ßo
cd build/games/tetris      # Execut√°vel compilado

# Encontrar arquivos espec√≠ficos
find . -name "*.png"       # Todas as imagens
find . -name "main.cpp"    # Todos os arquivos principais
grep -r "SFML" .          # Procurar por SFML no c√≥digo
```

### Atalhos √öteis

```BASH
# Aliases para .bashrc ou .zshrc
alias games='cd ~/path/to/16Games-in-Cpp'
alias buildgames='cd ~/path/to/16Games-in-Cpp/build'
alias rungames='cd ~/path/to/16Games-in-Cpp && make run-'

# Fun√ß√µes √∫teis
runGame() {
    cd ~/path/to/16Games-in-Cpp
    make run-$1
}
# Uso: runGame tetris
```

## Conclus√£o

A estrutura do projeto "16 Games in C++" foi projetada para ser:

* Intuitiva: F√°cil de navegar e entender

* Escal√°vel: F√°cil de adicionar novos jogos

* Mant√≠vel: C√≥digo e assets bem organizados

* Flex√≠vel: Suporta diferentes tipos de jogos

* Automatizada: Build e deploy simplificados

Compreender essa estrutura √© fundamental para:

* Modificar jogos existentes

* Criar novos jogos

* Contribuir para o projeto

* Usar como base para outros projetos

Use este guia como refer√™ncia para navegar eficientemente pelo projeto e aproveitar ao m√°ximo sua organiza√ß√£o.



# Jogos

Conhe√ßa todos os 16 jogos inclu√≠dos neste projeto, cada um com suas mec√¢nicas √∫nicas e implementa√ß√µes interessantes! üéÆ

## üéØ Vis√£o Geral

Este projeto inclui 16 jogos cl√°ssicos, cada um demonstrando diferentes conceitos de programa√ß√£o de jogos:

* F√≠sica e movimento

* Detec√ß√£o de colis√£o

* Intelig√™ncia artificial (IA b√°sica)

* Gera√ß√£o procedural

* Estados de jogo

* Interface de usu√°rio

* Gerenciamento de assets

## üèÜ Lista Completa de Jogos

### üü¶ Jogos de Puzzle

1. [Tetris](tetris.html) - O cl√°ssico jogo de blocos que caem

2. [Fifteen Puzzle](fifteen-puzzle.html) - Quebra-cabe√ßa num√©rico deslizante

3. [Minesweeper](minesweeper.html) - Campo minado cl√°ssico

4. [NetWalk](netwalk.html) - Conecte os canos para criar uma rede

5. [Mahjong Solitaire](mahjong.html) - Paci√™ncia com pe√ßas do mahjong

### üèÉ Jogos de A√ß√£o/Arcade

1. [Doodle Jump](doodle-jump.html) - Pule o mais alto poss√≠vel

2. [Snake](snake.html) - A serpente cl√°ssica que cresce

3. [Arkanoid](arkanoid.html) - Quebre todos os blocos com a bola

4. [Bejeweled](bejeweled.html) - Combine joias para pontos

5. [Xonix](xonix.html) - Conquiste territ√≥rio evitando inimigos

### üèéÔ∏è Jogos de Corrida

1. [Racing (Top Down)](racing.html) - Corrida vista de cima

2. [Outrun](outrun.html) - Corrida em perspectiva 3D

### ‚öîÔ∏è Jogos de Combate/Estrat√©gia

1. [Asteroids](null) - Destrua asteroides no espa√ßo

2. [Tron](null) - Batalha de motos de luz

3. [Chess](null) - Xadrez completo com IA

4. [Volleyball](null) - V√¥lei arcade multiplayer

## üìä Status dos Jogos

| Jogo |Compila√ß√£o |Execu√ß√£o |Complexidade |Conceitos Principais |
------------------------------------------------------------------
| Tetris |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê |Estados, Rota√ß√£o, Grid |
| Doodle Jump |‚úÖ |‚úÖ |‚≠ê‚≠ê |F√≠sica, C√¢mera, Procedural |
| Arkanoid |‚úÖ |‚úÖ |‚≠ê‚≠ê |Colis√£o, F√≠sica da Bola |
| Snake |‚úÖ |‚úÖ |‚≠ê‚≠ê |Lista, Crescimento |
| Minesweeper |‚úÖ |‚úÖ |‚≠ê‚≠ê |Grid, Recurs√£o |
| Fifteen Puzzle |‚úÖ |‚úÖ |‚≠ê‚≠ê |Algoritmos, Shuffling |
| Racing |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê |Movimento, Colis√£o |
| Xonix |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê |Flood Fill, Territory |
| Bejeweled |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê |Match-3, Anima√ß√µes, Persist√™ncia de Dados (SQLite) |
| NetWalk |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê |Conectividade, Rota√ß√£o |
| Mahjong |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê |3D Stacking, Matching |
| Asteroids |‚úÖ |‚úÖ |‚≠ê‚≠ê‚≠ê‚≠ê |Vetores, Rota√ß√£o |
| Outrun |‚ùå |- |‚≠ê‚≠ê‚≠ê‚≠ê |Pseudo-3D, Sprites |
| Chess |‚ùå |- |‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |IA, Valida√ß√£o de Movimentos |
| Volleyball |‚ùå |- |‚≠ê‚≠ê‚≠ê |Multiplayer, F√≠sica |
| Tron |‚ùå |- |‚≠ê‚≠ê |Trail Rendering, IA |

Legenda de Complexidade:

* ‚≠ê = Muito Simples

* ‚≠ê‚≠ê = Simples

* ‚≠ê‚≠ê‚≠ê = Intermedi√°rio

* ‚≠ê‚≠ê‚≠ê‚≠ê = Avan√ßado

* ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê = Muito Avan√ßado

## üéÆ Como Jogar

### Execu√ß√£o R√°pida

```BASH
# Compilar todos os jogos
make all_games

# Executar um jogo espec√≠fico
make run_tetris
make run_doodle_jump
make run_snake
```

### Execu√ß√£o Individual

```BASH
# Navegar para o jogo
cd build/games/tetris

# Executar
./tetris
```

## üéØ Conceitos por Jogo

### üîß F√≠sica e Movimento

* [Doodle Jump](doodle-jump.html): Gravidade, impulso, wrapping

* [Arkanoid](arkanoid.html): Rebote de bola, colis√£o angular

* [Asteroids](null): Movimento vetorial, rota√ß√£o

### üß© Algoritmos

* [Minesweeper](minesweeper.html): Flood fill recursivo

* [Fifteen Puzzle](fifteen-puzzle.html): Algoritmo de embaralhamento

* [Chess](null): Minimax, avalia√ß√£o de posi√ß√£o

### üé® Renderiza√ß√£o

* [Tetris](tetris.html): Grid-based rendering

* [Outrun](outrun.html): Pseudo-3D com sprites

* [Tron](null): Trail rendering

### ü§ñ Intelig√™ncia Artificial

* [Chess](null): IA completa com diferentes n√≠veis

* [Tron](null): IA b√°sica de pathfinding

### üåê Gera√ß√£o Procedural

* [Doodle Jump](doodle-jump.html): Plataformas infinitas

* [Racing](racing.html): Gera√ß√£o de pista

## üìö Recursos de Aprendizado

### Para Iniciantes

Comece com estes jogos mais simples:

1. [Snake](snake.html) - Conceitos b√°sicos

2. [Doodle Jump](doodle-jump.html) - F√≠sica simples

3. [Minesweeper](minesweeper.html) - L√≥gica de grid

### Para Intermedi√°rios

Avance para estes jogos:

1. [Tetris](tetris.html) - Estados complexos

2. [Arkanoid](arkanoid.html) - F√≠sica de colis√£o

3. [Bejeweled](bejeweled.html) - Match-3 algorithm

### Para Avan√ßados

Desafie-se com:

1. [Chess](null) - IA complexa

2. [Asteroids](null) - Matem√°tica vetorial

3. [Outrun](outrun.html) - Renderiza√ß√£o 3D

## üîß Estrutura dos Jogos

Cada jogo segue uma estrutura similar:

```
<Jogo>/
‚îú‚îÄ‚îÄ main.cpp           # C√≥digo principal
‚îú‚îÄ‚îÄ images/            # Sprites e texturas
‚îú‚îÄ‚îÄ fonts/             # Fontes (quando necess√°rio)
‚îî‚îÄ‚îÄ files/             # Assets adicionais
```

### Padr√£o de Implementa√ß√£o

```CPP
// Estrutura comum dos jogos
int main() {
    // 1. Inicializa√ß√£o
    RenderWindow window(...);
    // Carregar assets
    
    // 2. Loop principal
    while (window.isOpen()) {
        // 2.1 Eventos
        Event event;
        while (window.pollEvent(event)) {
            // Processar entrada
        }
        
        // 2.2 L√≥gica do jogo
        // Atualizar estado
        
        // 2.3 Renderiza√ß√£o
        window.clear();
        // Desenhar elementos
        window.display();
    }
    
    return 0;
}
```

## üéØ Pr√≥ximos Passos

1. Escolha um jogo que te interesse

2. Leia o tutorial espec√≠fico

3. Execute o jogo para entender a mec√¢nica

4. Analise o c√≥digo para ver a implementa√ß√£o

5. Experimente modifica√ß√µes para aprender

## üí° Dicas de Estudo

### An√°lise de C√≥digo

* Comece lendo a fun√ß√£o `main()`

* Identifique o loop principal

* Entenda as estruturas de dados

* Trace o fluxo de execu√ß√£o

### Experimenta√ß√£o

* Modifique valores constantes

* Adicione prints para debug

* Implemente pequenas melhorias

* Teste diferentes cen√°rios

### Progress√£o

* Domine um jogo antes de passar para outro

* Implemente varia√ß√µes dos jogos

* Combine conceitos de diferentes jogos

* Crie seus pr√≥prios jogos

Escolha seu jogo favorito e comece a explorar! Cada um oferece uma experi√™ncia √∫nica de aprendizado. üöÄ



# Tetris

Este tutorial ensina como criar o jogo Tetris do zero usando C++ e SFML. Vamos come√ßar com conceitos b√°sicos e construir o conhecimento passo a passo, explicando cada parte de forma clara e detalhada.

## O que √© Tetris

Imagine um jogo onde pe√ßas de diferentes formatos caem do c√©u como chuva, e voc√™ precisa organiz√°-las de forma inteligente para que se encaixem perfeitamente. √â como um quebra-cabe√ßas em movimento, onde:

* Pe√ßas geom√©tricas (chamadas de "tetromin√≥s") caem de cima para baixo

* Voc√™ pode mover as pe√ßas para esquerda e direita

* Voc√™ pode girar as pe√ßas para encaix√°-las melhor

* Quando uma linha horizontal fica completamente preenchida, ela desaparece

* O objetivo √© durar o m√°ximo de tempo poss√≠vel sem deixar as pe√ßas chegarem ao topo

Este jogo √© perfeito para aprender conceitos fundamentais de programa√ß√£o como arrays bidimensionais, rota√ß√£o de objetos, detec√ß√£o de colis√µes e manipula√ß√£o de dados.

## A Matem√°tica Secreta dos Tetromin√≥s

### O que s√£o Tetromin√≥s?

Tetromin√≥s s√£o formas geom√©tricas feitas de exatamente 4 quadrados conectados. Existem apenas 7 formas diferentes poss√≠veis:

```MERMAID
graph TD
    A[I - Linha] --> B[‚ñà‚ñà‚ñà‚ñà]
    C[Z - Zigue-zague] --> D[‚ñà‚ñà<br/>  ‚ñà‚ñà]
    E[S - Zigue-zague reverso] --> F[  ‚ñà‚ñà<br/>‚ñà‚ñà]
    G[T - Formato T] --> H[‚ñà‚ñà‚ñà<br/> ‚ñà]
    I[L - Formato L] --> J[‚ñà<br/>‚ñà<br/>‚ñà‚ñà]
    K[J - L reverso] --> L[  ‚ñà<br/>  ‚ñà<br/>‚ñà‚ñà]
    M[O - Quadrado] --> N[‚ñà‚ñà<br/>‚ñà‚ñà]
```

### Como Representar Formas com N√∫meros

A parte mais inteligente do nosso Tetris √© como representamos cada pe√ßa usando apenas n√∫meros. Em vez de desenhar cada forma, usamos um sistema de coordenadas em uma grade 4x4:

```MERMAID
graph TB
    subgraph "Grade 4x4"
        A[0,1,2,3<br/>4,5,6,7<br/>8,9,10,11<br/>12,13,14,15]
    end
    
    subgraph "Pe√ßa I"
        B[1,3,5,7]
    end
    
    subgraph "Pe√ßa O"
        C[2,3,4,5]
    end
```

Vamos entender como isso funciona:

```CPP
int figures[7][4] = {
    1, 3, 5, 7,  // I - Linha vertical
    2, 4, 5, 7,  // Z - Zigue-zague
    3, 5, 4, 6,  // S - Zigue-zague reverso
    3, 5, 4, 7,  // T - Formato T
    2, 3, 5, 7,  // L - Formato L
    3, 5, 7, 6,  // J - L reverso
    2, 3, 4, 5,  // O - Quadrado
};
```

Como converter n√∫meros em posi√ß√µes:

Para transformar um n√∫mero em coordenadas (x, y):

```CPP
int x = numero % 2;  // Resto da divis√£o por 2 = coluna
int y = numero / 2;  // Divis√£o inteira por 2 = linha
```

Por exemplo, o n√∫mero 5:

* x = 5 % 2 = 1 (coluna 1)

* y = 5 / 2 = 2 (linha 2)

Isso significa que a posi√ß√£o 5 est√° na coluna 1, linha 2 da nossa grade 4x4.

## A Estrutura do Jogo

### O Campo de Jogo - Uma Grade Inteligente

O campo de jogo √© como uma folha de papel quadriculado, onde cada quadradinho pode estar vazio (0) ou preenchido com uma cor (1 a 7):

```CPP
const int M = 20;  // 20 linhas de altura
const int N = 10;  // 10 colunas de largura
int field[M][N] = {0};  // Inicializa tudo com 0 (vazio)
```

Por que 20x10?

* √â o tamanho cl√°ssico do Tetris original

* Oferece desafio suficiente sem ser imposs√≠vel

* Permite que as pe√ßas tenham espa√ßo para manobrar

### Representando as Pe√ßas Ativas

Cada pe√ßa tem 4 blocos, ent√£o usamos duas estruturas de dados:

```CPP
struct Point {
    int x, y;    // Coordenadas de cada bloco
} a[4], b[4];   // a = posi√ß√£o atual, b = posi√ß√£o anterior
```

Por que duas arrays?

* a[4]: Posi√ß√£o atual da pe√ßa (onde ela est√° agora)

* b[4]: Posi√ß√£o anterior da pe√ßa (onde ela estava antes)

* Se um movimento for inv√°lido, copiamos b para a (desfazemos o movimento)

## As Principais Mec√¢nicas do Jogo

### 1. Verifica√ß√£o de Colis√µes - A Fun√ß√£o Mais Importante

Esta √© a fun√ß√£o que decide se um movimento √© v√°lido ou n√£o:

```CPP
bool check() {
    for (int i = 0; i < 4; i++) {
        // Verifica se a pe√ßa saiu dos limites da tela
        if (a[i].x < 0 || a[i].x >= N || a[i].y >= M) return false;
        
        // Verifica se a pe√ßa colidiu com algo j√° no campo
        else if (field[a[i].y][a[i].x]) return false;
    }
    return true;  // Movimento √© v√°lido
}
```

O que esta fun√ß√£o verifica:

```MERMAID
flowchart TD
    A[Verificar cada bloco da pe√ßa] --> B{Est√° fora dos limites?}
    B -->|Sim| C[Movimento INV√ÅLIDO]
    B -->|N√£o| D{Colidiu com pe√ßa existente?}
    D -->|Sim| C
    D -->|N√£o| E[Continuar verificando]
    E --> F{Todos os 4 blocos OK?}
    F -->|Sim| G[Movimento V√ÅLIDO]
    F -->|N√£o| A
```

### 2. Movimento Horizontal - Esquerda e Direita

O movimento horizontal √© simples mas usa um truque inteligente:

```CPP
// Salvar posi√ß√£o atual
for (int i = 0; i < 4; i++) {
    b[i] = a[i];        // Guardar posi√ß√£o antiga
    a[i].x += dx;       // Mover para nova posi√ß√£o
}

// Se o movimento for inv√°lido, desfazer
if (!check()) {
    for (int i = 0; i < 4; i++) {
        a[i] = b[i];    // Voltar para posi√ß√£o anterior
    }
}
```

A estrat√©gia "Tentar e Desfazer":

1. Salvar a posi√ß√£o atual em `b`

2. Mover a pe√ßa para a nova posi√ß√£o em `a`

3. Verificar se a nova posi√ß√£o √© v√°lida

4. Se n√£o for v√°lida, copiar `b` de volta para `a`

### 3. Rota√ß√£o - A Parte Mais Matem√°tica

A rota√ß√£o √© baseada em matem√°tica de transforma√ß√£o de coordenadas. Giramos cada bloco 90 graus ao redor do segundo bloco da pe√ßa:

```CPP
if (rotate) {
    Point p = a[1];  // Centro de rota√ß√£o (segundo bloco)
    
    for (int i = 0; i < 4; i++) {
        // Calcular posi√ß√£o relativa ao centro
        int x = a[i].y - p.y;
        int y = a[i].x - p.x;
        
        // Aplicar rota√ß√£o de 90 graus
        a[i].x = p.x - x;
        a[i].y = p.y + y;
    }
    
    // Se a rota√ß√£o for inv√°lida, desfazer
    if (!check()) {
        for (int i = 0; i < 4; i++) {
            a[i] = b[i];
        }
    }
}
```

Como funciona a rota√ß√£o matem√°tica:

```MERMAID
graph TD
    A[Ponto Original: x,y] --> B[Relativo ao Centro: x-cx, y-cy]
    B --> C[Rota√ß√£o 90¬∞: -y, x]
    C --> D[Volta ao Sistema: cx-y, cy+x]
    
    E[Exemplo: 3,1 com centro 2,2] --> F[Relativo: 1,-1]
    F --> G[Rotacionado: 1,1]
    G --> H[Final: 1,3]
```

### 4. Queda Autom√°tica - O Tick do Jogo

As pe√ßas caem sozinhas seguindo um cron√¥metro:

```CPP
float timer = 0, delay = 0.3;  // 0.3 segundos entre cada queda

if (timer > delay) {
    // Salvar posi√ß√£o atual
    for (int i = 0; i < 4; i++) {
        b[i] = a[i];
        a[i].y += 1;    // Mover para baixo
    }
    
    // Se n√£o conseguir mover para baixo, fixar a pe√ßa
    if (!check()) {
        for (int i = 0; i < 4; i++) {
            field[b[i].y][b[i].x] = colorNum;  // Fixar no campo
        }
        
        // Gerar nova pe√ßa
        colorNum = 1 + rand() % 7;
        int n = rand() % 7;
        for (int i = 0; i < 4; i++) {
            a[i].x = figures[n][i] % 2;
            a[i].y = figures[n][i] / 2;
        }
    }
    
    timer = 0;  // Resetar cron√¥metro
}
```

## A L√≥gica de Eliminar Linhas

### Detectando Linhas Completas

A parte mais inteligente do Tetris √© como removemos linhas completas. Usamos um algoritmo de "compacta√ß√£o":

```CPP
int k = M - 1;  // Ponteiro para onde escrever
for (int i = M - 1; i > 0; i--) {  // Ler de baixo para cima
    int count = 0;
    
    // Contar quantos blocos h√° nesta linha
    for (int j = 0; j < N; j++) {
        if (field[i][j]) count++;
        field[k][j] = field[i][j];  // Copiar linha
    }
    
    // Se a linha n√£o est√° completa, manter ela
    if (count < N) k--;
}
```

### Como Funciona o Algoritmo

```MERMAID
sequenceDiagram
    participant Leitura as Linha de Leitura (i)
    participant Escrita as Linha de Escrita (k)
    participant Campo as Campo de Jogo
    
    Leitura->>Campo: Ler linha de baixo para cima
    Campo->>Leitura: Contar blocos na linha
    Leitura->>Escrita: Copiar linha para posi√ß√£o k
    
    alt Linha incompleta
        Escrita->>Escrita: k-- (mover ponteiro para cima)
    else Linha completa
        Escrita->>Escrita: k permanece (linha ser√° sobrescrita)
    end
```

Por que isso funciona:

1. Come√ßamos de baixo para cima

2. Copiamos cada linha para a posi√ß√£o `k`

3. Se a linha n√£o est√° completa, movemos `k` para cima

4. Se a linha est√° completa, `k` n√£o se move (linha ser√° sobrescrita)

5. Linhas completas "desaparecem" naturalmente

Exemplo pr√°tico:

```
Antes:           Depois:
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà         ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
```

## Gerando Pe√ßas Aleat√≥rias

### Como Criar Pe√ßas Novas

Quando uma pe√ßa √© fixada, criamos uma nova pe√ßa aleat√≥ria:

```CPP
colorNum = 1 + rand() % 7;    // Cor aleat√≥ria de 1 a 7
int n = rand() % 7;           // Forma aleat√≥ria de 0 a 6

for (int i = 0; i < 4; i++) {
    a[i].x = figures[n][i] % 2;  // Posi√ß√£o X do bloco
    a[i].y = figures[n][i] / 2;  // Posi√ß√£o Y do bloco
}
```

### Por que Come√ßar no Topo?

As pe√ßas novas sempre aparecem no topo da tela porque:

* figures[n][i] representa posi√ß√µes de 0 a 15

* figures[n][i] / 2 d√° valores de 0 a 7 (linhas do topo)

* Isso garante que as pe√ßas sempre come√ßam vis√≠veis

## O Sistema de Cores

### Cada Pe√ßa Tem Sua Cor

```CPP
int colorNum = 1;  // Cor da pe√ßa atual (1 a 7)
```

Mapeamento de cores:

* 0: Vazio (preto)

* 1-7: Diferentes cores para cada tipo de pe√ßa

### Como Desenhar com Cores

```CPP
// Para pe√ßas j√° fixadas no campo
s.setTextureRect(IntRect(field[i][j] * 18, 0, 18, 18));

// Para a pe√ßa atual em movimento
s.setTextureRect(IntRect(colorNum * 18, 0, 18, 18));
```

Cada cor √© uma se√ß√£o de 18x18 pixels na textura.

## Otimiza√ß√µes Inteligentes

### Por que Usar Arrays de Tamanho Fixo?

```CPP
Point a[4], b[4];  // Sempre exatamente 4 pontos
```

Vantagens:

* Cada tetromin√≥ tem exatamente 4 blocos

* Arrays de tamanho fixo s√£o mais r√°pidos

* Menos uso de mem√≥ria

* C√≥digo mais simples

### Por que N√£o Usar Vetores Din√¢micos?

Para um jogo simples como Tetris:

* A complexidade extra n√£o vale a pena

* Arrays fixos s√£o mais eficientes

* O c√≥digo fica mais f√°cil de entender

## A Matem√°tica do Timing

### Controlando a Velocidade

```CPP
float timer = 0, delay = 0.3;
```

Como funciona:

* `timer` acumula o tempo passado

* `delay` define quantos segundos entre cada queda

* Quando `timer > delay`, a pe√ßa desce um n√≠vel

### Calculando FPS

Se o jogo roda a 60 FPS:

* delay = 0.3 segundos

* Pe√ßa cai a cada 0.3 √ó 60 = 18 frames

* Isso d√° tempo suficiente para o jogador pensar e agir

## Detec√ß√£o de Game Over

### Quando o Jogo Termina?

O jogo termina quando uma nova pe√ßa n√£o consegue ser colocada no topo:

```CPP
// Ap√≥s gerar nova pe√ßa
if (!check()) {
    // Game Over - pe√ßa n√£o cabe no topo
}
```

Embora o c√≥digo atual n√£o implemente explicitamente o game over, a l√≥gica est√° l√°: se `check()` retornar false para uma pe√ßa rec√©m-criada, significa que o campo est√° cheio.

## Conceitos Avan√ßados

### Por que Usar Coordenadas Relativas?

Quando geramos pe√ßas, usamos coordenadas relativas (0-15) que depois convertemos para coordenadas absolutas da tela. Isso permite:

1. F√°cil mudan√ßa de tamanho: Alterar o tamanho dos blocos n√£o quebra o jogo

2. Rota√ß√£o simples: Matem√°tica de rota√ß√£o funciona melhor com coordenadas relativas

3. Reutiliza√ß√£o: O mesmo c√≥digo serve para diferentes posi√ß√µes na tela

### A Beleza da Simplicidade

O Tetris prova que jogos incr√≠veis podem ter c√≥digo simples:

* Apenas 154 linhas de c√≥digo

* Usa conceitos b√°sicos: arrays, loops, condicionais

* Sem classes complexas ou padr√µes de design rebuscados

* Foca na l√≥gica do jogo, n√£o em arquitetura

## Poss√≠veis Melhorias

### 1. Sistema de Pontua√ß√£o

```CPP
int score = 0;
int linesCleared = 0;

// Ap√≥s eliminar linha
score += 100 * level;
linesCleared++;
```

### 2. N√≠veis de Dificuldade

```CPP
int level = 1;
delay = 0.5 - (level * 0.05);  // Fica mais r√°pido a cada n√≠vel
```

### 3. Previs√£o da Pr√≥xima Pe√ßa

```CPP
int nextPiece = rand() % 7;
// Mostrar nextPiece na interface
```

### 4. Sistema de Pausa

```CPP
bool paused = false;
if (Keyboard::isKeyPressed(Keyboard::P)) paused = !paused;
```

## Por que este C√≥digo Funciona T√£o Bem

### 1. Separa√ß√£o Clara de Responsabilidades

* `check()`: Valida movimentos

* Loop principal: Gerencia input e timing

* Algoritmo de linha: Remove linhas completas

### 2. Uso Inteligente de Dados

* Arrays 2D para o campo

* Arrays 1D para pe√ßas

* N√∫meros simples para representar formas

### 3. Algoritmos Eficientes

* Verifica√ß√£o de colis√£o: O(1) por bloco

* Remo√ß√£o de linhas: O(n) onde n √© o n√∫mero de linhas

* Rota√ß√£o: O(1) por bloco

### 4. Matem√°tica Simples mas Poderosa

* M√≥dulo e divis√£o para convers√£o de coordenadas

* Rota√ß√£o usando transforma√ß√£o linear

* Timing baseado em acumula√ß√£o de tempo

## O Tetris Como Ferramenta de Aprendizado

Este jogo √© perfeito para iniciantes porque ensina:

1. Arrays bidimensionais: O campo de jogo

2. Estruturas de dados: Points para representar blocos

3. Algoritmos: Detec√ß√£o de colis√£o, remo√ß√£o de linhas

4. Matem√°tica b√°sica: Rota√ß√£o, convers√£o de coordenadas

5. Game loop: Timing, input, renderiza√ß√£o

6. L√≥gica booleana: Verifica√ß√µes de validade

Cada conceito √© usado de forma pr√°tica e imediata, tornando o aprendizado mais efetivo do que estudar teoria abstrata.

## Conclus√£o

O Tetris √© um exemplo perfeito de como um jogo simples pode ensinar conceitos profundos de programa√ß√£o. Sua beleza est√° na simplicidade elegante: com menos de 200 linhas de c√≥digo, temos um jogo completo e divertido que demonstra arrays, algoritmos, matem√°tica e l√≥gica de jogos.

O c√≥digo n√£o √© apenas funcional - √© educativo. Cada linha tem um prop√≥sito claro, cada algoritmo resolve um problema espec√≠fico, e o resultado final √© um jogo que diverte e ensina ao mesmo tempo.



# Doodle Jump

Este tutorial ensina como criar o jogo Doodle Jump do zero usando C++ e SFML. Vamos come√ßar com conceitos b√°sicos e construir o conhecimento passo a passo, explicando cada parte de forma clara e detalhada.

## O que √© Doodle Jump

Imagine um jogo onde voc√™ controla um pequeno personagem que precisa pular de uma plataforma para outra, tentando subir o mais alto poss√≠vel. √â como pular de degrau em degrau de uma escada infinita, mas com algumas regras especiais:

* O personagem sempre cai devido √† gravidade (como na vida real)

* Ele s√≥ pode se mover para esquerda e direita

* Quando toca uma plataforma enquanto est√° caindo, automaticamente pula para cima

* Se cair muito para baixo, o jogo termina

* O objetivo √© alcan√ßar a maior altura poss√≠vel

Este jogo nos permite aprender v√°rios conceitos importantes de programa√ß√£o de jogos de forma simples e divertida.

## Como Organizar um Jogo

### Estados do Jogo - Diferentes Telas

Antes de come√ßar a programar, precisamos pensar em como organizar nosso jogo. Todo jogo tem diferentes "telas" ou "estados". Por exemplo:

* Menu: A tela inicial onde o jogador decide se quer jogar

* Jogando: Quando o jogo est√° realmente acontecendo

* Game Over: Quando o jogador perde e v√™ sua pontua√ß√£o

Chamamos isso de "estados do jogo". √â como ter diferentes salas em uma casa - voc√™ s√≥ pode estar em uma sala por vez, mas pode se mover entre elas.

```MERMAID
graph LR
    A[MENU] -->|Espa√ßo| B[PLAYING]
    B -->|Queda| C[GAME_OVER]
    C -->|R| B
    C -->|M| A
    A -->|ESC| D[EXIT]
```

Este diagrama mostra como o jogador navega entre as telas:

* Do Menu, apertar Espa√ßo leva para o jogo

* Durante o Jogo, se o jogador cair, vai para Game Over

* No Game Over, pode apertar R para jogar de novo ou M para voltar ao menu

Para implementar isso no c√≥digo, usamos algo chamado "enum" - que √© uma forma de dar nomes para n√∫meros:

```CPP
enum GameState {
    MENU,        // Valor 0 - Tela inicial do jogo
    PLAYING,     // Valor 1 - Quando estamos jogando
    GAME_OVER    // Valor 2 - Quando o jogo termina
};
```

### Guardando Informa√ß√µes - Vari√°veis e Estruturas

Em qualquer jogo, precisamos guardar informa√ß√µes. Por exemplo, onde est√° o jogador? Onde est√£o as plataformas? Qual √© a pontua√ß√£o atual?

#### Posi√ß√£o das Plataformas

Para cada plataforma, precisamos saber sua posi√ß√£o na tela. Uma posi√ß√£o tem duas coordenadas: X (horizontal) e Y (vertical). Criamos uma estrutura para isso:

```CPP
struct point {
    int x, y;    // x = posi√ß√£o horizontal, y = posi√ß√£o vertical
};
```

Pense nisso como um endere√ßo: "A plataforma est√° na posi√ß√£o X=100, Y=200".

#### Informa√ß√µes do Jogador

Para o jogador, precisamos guardar v√°rias informa√ß√µes importantes:

```CPP
int x = 100, y = 100;  // Onde o jogador est√° na tela
int h = 200;           // Uma altura especial (explicaremos depois)
float dx = 0, dy = 0;  // Velocidade do jogador
int score = 0;         // Pontos que o jogador fez
int height = 0;        // Maior altura que o jogador alcan√ßou
```

Vamos entender cada uma:

* x, y: A posi√ß√£o do jogador na tela (como coordenadas de um mapa)

* dx, dy: A velocidade do jogador (dx = velocidade horizontal, dy = velocidade vertical)

* h: Uma altura de refer√™ncia especial que usamos para o sistema de c√¢mera

* score: Os pontos que o jogador conquistou

* height: A maior altura que o jogador j√° alcan√ßou no jogo

## As Principais Mec√¢nicas do Jogo

### Como Funciona a Gravidade

Na vida real, quando voc√™ pula, a gravidade te puxa para baixo. No nosso jogo, precisamos simular essa gravidade de forma simples.

Imagine a gravidade como uma for√ßa que est√° sempre puxando o jogador para baixo. A cada momento do jogo (a cada "frame"), a gravidade faz o jogador cair um pouco mais r√°pido.

```MERMAID
graph TD
    A[A cada frame do jogo] --> B[Aumentar velocidade para baixo: dy += 0.2]
    B --> C[Mover jogador: y += dy]
    C --> D[Verificar se tocou plataforma]
    D --> E{Tocou plataforma?}
    E -->|Sim| F[Pular para cima: dy = -10]
    E -->|N√£o| G[Continuar caindo]
    F --> A
    G --> A
```

Vamos entender isso passo a passo:

```CPP
dy += 0.2;  // A cada frame, o jogador cai um pouco mais r√°pido
y += dy;    // Mover o jogador baseado na velocidade atual
```

Como funciona:

* dy √© a velocidade vertical do jogador

* Quando dy √© negativo (exemplo: -10), o jogador se move para cima

* Quando dy √© positivo (exemplo: +5), o jogador se move para baixo

* A gravidade sempre adiciona +0.2 ao dy, fazendo o jogador cair mais r√°pido

* Quando o jogador toca uma plataforma, definimos dy = -10, fazendo ele pular para cima

### Movimento Horizontal - Esquerda e Direita

O jogador pode se mover para esquerda e direita usando as setas do teclado. Mas h√° um truque especial: quando o jogador sai de um lado da tela, ele aparece do outro lado.

Imagine que a tela √© como um cilindro - se voc√™ andar para a direita e sair da tela, voc√™ aparece do lado esquerdo. Isso cria a sensa√ß√£o de um mundo infinito.

```CPP
if (Keyboard::isKeyPressed(Keyboard::Right)) {
    x += 3;                // Move 3 pixels para a direita
    if (x > 400) x = -50;  // Se saiu da direita, aparece na esquerda
}
if (Keyboard::isKeyPressed(Keyboard::Left)) {
    x -= 3;                // Move 3 pixels para a esquerda
    if (x < -50) x = 400;  // Se saiu da esquerda, aparece na direita
}
```

Por que -50 e 400?

* A tela tem 400 pixels de largura (de 0 a 400)

* Usamos -50 e 400 para criar uma transi√ß√£o suave

* O jogador desaparece gradualmente de um lado antes de aparecer do outro

### O Truque da C√¢mera - A Parte Mais Inteligente

Esta √© a parte mais interessante do jogo. Em vez de fazer o jogador subir na tela quando ele pula alto, fazemos o contr√°rio: mantemos o jogador no mesmo lugar e movemos todo o mundo para baixo!

Imagine que voc√™ est√° em uma esteira rolante que se move para baixo. Voc√™ est√° sempre na mesma posi√ß√£o na esteira, mas o mundo ao seu redor est√° se movendo.

```MERMAID
sequenceDiagram
    participant Jogador
    participant C√¢mera
    participant Plataformas
    
    Jogador->>C√¢mera: Subiu muito alto!
    C√¢mera->>Plataformas: Mover todas para baixo
    Plataformas->>Plataformas: Recriar plataformas que sa√≠ram da tela
    C√¢mera->>Jogador: Manter na mesma altura visual
```

Como isso funciona no c√≥digo:

```CPP
if (y < h) {  // Se o jogador subiu acima da altura de refer√™ncia
    int heightGain = h - y;        // Calcular quanto subiu
    height += heightGain;          // Contar para estat√≠sticas
    score += heightGain / 5;       // Dar pontos por subir
    
    // Mover TODAS as plataformas para baixo
    for (int i = 0; i < 10; i++) {
        plat[i].y = plat[i].y - dy;
        
        // Se uma plataforma saiu da tela por baixo, criar uma nova no topo
        if (plat[i].y > 533) {
            plat[i].y = -50;           // Nova posi√ß√£o no topo
            plat[i].x = rand() % 332;  // Posi√ß√£o horizontal aleat√≥ria
        }
    }
    y = h; // Colocar o jogador de volta na altura de refer√™ncia
}
```

Por que fazer assim?

* O jogador sempre fica vis√≠vel na tela

* Podemos criar plataformas infinitamente

* √â mais f√°cil de programar

* O jogo nunca "acaba" - sempre h√° mais plataformas aparecendo

### Como Detectar se o Jogador Tocou uma Plataforma

Para saber se o jogador tocou uma plataforma, precisamos verificar se eles est√£o "se sobrepondo" na tela. √â como verificar se dois ret√¢ngulos est√£o se tocando.

Mas h√° uma regra especial: s√≥ detectamos a colis√£o quando o jogador est√° caindo (n√£o quando est√° subindo). Isso permite que o jogador passe atrav√©s das plataformas quando est√° subindo, mas "aterrisse" nelas quando est√° descendo.

```CPP
for (int i = 0; i < 10; i++) {  // Verificar todas as 10 plataformas
    if ((x + 25 > plat[i].x) &&              // Jogador n√£o est√° muito √† esquerda
        (x + 25 < plat[i].x + 68) &&         // Jogador n√£o est√° muito √† direita
        (y + 70 > plat[i].y) &&              // Jogador n√£o est√° muito acima
        (y + 70 < plat[i].y + 14) &&         // Jogador n√£o est√° muito abaixo
        (dy > 0)) {                          // Jogador est√° caindo (n√£o subindo)
        
        dy = -10;    // Fazer o jogador pular para cima
        score += 10; // Dar pontos por conseguir pular
    }
}
```

Entendendo as condi√ß√µes:

* x + 25: Usamos x + 25 porque queremos verificar o centro do jogador

* plat[i].x + 68: 68 √© a largura da plataforma

* y + 70: 70 √© aproximadamente a altura do jogador

* plat[i].y + 14: 14 √© a altura da plataforma

* dy > 0: S√≥ detecta colis√£o quando o jogador est√° caindo

Por que s√≥ quando est√° caindo?

* Se o jogador est√° subindo, ele deve passar atrav√©s da plataforma

* Se o jogador est√° descendo, ele deve "aterrissar" na plataforma

* Isso evita que o jogador fique "grudado" na plataforma

## A Matem√°tica Por Tr√°s do Jogo

### Calculando a Altura dos Pulos

Vamos descobrir algumas coisas interessantes sobre o nosso jogo usando matem√°tica simples.

No nosso jogo:

* A gravidade adiciona 0.2 √† velocidade a cada frame

* Quando o jogador pula, sua velocidade inicial √© -10

Qual √© a altura m√°xima que o jogador pode alcan√ßar?

Podemos calcular isso! Quando o jogador pula, ele come√ßa com velocidade -10 e a gravidade vai diminuindo essa velocidade at√© chegar a 0 (quando ele para de subir).

```
Altura m√°xima = (velocidade inicial)¬≤ √∑ (2 √ó gravidade)
Altura m√°xima = 10¬≤ √∑ (2 √ó 0.2) = 100 √∑ 0.4 = 250 pixels
```

Quanto tempo o jogador fica no ar?

```
Tempo para subir = velocidade inicial √∑ gravidade = 10 √∑ 0.2 = 50 frames
Tempo total no ar = 2 √ó tempo para subir = 100 frames
```

Se o jogo roda a 60 fps, isso significa que cada pulo dura cerca de 1.67 segundos.

### Por que as Plataformas Est√£o a 80 Pixels de Dist√¢ncia?

As plataformas est√£o espa√ßadas de 80 pixels verticalmente. Como o jogador pode pular at√© 250 pixels de altura, ele sempre consegue alcan√ßar as pr√≥ximas plataformas. Isso mant√©m o jogo desafiador mas sempre poss√≠vel de jogar.

```MERMAID
graph TB
    A[Plataforma Atual] -->|80px| B[Pr√≥xima Plataforma]
    B -->|80px| C[Plataforma Seguinte]
    D[Altura M√°xima: 250px] -.->|Alcan√ß√°vel| B
    D -.->|Alcan√ß√°vel| C
```

## Como Criar Plataformas Infinitas

Uma das partes mais legais do jogo √© que as plataformas nunca acabam. Isso √© chamado de "gera√ß√£o procedural" - o computador cria novo conte√∫do automaticamente conforme voc√™ joga.

### Criando as Primeiras Plataformas

Quando o jogo come√ßa, criamos 10 plataformas:

```CPP
for (int i = 0; i < 10; i++) {
    plat[i].x = rand() % 332;    // Posi√ß√£o horizontal aleat√≥ria
    plat[i].y = i * 80 + 100;    // Espa√ßamento vertical de 80 pixels
}
```

Por que usar 332?

* Nossa tela tem 400 pixels de largura

* Cada plataforma tem 68 pixels de largura

* Para a plataforma caber completamente na tela: 400 - 68 = 332

* Ent√£o podemos colocar a plataforma em qualquer posi√ß√£o de 0 a 332

### Reciclando Plataformas

Quando uma plataforma sai da parte de baixo da tela, n√£o a jogamos fora. Em vez disso, a "reciclamos" criando uma nova plataforma no topo:

```CPP
if (plat[i].y > 533) {         // Se a plataforma saiu da tela
    plat[i].y = -50;           // Colocar no topo da tela
    plat[i].x = rand() % 332;  // Nova posi√ß√£o horizontal aleat√≥ria
}
```

Isso significa que sempre temos exatamente 10 plataformas na tela, mas elas est√£o sempre mudando de posi√ß√£o.

## Como Funciona a Pontua√ß√£o

O jogo tem tr√™s formas de ganhar pontos:

### 1. Pontos por Subir

```CPP
score += heightGain / 5;  // 1 ponto a cada 5 pixels que subir
```

Conforme voc√™ sobe no jogo, ganha pontos automaticamente. Quanto mais alto, mais pontos!

### 2. Pontos por Pular em Plataformas

```CPP
score += 10;  // 10 pontos cada vez que toca uma plataforma
```

Cada vez que voc√™ consegue pular em uma plataforma, ganha 10 pontos extras.

### 3. B√¥nus Especiais

```CPP
if (height % 1000 == 0 && height > 0) {
    score += 500;  // 500 pontos a cada 1000 unidades de altura
}
```

A cada 1000 unidades de altura, voc√™ ganha um b√¥nus especial de 500 pontos!

## Melhorando a Apar√™ncia do Texto

### Texto com Contorno

Para que o texto seja sempre vis√≠vel (independente da cor do fundo), criamos uma fun√ß√£o especial que desenha um contorno ao redor das letras:

```CPP
void drawTextWithOutline(RenderWindow& window, Text& text, Color outlineColor) {
    Vector2f originalPos = text.getPosition();
    Color originalColor = text.getFillColor();
    
    // Desenhar "sombra" do texto em 8 posi√ß√µes ao redor
    text.setFillColor(outlineColor);
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            if (dx != 0 || dy != 0) {
                text.setPosition(originalPos.x + dx, originalPos.y + dy);
                window.draw(text);
            }
        }
    }
    
    // Desenhar o texto principal por cima
    text.setFillColor(originalColor);
    text.setPosition(originalPos);
    window.draw(text);
}
```

Esta fun√ß√£o desenha o texto em 8 posi√ß√µes ligeiramente diferentes ao redor da posi√ß√£o original, criando um efeito de contorno que torna o texto sempre leg√≠vel.

## Por que o Jogo Funciona Bem

### Usando Apenas 10 Plataformas

O jogo s√≥ precisa de 10 plataformas ativas ao mesmo tempo. Isso √© inteligente porque:

* Economiza mem√≥ria do computador

* O jogo funciona sempre na mesma velocidade

* √â mais f√°cil de programar e debugar

### Verifica√ß√µes Inteligentes

S√≥ verificamos colis√µes quando o jogador est√° caindo, n√£o quando est√° subindo. Isso torna o jogo mais r√°pido e evita problemas.

## Como o Jogo Funciona - O Loop Principal

Todo jogo tem um "loop principal" - um ciclo que se repete muitas vezes por segundo. A cada repeti√ß√£o (chamada de "frame"), o jogo:

```MERMAID
flowchart TD
    A[Come√ßar o frame] --> B[Ver o que o jogador apertou]
    B --> C{Em que tela estamos?}
    C -->|MENU| D[Mostrar menu]
    C -->|PLAYING| E[Jogar o jogo]
    C -->|GAME_OVER| F[Mostrar game over]
    D --> G[Desenhar tudo na tela]
    E --> H[Mover jogador e plataformas]
    F --> G
    H --> I[Mover a c√¢mera se necess√°rio]
    I --> G
    G --> J[Mostrar o frame na tela]
    J --> K{Continuar jogando?}
    K -->|Sim| A
    K -->|N√£o| L[Fechar o jogo]
```

### O que Cada Estado Faz

* MENU: Mostra o t√≠tulo do jogo e espera o jogador apertar Espa√ßo para come√ßar

* PLAYING: Roda toda a l√≥gica do jogo (f√≠sica, colis√µes, pontua√ß√£o)

* GAME_OVER: Mostra a pontua√ß√£o final e permite reiniciar ou voltar ao menu

## Como Executar o Jogo

### Compilar

```BASH
cd build
make doodle_jump
```

### Jogar

```BASH
make run_doodle_jump
```

### Arquivos Necess√°rios

O jogo precisa destes arquivos para funcionar:

* `images/background.png`: A imagem de fundo

* `images/platform.png`: A imagem da plataforma

* `images/doodle.png`: A imagem do personagem

* `fonts/Carlito-Regular.ttf`: A fonte para os textos

## Ideias para Melhorar o Jogo

### Novas Mec√¢nicas

* Power-ups como pulo duplo ou jetpack

* Plataformas especiais (que se movem, quebram, ou d√£o super pulo)

* Inimigos para evitar

* Efeitos sonoros e m√∫sica

### Melhorias T√©cnicas

* Mais plataformas na tela

* Gr√°ficos mais bonitos

* Anima√ß√µes suaves

* Sistema de save para lembrar da maior pontua√ß√£o

## 

C√≥digo do Jogo Completo

* [Repo](https://github.com/mrpunkdasilva/16Games-in-Cpp/tree/main/02%20%20Doodle%20Jump)

### Ver c√≥digo

```CPLUSPLUS
#include <SFML/Graphics.hpp>
#include <time.h>
#include <iostream>
#include <string>

using namespace sf;

struct point {
	int x, y;
};

enum GameState {
	MENU,
	PLAYING,
	GAME_OVER
};

// Fun√ß√£o para desenhar texto com borda para melhor visibilidade
void drawTextWithOutline(RenderWindow& window, Text& text, Color outlineColor = Color::Black) {
	Vector2f originalPos = text.getPosition();
	Color originalColor = text.getFillColor();
	
	// Desenhar sombra/borda em v√°rias posi√ß√µes
	text.setFillColor(outlineColor);
	for (int dx = -1; dx <= 1; dx++) {
		for (int dy = -1; dy <= 1; dy++) {
			if (dx != 0 || dy != 0) {
				text.setPosition(originalPos.x + dx, originalPos.y + dy);
				window.draw(text);
			}
		}
	}
	
	// Desenhar o texto principal
	text.setFillColor(originalColor);
	text.setPosition(originalPos);
	window.draw(text);
}

int main() {
	srand(time(0));

	RenderWindow app(VideoMode(400, 533), "Doodle Game!");
	app.setFramerateLimit(60);

	Texture t1,t2,t3;
    
    // Verifica√ß√£o de carregamento de imagens
    if (!t1.loadFromFile("images/background.png")) {
        std::cout << "Erro ao carregar background.png" << std::endl;
        return -1;
    }
    if (!t2.loadFromFile("images/platform.png")) {
        std::cout << "Erro ao carregar platform.png" << std::endl;
        return -1;
    }
    if (!t3.loadFromFile("images/doodle.png")) {
        std::cout << "Erro ao carregar doodle.png" << std::endl;
        return -1;
    }

	Sprite sBackground(t1), sPlat(t2), sPers(t3);

	point plat[20];

	// Inicializa√ß√£o das plataformas com espa√ßamento adequado
	for (int i = 0; i < 10; i++) {
		plat[i].x = rand() % 332; // 400 - 68 (largura da plataforma)
		plat[i].y = i * 80 + 100; // Espa√ßamento vertical adequado
	}

	// Estado do jogo
	GameState gameState = MENU;
	
	// Vari√°veis do jogo
	int x = 100, y = 100, h = 200;
	float dx = 0, dy = 0;
	int score = 0;
	int highScore = 0;
	int height = 0; // Altura m√°xima alcan√ßada
	
	// Configura√ß√£o de fonte
	Font font;
	bool fontLoaded = false;
	
	// Carrega fonte local do projeto (inclu√≠da para distribui√ß√£o)
	if (font.loadFromFile("fonts/Carlito-Regular.ttf")) {
		fontLoaded = true;
	}
	
	// Textos do menu
	Text titleText, startText, quitText, instructionsText;
	if (fontLoaded) {
		titleText.setFont(font);
		titleText.setCharacterSize(48);
		titleText.setFillColor(Color::Blue); // Azul para contraste com fundo branco
		titleText.setString("DOODLE JUMP");
		titleText.setPosition(80, 100);
		
		startText.setFont(font);
		startText.setCharacterSize(32);
		startText.setFillColor(Color::Black); // Preto para contraste
		startText.setString("Press SPACE to Start");
		startText.setPosition(70, 250);
		
		quitText.setFont(font);
		quitText.setCharacterSize(24);
		quitText.setFillColor(Color(64, 64, 64)); // Cinza escuro
		quitText.setString("Press ESC to Quit");
		quitText.setPosition(120, 350);
		
		instructionsText.setFont(font);
		instructionsText.setCharacterSize(20);
		instructionsText.setFillColor(Color(0, 100, 0)); // Verde escuro
		instructionsText.setString("Use LEFT/RIGHT arrows to move\nJump on platforms to go higher!");
		instructionsText.setPosition(40, 400);
	}
	
	// Textos do jogo
	Text scoreText, heightText;
	if (fontLoaded) {
		scoreText.setFont(font);
		scoreText.setCharacterSize(24);
		scoreText.setFillColor(Color::Black); // Preto para contraste
		scoreText.setPosition(10, 10);
		
		heightText.setFont(font);
		heightText.setCharacterSize(20);
		heightText.setFillColor(Color(0, 0, 150)); // Azul escuro
		heightText.setPosition(10, 40);
	}
	
	// Textos do game over
	Text gameOverText, finalScoreText, highScoreText, restartText;
	if (fontLoaded) {
		gameOverText.setFont(font);
		gameOverText.setCharacterSize(48);
		gameOverText.setFillColor(Color::Red); // Vermelho fica bom contra fundo branco
		gameOverText.setString("GAME OVER");
		gameOverText.setPosition(90, 150);
		
		finalScoreText.setFont(font);
		finalScoreText.setCharacterSize(28);
		finalScoreText.setFillColor(Color::Black); // Preto para contraste
		finalScoreText.setPosition(100, 220);
		
		highScoreText.setFont(font);
		highScoreText.setCharacterSize(24);
		highScoreText.setFillColor(Color(150, 100, 0)); // Marrom/dourado escuro
		highScoreText.setPosition(80, 260);
		
		restartText.setFont(font);
		restartText.setCharacterSize(20);
		restartText.setFillColor(Color(0, 100, 100)); // Verde-azul escuro
		restartText.setString("Press R to Restart\nPress M for Menu");
		restartText.setPosition(110, 320);
	}

	while (app.isOpen()) {
		Event e;
		while (app.pollEvent(e)) {
			if (e.type == Event::Closed)
				app.close();
			
			if (e.type == Event::KeyPressed) {
				switch (gameState) {
					case MENU:
						if (e.key.code == Keyboard::Space) {
							gameState = PLAYING;
							// Reiniciar vari√°veis do jogo
							x = 100;
							y = 100;
							h = 200;
							dy = 0;
							score = 0;
							height = 0;
							
							// Reiniciar plataformas
							for (int i = 0; i < 10; i++) {
								plat[i].x = rand() % 332;
								plat[i].y = i * 80 + 100;
							}
						}
						else if (e.key.code == Keyboard::Escape) {
							app.close();
						}
						break;
						
					case PLAYING:
						// Controles durante o jogo s√£o tratados no loop principal
						break;
						
					case GAME_OVER:
						if (e.key.code == Keyboard::R) {
							gameState = PLAYING;
							// Reiniciar vari√°veis do jogo
							x = 100;
							y = 100;
							h = 200;
							dy = 0;
							score = 0;
							height = 0;
							
							// Reiniciar plataformas
							for (int i = 0; i < 10; i++) {
								plat[i].x = rand() % 332;
								plat[i].y = i * 80 + 100;
							}
						}
						else if (e.key.code == Keyboard::M) {
							gameState = MENU;
						}
						break;
				}
			}
		}

		// L√≥gica do jogo
		if (gameState == PLAYING) {
			// Controles horizontais com wrapping (movimento infinito)
			if (Keyboard::isKeyPressed(Keyboard::Right)) {
				x += 3;
				if (x > 400) x = -50; // Sai pela direita, aparece na esquerda
			}
			if (Keyboard::isKeyPressed(Keyboard::Left)) {
				x -= 3;
				if (x < -50) x = 400; // Sai pela esquerda, aparece na direita
			}

			// Aplicar gravidade
			dy += 0.2;
			y += dy;
			
			// Se o jogador cair muito baixo, game over
			if (y > 600) {
				gameState = GAME_OVER;
				// Atualizar high score
				if (score > highScore) {
					highScore = score;
				}
			}
			
			// L√≥gica de movimento do mundo (c√¢mera)
			if (y < h) {
				// Calcular altura alcan√ßada
				int heightGain = h - y;
				height += heightGain;
				
				// Aumenta o score quando o jogador sobe
				score += heightGain / 5; // Pontos por altura
				
				// B√¥nus por altura alcan√ßada
				if (height % 1000 == 0 && height > 0) {
					score += 500; // B√¥nus a cada 1000 unidades de altura
				}
				
				// Move todas as plataformas para baixo
				for (int i = 0; i < 10; i++) {
					plat[i].y = plat[i].y - dy;
					// Se a plataforma sair da tela por baixo, reposiciona no topo
					if (plat[i].y > 533) {
						plat[i].y = -50; // Aparece no topo
						plat[i].x = rand() % 332; // Nova posi√ß√£o horizontal
					}
				}
				y = h; // Mant√©m o jogador na mesma altura visual
			}

			// Verifica√ß√£o de colis√£o corrigida
			for (int i = 0; i < 10; i++) {
				// Verifica se o jogador est√° caindo (dy > 0) e colidindo com a plataforma
				if ((x + 25 > plat[i].x) && (x + 25 < plat[i].x + 68) && 
				    (y + 70 > plat[i].y) && (y + 70 < plat[i].y + 14) && (dy > 0)) {
					dy = -10; // Faz o jogador pular
					score += 10; // Pontos por pular na plataforma
				}
			}
		}

		// Desenhar tudo
		app.draw(sBackground);
		
		switch (gameState) {
			case MENU:
				if (fontLoaded) {
					drawTextWithOutline(app, titleText, Color::White);
					drawTextWithOutline(app, startText, Color::White);
					drawTextWithOutline(app, quitText, Color::White);
					drawTextWithOutline(app, instructionsText, Color::White);
					
					// Mostrar high score no menu
					if (highScore > 0) {
						Text menuHighScore;
						menuHighScore.setFont(font);
						menuHighScore.setCharacterSize(20);
						menuHighScore.setFillColor(Color(150, 100, 0)); // Marrom/dourado escuro
						menuHighScore.setString("High Score: " + std::to_string(highScore));
						menuHighScore.setPosition(130, 300);
						drawTextWithOutline(app, menuHighScore, Color::White);
					}
				}
				break;
				
			case PLAYING:
				// Desenhar plataformas
				for (int i = 0; i < 10; i++) {
					sPlat.setPosition(plat[i].x, plat[i].y);
					app.draw(sPlat);
				}
				
				// Desenhar jogador
				sPers.setPosition(x, y);
				app.draw(sPers);
				
				// Desenhar UI do jogo
				if (fontLoaded) {
					scoreText.setString("Score: " + std::to_string(score));
					drawTextWithOutline(app, scoreText, Color::White);
					
					heightText.setString("Height: " + std::to_string(height));
					drawTextWithOutline(app, heightText, Color::White);
				}
				break;
				
			case GAME_OVER:
				// Desenhar estado final do jogo (sem movimento)
				for (int i = 0; i < 10; i++) {
					sPlat.setPosition(plat[i].x, plat[i].y);
					app.draw(sPlat);
				}
				
				sPers.setPosition(x, y);
				app.draw(sPers);
				
				// Desenhar UI do game over
				if (fontLoaded) {
					drawTextWithOutline(app, gameOverText, Color::White);
					
					finalScoreText.setString("Final Score: " + std::to_string(score));
					drawTextWithOutline(app, finalScoreText, Color::White);
					
					highScoreText.setString("High Score: " + std::to_string(highScore));
					drawTextWithOutline(app, highScoreText, Color::White);
					
					drawTextWithOutline(app, restartText, Color::White);
				}
				break;
		}

		app.display();
	}


	return 0;
}
```

## Conclus√£o

Parab√©ns! Voc√™ aprendeu como funciona um jogo completo. Doodle Jump pode parecer simples, mas ele ensina conceitos muito importantes:

* Estados de jogo: Como organizar diferentes telas

* F√≠sica b√°sica: Como simular gravidade e movimento

* Detec√ß√£o de colis√£o: Como saber quando objetos se tocam

* Gera√ß√£o procedural: Como criar conte√∫do infinito

* Sistema de c√¢mera: Como fazer o mundo se mover em vez do jogador

Estes conceitos s√£o usados em jogos muito mais complexos. Agora que voc√™ entende como funciona, pode experimentar modificar os valores no c√≥digo para ver o que acontece, ou at√© mesmo criar suas pr√≥prias mec√¢nicas!



# Arkanoid

Este tutorial ensina como criar o jogo Arkanoid do zero usando C++ e SFML. Vamos come√ßar com conceitos b√°sicos e construir o conhecimento passo a passo, explicando cada parte de forma clara e detalhada.

## O que √© Arkanoid

Imagine um jogo onde voc√™ controla uma raquete na parte inferior da tela, e precisa usar uma bola para destruir todos os blocos coloridos que est√£o organizados na parte superior. √â como se voc√™ estivesse jogando t√™nis, mas em vez de rebater a bola para o outro lado, voc√™ a usa para quebrar tijolos em uma parede:

* Uma bola ricocheia pela tela seguindo leis da f√≠sica

* Voc√™ controla uma raquete que pode se mover para esquerda e direita

* A bola deve rebater na raquete para n√£o cair fora da tela

* Cada bloco destru√≠do d√° pontos

* O objetivo √© destruir todos os blocos sem deixar a bola cair

Este jogo nos permite aprender v√°rios conceitos importantes de programa√ß√£o de jogos, incluindo f√≠sica de colis√µes, programa√ß√£o orientada a objetos e gerenciamento de estados.

## Como Organizar um Jogo Complexo

### Estados do Jogo - Diferentes Telas

O Arkanoid tem mais estados que jogos simples, pois precisa gerenciar situa√ß√µes como pausa e vit√≥ria:

* Menu: A tela inicial com instru√ß√µes

* Jogando: Quando o jogo est√° ativo

* Pausado: Quando o jogador pausa o jogo

* Game Over: Quando o jogador perde todas as vidas

* Vit√≥ria: Quando o jogador completa todos os n√≠veis

```MERMAID
graph LR
    A[MENU] -->|Espa√ßo| B[PLAYING]
    B -->|P| C[PAUSED]
    C -->|P| B
    B -->|Sem vidas| D[GAME_OVER]
    B -->|Todos blocos| E[VICTORY]
    D -->|R| A
    E -->|R| A
```

No c√≥digo, implementamos isso com um enum mais completo:

```CPP
enum GameState {
    MENU,        // Tela inicial
    PLAYING,     // Jogando ativamente
    PAUSED,      // Jogo pausado
    GAME_OVER,   // Perdeu todas as vidas
    VICTORY      // Completou todos os n√≠veis
};
```

### Programa√ß√£o Orientada a Objetos

Diferente de jogos simples, o Arkanoid usa classes para organizar melhor o c√≥digo. Cada elemento importante do jogo tem sua pr√≥pria classe:

#### Classe Block - Representando os Blocos

```CPP
class Block {
public:
    Sprite sprite;      // Como o bloco aparece na tela
    bool isDestroyed;   // Se foi destru√≠do ou n√£o
    int points;         // Quantos pontos vale
    
    Block() : isDestroyed(false), points(10) {} // Construtor
    
    void destroy() { isDestroyed = true; }      // Marcar como destru√≠do
    FloatRect getBounds() const;                // √Årea de colis√£o
    void draw(RenderWindow& window);            // Desenhar na tela
};
```

Por que usar uma classe?

* Cada bloco tem suas pr√≥prias propriedades (posi√ß√£o, cor, se foi destru√≠do)

* Podemos ter muitos blocos facilmente

* O c√≥digo fica mais organizado e reutiliz√°vel

#### Classe Ball - A Bola F√≠sica

```CPP
class Ball {
public:
    Sprite sprite;        // Apar√™ncia da bola
    Vector2f velocity;    // Velocidade (dire√ß√£o e rapidez)
    float speed;          // Velocidade base
    
    void update(float deltaTime, const Vector2u& windowSize);  // Atualizar posi√ß√£o
    void reverseX() { velocity.x = -velocity.x; }             // Inverter dire√ß√£o X
    void reverseY() { velocity.y = -velocity.y; }             // Inverter dire√ß√£o Y
    bool isOutOfBounds(const Vector2u& windowSize) const;     // Verificar se saiu da tela
};
```

A bola √© mais complexa porque precisa simular f√≠sica realista.

## As Principais Mec√¢nicas do Jogo

### F√≠sica da Bola - Movimento e Colis√µes

A bola do Arkanoid segue leis f√≠sicas simples. Ela se move em linha reta at√© colidir com algo, ent√£o muda de dire√ß√£o.

```MERMAID
graph TD
    A[A cada frame do jogo] --> B[Mover bola: posi√ß√£o += velocidade √ó tempo]
    B --> C[Verificar colis√£o com bordas]
    C --> D{Colidiu com borda?}
    D -->|Sim| E[Inverter dire√ß√£o apropriada]
    D -->|N√£o| F[Verificar colis√£o com raquete]
    F --> G{Colidiu com raquete?}
    G -->|Sim| H[Rebater com √¢ngulo]
    G -->|N√£o| I[Verificar colis√£o com blocos]
    I --> J{Colidiu com bloco?}
    J -->|Sim| K[Destruir bloco e rebater]
    J -->|N√£o| A
    E --> A
    H --> A
    K --> A
```

#### Movimento B√°sico

```CPP
void Ball::update(float deltaTime, const Vector2u& windowSize) {
    Vector2f pos = getPosition();
    pos += velocity * deltaTime;  // Mover baseado na velocidade
    
    // Colis√£o com bordas laterais e superior
    if (pos.x <= 0 || pos.x + getBounds().width >= windowSize.x) {
        velocity.x = -velocity.x;  // Inverter dire√ß√£o horizontal
    }
    if (pos.y <= 0) {
        velocity.y = -velocity.y;  // Inverter dire√ß√£o vertical
    }
    
    sprite.setPosition(pos);
}
```

Entendendo o deltaTime:

* `deltaTime` √© o tempo que passou desde o √∫ltimo frame

* Multiplicar por `deltaTime` faz o movimento ser suave independente da velocidade do computador

* Se o jogo roda a 60 FPS, `deltaTime` ser√° aproximadamente 0.0167 segundos

### Controle Inteligente da Raquete

A raquete responde aos comandos do jogador, mas tem limita√ß√µes realistas:

```CPP
void Paddle::update(float deltaTime, const Vector2u& windowSize) {
    Vector2f pos = getPosition();
    
    // Movimento baseado nas teclas pressionadas
    if (Keyboard::isKeyPressed(Keyboard::Left) || Keyboard::isKeyPressed(Keyboard::A)) {
        pos.x -= speed * deltaTime;  // Mover para esquerda
    }
    if (Keyboard::isKeyPressed(Keyboard::Right) || Keyboard::isKeyPressed(Keyboard::D)) {
        pos.x += speed * deltaTime;  // Mover para direita
    }
    
    // N√£o permitir sair da tela
    pos.x = std::max(0.0f, std::min(pos.x, (float)windowSize.x - getBounds().width));
    sprite.setPosition(pos);
}
```

Por que usar `speed * deltaTime`?

* Garante movimento suave

* A raquete se move na mesma velocidade em qualquer computador

* Permite controle responsivo

### O Truque do Rebote na Raquete

Uma das partes mais inteligentes do jogo √© como a bola rebate na raquete. N√£o √© apenas um rebote simples - o √¢ngulo depende de onde a bola toca a raquete:

```CPP
// Verificar colis√£o bola-raquete
if (ball.getBounds().intersects(paddle.getBounds())) {
    ball.reverseY();  // Sempre rebater para cima
    
    // Calcular √¢ngulo baseado na posi√ß√£o da colis√£o
    float ballCenter = ball.getPosition().x + ball.getBounds().width / 2;
    float paddleCenter = paddle.getPosition().x + paddle.getBounds().width / 2;
    float offset = (ballCenter - paddleCenter) / (paddle.getBounds().width / 2);
    
    // Ajustar velocidade horizontal baseada no offset
    ball.velocity.x = ball.speed * offset * 0.75f;
    ball.velocity.y = -std::abs(ball.velocity.y);  // Sempre para cima
}
```

```MERMAID
graph LR
    A[Bola toca esquerda da raquete] --> B[Rebate para esquerda e cima]
    C[Bola toca centro da raquete] --> D[Rebate direto para cima]
    E[Bola toca direita da raquete] --> F[Rebate para direita e cima]
```

Como funciona o c√°lculo:

* offset varia de -1 (extrema esquerda) a +1 (extrema direita)

* offset = 0 significa que a bola tocou o centro da raquete

* A velocidade horizontal √© proporcional ao offset

* Multiplicamos por 0.75 para n√£o deixar o rebote muito extremo

### Detec√ß√£o de Colis√£o com Blocos

Detectar qual lado do bloco a bola tocou √© crucial para um rebote realista:

```CPP
for (auto& block : blocks) {
    if (!block.isDestroyed && ball.getBounds().intersects(block.getBounds())) {
        block.destroy();  // Destruir o bloco
        score += block.points;  // Adicionar pontos
        
        // Determinar de que lado a bola colidiu
        Vector2f ballCenter = Vector2f(ball.getPosition().x + ball.getBounds().width / 2,
                                     ball.getPosition().y + ball.getBounds().height / 2);
        Vector2f blockCenter = Vector2f(block.getBounds().left + block.getBounds().width / 2,
                                       block.getBounds().top + block.getBounds().height / 2);
        
        float dx = std::abs(ballCenter.x - blockCenter.x);  // Dist√¢ncia horizontal
        float dy = std::abs(ballCenter.y - blockCenter.y);  // Dist√¢ncia vertical
        
        if (dx > dy) {
            ball.reverseX();  // Colidiu pela lateral
        } else {
            ball.reverseY();  // Colidiu por cima/baixo
        }
        
        break;  // S√≥ colidir com um bloco por frame
    }
}
```

Por que esse m√©todo funciona?

* Se `dx > dy`, a bola est√° mais pr√≥xima da lateral do bloco

* Se `dy > dx`, a bola est√° mais pr√≥xima do topo/base do bloco

* Isso determina se devemos inverter a velocidade X ou Y

## Criando o Mundo do Jogo

### Gera√ß√£o Procedural de Blocos

O jogo cria uma grade organizada de blocos coloridos:

```CPP
void createBlocks() {
    blocks.clear();
    const int rows = 8;      // 8 fileiras de blocos
    const int cols = 10;     // 10 colunas de blocos
    const float blockWidth = 60;
    const float blockHeight = 25;
    const float spacing = 5;  // Espa√ßo entre blocos
    
    // Centralizar a grade na tela
    const float startX = (800 - (cols * blockWidth + (cols - 1) * spacing)) / 2;
    const float startY = 50;
    
    for (int row = 0; row < rows; row++) {
        for (int col = 0; col < cols; col++) {
            Block block;
            
            // Calcular posi√ß√£o
            float x = startX + col * (blockWidth + spacing);
            float y = startY + row * (blockHeight + spacing);
            block.setPosition(x, y);
            
            // Blocos superiores valem mais pontos
            block.points = (rows - row) * 10;
            
            // Cores diferentes para cada fileira
            Color blockColor = blockColors[row % blockColors.size()];
            block.sprite.setColor(blockColor);
            
            blocks.push_back(block);
        }
    }
}
```

Por que essa organiza√ß√£o?

* Centralizamos a grade para ficar visualmente equilibrada

* Blocos superiores valem mais pontos (mais dif√≠ceis de alcan√ßar)

* Cores diferentes tornam o jogo mais atrativo

* Espa√ßamento uniforme cria uma apar√™ncia profissional

### Sistema de Vidas e Progress√£o

O jogo implementa um sistema de vidas realista:

```CPP
// Verificar se bola saiu da tela
if (ball.isOutOfBounds(window.getSize())) {
    lives--;  // Perder uma vida
    if (lives <= 0) {
        gameState = GAME_OVER;  // Fim de jogo
    } else {
        ball.reset(400, 300);   // Reposicionar bola
    }
}
```

E um sistema de progress√£o por n√≠veis:

```CPP
// Verificar vit√≥ria (todos os blocos destru√≠dos)
bool allDestroyed = true;
for (const auto& block : blocks) {
    if (!block.isDestroyed) {
        allDestroyed = false;
        break;
    }
}

if (allDestroyed) {
    level++;
    score += 1000 * level;     // B√¥nus por completar n√≠vel
    if (level <= 3) {          // M√°ximo 3 n√≠veis
        createBlocks();        // Criar novos blocos
        ball.reset(400, 300);  // Reposicionar bola
        ball.speed += 50;      // Aumentar dificuldade
    } else {
        gameState = VICTORY;   // Vit√≥ria total!
    }
}
```

## Texturas Procedurais - Gr√°ficos Sem Arquivos

Uma caracter√≠stica inteligente do jogo √© criar gr√°ficos automaticamente se n√£o encontrar arquivos de imagem:

### Criando uma Bola Redonda

```CPP
if (!ballTexture.loadFromFile("images/ball.png")) {
    // Criar textura de bola procedural
    Image ballImage;
    ballImage.create(20, 20, Color::White);
    
    for (int x = 0; x < 20; x++) {
        for (int y = 0; y < 20; y++) {
            int dx = x - 10;  // Dist√¢ncia do centro
            int dy = y - 10;
            
            // Se est√° dentro do c√≠rculo (raio = 10)
            if (dx*dx + dy*dy <= 100) {
                ballImage.setPixel(x, y, Color::White);
            } else {
                ballImage.setPixel(x, y, Color::Transparent);
            }
        }
    }
    ballTexture.loadFromImage(ballImage);
}
```

Como funciona a matem√°tica:

* `dx*dx + dy*dy` √© a dist√¢ncia ao quadrado do centro

* Se for ‚â§ 100, est√° dentro de um c√≠rculo de raio 10

* Pixels dentro do c√≠rculo ficam brancos, fora ficam transparentes

### Criando um Fundo com Estrelas

```CPP
// Criar fundo procedural com gradiente e estrelas
Image bgImage;
bgImage.create(800, 600, Color::Black);

// Criar um gradiente do azul escuro para preto
for (int y = 0; y < 600; y++) {
    for (int x = 0; x < 800; x++) {
        float factor = (float)y / 600.0f;  // 0 no topo, 1 na base
        Uint8 blue = (Uint8)(30 * (1.0f - factor));
        Uint8 green = (Uint8)(10 * (1.0f - factor));
        bgImage.setPixel(x, y, Color(0, green, blue));
    }
}

// Adicionar algumas "estrelas" aleat√≥rias
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<> xDist(0, 799);
std::uniform_int_distribution<> yDist(0, 399);  // Apenas na parte superior
std::uniform_int_distribution<> brightDist(100, 255);

for (int i = 0; i < 100; i++) {
    int x = xDist(gen);
    int y = yDist(gen);
    Uint8 brightness = brightDist(gen);
    bgImage.setPixel(x, y, Color(brightness, brightness, brightness));
}
```

Por que fazer isso?

* O jogo funciona mesmo sem arquivos de imagem

* Reduz depend√™ncias externas

* Permite personaliza√ß√£o f√°cil

* Ensina como criar gr√°ficos programaticamente

## Sistema de Pontua√ß√£o Inteligente

O jogo tem m√∫ltiplas formas de ganhar pontos:

### 1. Pontos por Bloco Destru√≠do

```CPP
score += block.points;  // Cada bloco tem valor diferente
```

Blocos superiores valem mais pontos pois s√£o mais dif√≠ceis de alcan√ßar.

### 2. B√¥nus por Completar N√≠vel

```CPP
score += 1000 * level;  // B√¥nus aumenta a cada n√≠vel
```

Completar n√≠veis mais altos d√° b√¥nus maiores.

### 3. Sistema de Vidas

```CPP
int lives = 3;  // Come√ßar com 3 vidas
```

Cada vida perdida significa uma nova chance, mas a pontua√ß√£o n√£o reseta.

## Efeitos Visuais Avan√ßados

### Mostrar Pontos Ganhados

Quando um bloco √© destru√≠do, o jogo mostra os pontos ganhos:

```CPP
// Mostrar bonus de pontos
lastScoreGain = block.points;
showScoreBonus = true;
effectClock.restart();

// Na renderiza√ß√£o:
if (showScoreBonus) {
    bonusText.setString("+" + std::to_string(lastScoreGain));
    bonusText.setPosition(ball.getPosition().x, ball.getPosition().y - 30);
    window.draw(bonusText);
}

// Esconder ap√≥s 1 segundo
if (showScoreBonus && effectClock.getElapsedTime().asSeconds() > 1.0f) {
    showScoreBonus = false;
}
```

### Interface de Usu√°rio Din√¢mica

```CPP
void updateUI() {
    std::stringstream ss;
    ss << "Score: " << score;
    scoreText.setString(ss.str());
    
    ss.str("");
    ss << "Lives: " << lives;
    livesText.setString(ss.str());
    
    ss.str("");
    ss << "Level: " << level;
    levelText.setString(ss.str());
}
```

## A Matem√°tica Por Tr√°s do Jogo

### Velocidade da Bola

A bola tem uma velocidade constante, mas sua dire√ß√£o muda:

```CPP
float speed = 300.0f;  // Pixels por segundo
Vector2f velocity = Vector2f(speed, -speed);  // Diagonal inicial
```

Calculando a velocidade real:

```
Velocidade diagonal = sqrt(speed¬≤ + speed¬≤) = sqrt(2) √ó speed
Para speed = 300: velocidade real = 424.26 pixels/segundo
```

### Progress√£o de Dificuldade

A cada n√≠vel, a velocidade da bola aumenta:

```CPP
ball.speed += 50;  // +50 pixels/segundo por n√≠vel
```

Velocidades por n√≠vel:

* N√≠vel 1: 300 px/s

* N√≠vel 2: 350 px/s

* N√≠vel 3: 400 px/s

### C√°lculo de Pontua√ß√£o M√°xima

Com 8 fileiras de 10 blocos cada:

```CPP
// Pontos por fileira (de cima para baixo): 80, 70, 60, 50, 40, 30, 20, 10
// Total por n√≠vel: (80+70+60+50+40+30+20+10) √ó 10 = 3600 pontos
// B√¥nus por n√≠vel: 1000, 2000, 3000
// Pontua√ß√£o m√°xima: (3600 √ó 3) + (1000 + 2000 + 3000) = 16,800 pontos
```

## Por que o Jogo Funciona Bem

### Organiza√ß√£o com Classes

Usar classes torna o c√≥digo:

* Mais leg√≠vel: Cada classe tem uma responsabilidade clara

* Mais reutiliz√°vel: Podemos criar m√∫ltiplos blocos facilmente

* Mais f√°cil de debugar: Problemas ficam isolados em classes espec√≠ficas

* Mais expans√≠vel: Podemos adicionar novos tipos de blocos facilmente

### Gerenciamento Inteligente de Mem√≥ria

```CPP
std::vector<Block> blocks;  // Vetor din√¢mico de blocos
```

* Crescimento autom√°tico: O vetor cresce conforme necess√°rio

* Mem√≥ria cont√≠gua: Melhor performance para itera√ß√£o

* Limpeza autom√°tica: RAII garante que a mem√≥ria seja liberada

### Estados Bem Definidos

O sistema de estados evita bugs comuns:

* S√≥ processa entrada do jogo quando `gameState == PLAYING`

* S√≥ atualiza f√≠sica quando necess√°rio

* Interface limpa entre diferentes telas

### Separa√ß√£o de Responsabilidades

```CPP
void handleEvents();  // S√≥ lida com entrada do usu√°rio
void update();        // S√≥ atualiza l√≥gica do jogo  
void render();        // S√≥ desenha na tela
```

Esta separa√ß√£o torna o c√≥digo mais f√°cil de manter e expandir.

## Extens√µes Poss√≠veis

O c√≥digo est√° estruturado para permitir extens√µes f√°ceis:

### Novos Tipos de Blocos

```CPP
class SpecialBlock : public Block {
    int hitCount;  // Blocos que precisam de m√∫ltiplos hits
    bool hasBonus; // Blocos que d√£o power-ups
};
```

### Power-ups

```CPP
class PowerUp {
    enum Type { BIGGER_PADDLE, SLOWER_BALL, EXTRA_LIFE };
    // Implementar l√≥gica de power-ups
};
```

### Mais N√≠veis

```CPP
void createBlocks(int levelNumber) {
    // Criar padr√µes diferentes para cada n√≠vel
    // Blocos mais resistentes em n√≠veis altos
}
```

### Salvamento de Pontua√ß√£o

```CPP
void saveHighScore(int score) {
    // Salvar em arquivo para persistir entre sess√µes
}
```

## Conceitos Importantes Aprendidos

Este tutorial ensina:

1. Programa√ß√£o Orientada a Objetos: Classes, heran√ßa, encapsulamento

2. F√≠sica de Jogos: Movimento, colis√µes, rebotes realistas

3. Gerenciamento de Estados: Como organizar diferentes telas de um jogo

4. Gera√ß√£o Procedural: Criar conte√∫do automaticamente

5. Interface de Usu√°rio: Feedback visual e informa√ß√µes para o jogador

6. Otimiza√ß√£o: Como escrever c√≥digo eficiente para jogos

O Arkanoid √© um exemplo perfeito de como jogos aparentemente simples podem ensinar conceitos avan√ßados de programa√ß√£o de forma divertida e pr√°tica.



# Snake

Este tutorial ensina como criar o cl√°ssico jogo Snake do zero usando C++ e SFML. Vamos construir o conhecimento passo a passo, explicando cada mec√¢nica e conceito de programa√ß√£o envolvido, desde o movimento b√°sico at√© sistemas avan√ßados de valida√ß√£o.

## O que √© Snake

Imagine um jogo onde voc√™ controla uma cobra que cresce a cada fruta que come, mas nunca pode tocar em si mesma. √â um dos jogos mais simples e viciantes j√° criados:

* Uma cobra se move continuamente pela tela

* Voc√™ controla apenas a dire√ß√£o (cima, baixo, esquerda, direita)

* A cobra cresce cada vez que come uma fruta

* O jogo termina se a cobra colidir consigo mesma ou com as paredes

* O objetivo √© conseguir a maior pontua√ß√£o poss√≠vel comendo frutas

Este jogo nos permite aprender conceitos fundamentais como arrays, l√≥gica de movimento, detec√ß√£o de colis√µes e valida√ß√£o de entrada do usu√°rio.

## Como Organizar o Jogo Snake

### Estados do Jogo - Controle de Fluxo

O Snake possui tr√™s estados principais que controlam toda a experi√™ncia:

* Menu: Tela inicial com instru√ß√µes e configura√ß√µes

* Jogando: Quando o jogo est√° ativo e a cobra se move

* Game Over: Quando o jogador perde, com op√ß√µes de reiniciar

```MERMAID
graph LR
    A[MENU] -->|Espa√ßo| B[PLAYING]
    B -->|Colis√£o| C[GAME_OVER]
    C -->|R| B
    C -->|M| A
    A -->|T| A
```

No c√≥digo, implementamos isso com um enum simples:

```CPP
enum GameState {
    MENU,        // Tela inicial
    PLAYING,     // Jogando ativamente  
    GAME_OVER    // Perdeu o jogo
};

GameState currentState = MENU;  // Come√ßa no menu
```

### Estruturas de Dados - Representando o Mundo do Jogo

#### Estrutura da Cobra

```CPP
struct Snake {
    int x, y;    // Posi√ß√£o na grade
} s[100];        // Array para at√© 100 segmentos

int num = 4;     // N√∫mero atual de segmentos da cobra
int dir = 0;     // Dire√ß√£o atual (0=baixo, 1=esquerda, 2=direita, 3=cima)
```

Por que usar um array?

* A cobra √© uma sequ√™ncia de segmentos conectados

* Cada segmento segue o movimento do anterior

* Array permite acesso direto e eficiente a qualquer segmento

* Tamanho fixo evita problemas de aloca√ß√£o din√¢mica

#### Estrutura da Fruta

```CPP
struct Fruit {
    int x, y;    // Posi√ß√£o na grade
} f;

int score = 0;       // Pontua√ß√£o atual
int highScore = 0;   // Maior pontua√ß√£o j√° alcan√ßada
```

### Sistema de Grade - Coordenadas L√≥gicas vs. Visuais

O jogo funciona em duas camadas de coordenadas:

```CPP
int N = 30, M = 20;  // Grade l√≥gica: 30x20 c√©lulas
int size = 16;       // Tamanho de cada c√©lula em pixels
int w = size * N;    // Largura da janela: 480 pixels
int h = size * M;    // Altura da janela: 320 pixels
```

Vantagens deste sistema:

* L√≥gica simples: Posi√ß√µes s√£o n√∫meros inteiros (0 a 29, 0 a 19)

* Movimento discreto: A cobra se move c√©lula por c√©lula

* Colis√µes precisas: Compara√ß√£o simples de coordenadas inteiras

* Escalabilidade: F√°cil mudar tamanho do jogo alterando `size`

## As Principais Mec√¢nicas do Jogo

### Movimento da Cobra - A Ess√™ncia do Snake

O movimento da cobra √© o cora√ß√£o do jogo. Cada segmento segue o anterior, criando o efeito de uma cobra se movendo:

```MERMAID
graph TD
    A[A cada frame do jogo] --> B[Mover corpo: cada segmento para posi√ß√£o do anterior]
    B --> C[Mover cabe√ßa baseado na dire√ß√£o]
    C --> D[Verificar colis√£o com parede]
    D --> E{Colidiu com parede?}
    E -->|Sim| F[Game Over ou Atravessar]
    E -->|N√£o| G[Verificar colis√£o consigo]
    G --> H{Colidiu consigo?}
    H -->|Sim| I[Game Over]
    H -->|N√£o| J[Verificar colis√£o com fruta]
    J --> K{Comeu fruta?}
    K -->|Sim| L[Crescer cobra e nova fruta]
    K -->|N√£o| A
    F --> A
    I --> M[Tela Game Over]
    L --> A
```

#### Implementa√ß√£o do Movimento

```CPP
void Tick() {
    // 1. Mover o corpo da cobra (cada segmento segue o anterior)
    for (int i = num - 1; i > 0; --i) {
        s[i].x = s[i-1].x;  // Copia posi√ß√£o X do segmento anterior
        s[i].y = s[i-1].y;  // Copia posi√ß√£o Y do segmento anterior
    }
    
    // 2. Mover a cabe√ßa da cobra baseado na dire√ß√£o
    if (dir == 0) s[0].y += 1;      // Baixo
    if (dir == 1) s[0].x -= 1;      // Esquerda
    if (dir == 2) s[0].x += 1;      // Direita
    if (dir == 3) s[0].y -= 1;      // Cima
    
    // 3. Resto da l√≥gica de colis√µes...
}
```

Por que esse algoritmo funciona?

* Movimento em cadeia: Come√ßamos do final (`num-1`) e vamos at√© o segundo segmento (`1`)

* Preserva√ß√£o de posi√ß√µes: Cada segmento "lembra" onde o anterior estava

* Cabe√ßa independente: S√≥ a cabe√ßa (`s[0]`) se move baseada na dire√ß√£o do jogador

* Efeito visual: Cria a ilus√£o de uma cobra deslizando suavemente

### Controle de Dire√ß√£o - Prevenindo Morte Acidental

Um aspecto crucial √© impedir que o jogador v√° na dire√ß√£o oposta, o que causaria morte instant√¢nea:

```CPP
// Input do jogo com valida√ß√£o
if (currentState == PLAYING) {
    // Validar input para evitar movimento na dire√ß√£o oposta
    if (Keyboard::isKeyPressed(Keyboard::Left) && dir != 2) dir=1;   // ‚Üê s√≥ se n√£o estava indo ‚Üí
    if (Keyboard::isKeyPressed(Keyboard::Right) && dir != 1) dir=2;  // ‚Üí s√≥ se n√£o estava indo ‚Üê
    if (Keyboard::isKeyPressed(Keyboard::Up) && dir != 0) dir=3;     // ‚Üë s√≥ se n√£o estava indo ‚Üì
    if (Keyboard::isKeyPressed(Keyboard::Down) && dir != 3) dir=0;   // ‚Üì s√≥ se n√£o estava indo ‚Üë
}
```

Mapeamento das dire√ß√µes:

* `dir = 0`: Baixo (‚Üì) - oposto: Cima (3)

* `dir = 1`: Esquerda (‚Üê) - oposto: Direita (2)

* `dir = 2`: Direita (‚Üí) - oposto: Esquerda (1)

* `dir = 3`: Cima (‚Üë) - oposto: Baixo (0)

### Sistema de Colis√µes - Detectando Eventos do Jogo

#### Colis√£o com Parede

```CPP
bool checkWallCollision() {
    return (s[0].x < 0 || s[0].x >= N || s[0].y < 0 || s[0].y >= M);
}

void handleWallCollision() {
    if (wallCollisionEnabled) {
        // Modo cl√°ssico: game over ao bater na parede
        currentState = GAME_OVER;
    } else {
        // Modo wrap-around: atravessa para o outro lado
        if (s[0].x >= N) s[0].x = 0;      // Direita ‚Üí Esquerda
        if (s[0].x < 0) s[0].x = N - 1;   // Esquerda ‚Üí Direita
        if (s[0].y >= M) s[0].y = 0;      // Baixo ‚Üí Cima
        if (s[0].y < 0) s[0].y = M - 1;   // Cima ‚Üí Baixo
    }
}
```

Dois modos de jogo:

* Cl√°ssico: Colidir com parede = Game Over

* Wrap-around: Cobra atravessa as bordas (como Pac-Man)

#### Colis√£o Consigo Mesmo

```CPP
bool checkSelfCollision() {
    for (int i = 1; i < num; i++) {  // Come√ßar do √≠ndice 1 (pular a cabe√ßa)
        if (s[0].x == s[i].x && s[0].y == s[i].y) {
            return true;  // Cabe√ßa tocou algum segmento do corpo
        }
    }
    return false;
}
```

Por que come√ßar do √≠ndice 1?

* `s[0]` √© a cabe√ßa da cobra

* `s[1]` at√© `s[num-1]` s√£o os segmentos do corpo

* A cabe√ßa n√£o pode colidir consigo mesma (√≠ndice 0)

#### Colis√£o com Fruta

```CPP
bool checkFruitCollision() {
    return (s[0].x == f.x && s[0].y == f.y);
}

// Quando come fruta
if (checkFruitCollision()) {
    num++;           // Aumenta o tamanho da cobra
    score += 10;     // Adiciona pontos
    if (score > highScore) {
        highScore = score;  // Atualiza recorde
    }
    spawnNewFruit(); // Gera nova fruta
}
```

### Gera√ß√£o Inteligente de Frutas

Gerar uma fruta em posi√ß√£o v√°lida √© mais complexo do que parece:

```CPP
void spawnNewFruit() {
    bool validPosition = false;
    int attempts = 0;
    
    while (!validPosition && attempts < 100) {
        f.x = rand() % N;  // Posi√ß√£o X aleat√≥ria
        f.y = rand() % M;  // Posi√ß√£o Y aleat√≥ria
        
        // Verifica se a fruta n√£o est√° na cobra
        validPosition = true;
        for (int i = 0; i < num; i++) {
            if (f.x == s[i].x && f.y == s[i].y) {
                validPosition = false;  // Posi√ß√£o ocupada pela cobra
                break;
            }
        }
        attempts++;
    }
    
    // Fallback: se n√£o achou posi√ß√£o em 100 tentativas
    if (!validPosition) {
        f.x = rand() % N;
        f.y = rand() % M;
    }
}
```

Problemas que este algoritmo resolve:

* Fruta na cobra: Impede gerar fruta onde j√° h√° segmentos

* Loop infinito: Limite de 100 tentativas evita travamento

* Cobras grandes: Funciona mesmo quando a cobra ocupa muito espa√ßo

* Fallback seguro: Se n√£o achar posi√ß√£o v√°lida, pelo menos gera algo

## Gerenciamento de Estados e Interface

### Sistema de Menus - M√∫ltiplas Interfaces

O jogo precisa de diferentes interfaces para cada estado:

```CPP
void drawMenu(RenderWindow& window, Font& font, bool fontLoaded) {
    if (fontLoaded) {
        // Interface com texto quando fonte est√° dispon√≠vel
        Text title("SNAKE GAME", font, 50);
        title.setFillColor(Color::Green);
        title.setPosition(w/2 - 120, h/2 - 150);
        
        Text instruction("Pressione SPACE para jogar", font, 20);
        instruction.setFillColor(Color::White);
        instruction.setPosition(w/2 - 120, h/2 - 70);
        
        Text modeText("Modo: " + std::string(wallCollisionEnabled ? "Parede Mata" : "Atravessa Parede"), font, 18);
        modeText.setFillColor(Color::Cyan);
        modeText.setPosition(w/2 - 90, h/2 - 40);
        
        window.draw(title);
        window.draw(instruction);
        window.draw(modeText);
    } else {
        // Interface visual sem texto (fallback criativo)
        for (int i = 0; i < 5; i++) {
            RectangleShape segment(Vector2f(20, 20));
            segment.setFillColor(Color::Green);
            segment.setPosition(w/2 - 50 + i * 25, h/2 - 150);
            window.draw(segment);  // Desenha "SNAKE" visualmente
        }
    }
}
```

### Controle de Velocidade - Timing do Jogo

```CPP
Clock clock;
float timer = 0, delay = 0.1;  // Delay de 100ms entre movimentos

// No loop principal
float time = clock.getElapsedTime().asSeconds();
clock.restart();
timer += time;

if (currentState == PLAYING) {
    if (timer > delay) {
        timer = 0;
        Tick();  // Executar pr√≥ximo movimento
    }
}
```

Como funciona o timing:

* clock.getElapsedTime(): Tempo desde √∫ltima medi√ß√£o

* timer: Acumula tempo at√© atingir o delay

* delay = 0.1: Cobra se move 10 vezes por segundo

* timer = 0: Reset para pr√≥ximo ciclo

### Fun√ß√£o de Reset - Come√ßar Nova Partida

```CPP
void resetGame() {
    num = 4;         // Tamanho inicial da cobra
    score = 0;       // Zerar pontua√ß√£o
    dir = 0;         // Dire√ß√£o inicial (baixo)
    f.x = 10;        // Posi√ß√£o inicial da fruta
    f.y = 10;
    
    // Resetar posi√ß√£o da cobra (linha horizontal)
    for (int i = 0; i < 4; i++) {
        s[i].x = 4 - i;  // x: 4, 3, 2, 1
        s[i].y = 5;      // y: todos na linha 5
    }
    
    currentState = PLAYING;  // Iniciar jogo
}
```

Posicionamento inicial:

* Cabe√ßa: `s[0]` na posi√ß√£o (4, 5)

* Corpo: `s[1]` (3,5), `s[2]` (2,5), `s[3]` (1,5)

* Resultado: Cobra horizontal de 4 segmentos indo para a direita

## Conceitos Avan√ßados de Programa√ß√£o

### Valida√ß√£o de Dados - Prevenindo Bugs

```CPP
void validateGameState() {
    // Verificar se a cabe√ßa est√° dentro dos limites
    if (s[0].x < 0 || s[0].x >= N || s[0].y < 0 || s[0].y >= M) {
        if (wallCollisionEnabled && currentState != GAME_OVER) {
            // Erro: deveria ter terminado o jogo
            // √ötil para debug
        }
    }
    
    // Verificar colis√£o com pr√≥prio corpo
    for (int i = 1; i < num; i++) {
        if (s[0].x == s[i].x && s[0].y == s[i].y) {
            if (currentState != GAME_OVER) {
                // Erro: deveria ter terminado o jogo por auto-colis√£o
            }
        }
    }
}
```

Prop√≥sito da valida√ß√£o:

* Debug: Identificar bugs na l√≥gica

* Testes: Verificar se o jogo est√° funcionando corretamente

* Robustez: Detectar estados inv√°lidos

* Manuten√ß√£o: Facilitar corre√ß√£o de problemas

### Fallback Gr√°fico - Funcionar Sem Recursos

O jogo funciona mesmo sem arquivos de imagem:

```CPP
// Tentar carregar texturas
Texture t1, t2;
if (!t1.loadFromFile("images/white.png")) {
    // Criar textura procedural branca
    Image whiteImage;
    whiteImage.create(16, 16, Color::White);
    t1.loadFromImage(whiteImage);
}

if (!t2.loadFromFile("images/red.png")) {
    // Criar textura procedural vermelha
    Image redImage;
    redImage.create(16, 16, Color::Red);
    t2.loadFromImage(redImage);
}
```

Vantagens:

* Independ√™ncia: Jogo funciona em qualquer ambiente

* Robustez: N√£o quebra por arquivos faltando

* Desenvolvimento: Pode testar sem assets

* Distribui√ß√£o: Menos arquivos para gerenciar

### Sistema de Pontua√ß√£o Visual

Quando n√£o h√° fonte dispon√≠vel, criar visualiza√ß√£o de pontua√ß√£o:

```CPP
void drawScore(RenderWindow& window, Font& font, bool fontLoaded) {
    if (!fontLoaded) {
        // Score visual com barras
        int scoreBars = (score / 10) > 15 ? 15 : (score / 10);
        for (int i = 0; i < scoreBars; i++) {
            RectangleShape bar(Vector2f(6, 15));
            bar.setFillColor(Color::White);
            bar.setPosition(10 + i * 8, 10);
            window.draw(bar);
        }
        
        // High score visual
        int highScoreBars = (highScore / 10) > 15 ? 15 : (highScore / 10);
        for (int i = 0; i < highScoreBars; i++) {
            RectangleShape bar(Vector2f(6, 15));
            bar.setFillColor(Color::Yellow);
            bar.setPosition(w - 130 + i * 8, 10);
            window.draw(bar);
        }
    }
}
```

## Estrutura Completa do Main Loop

```CPP
int main() {
    srand(time(0));  // Seed para n√∫meros aleat√≥rios
    
    RenderWindow window(VideoMode(w, h), "Snake Game!");
    
    // Inicializa√ß√£o de recursos...
    
    while (window.isOpen()) {
        // 1. Controle de timing
        float time = clock.getElapsedTime().asSeconds();
        clock.restart();
        timer += time;
        
        // 2. Processar eventos
        Event e;
        while (window.pollEvent(e)) {
            if (e.type == Event::Closed) {
                window.close();
            }
            
            // Eventos espec√≠ficos por estado...
        }
        
        // 3. L√≥gica do jogo
        if (currentState == PLAYING) {
            // Input com valida√ß√£o
            // Movimento autom√°tico com timer
        }
        
        // 4. Renderiza√ß√£o
        window.clear();
        
        if (currentState == MENU) {
            drawMenu(window, font, fontLoaded);
        }
        else if (currentState == PLAYING) {
            // Desenhar fundo, cobra, fruta, interface
        }
        else if (currentState == GAME_OVER) {
            drawGameOver(window, font, fontLoaded);
        }
        
        window.display();
    }
    
    return 0;
}
```

## Conceitos de Programa√ß√£o Aprendidos

### 

1. Arrays e Indexa√ß√£o

* Uso de arrays para representar sequ√™ncias

* Manipula√ß√£o de √≠ndices com cuidado

* Diferen√ßa entre tamanho l√≥gico e f√≠sico

### 

2. M√°quinas de Estado

* Enum para representar estados

* Transi√ß√µes controladas entre estados

* Comportamento espec√≠fico por estado

### 

3. Algoritmos de Movimento

* Movimento em cadeia (seguir o l√≠der)

* Coordenadas l√≥gicas vs. f√≠sicas

* Controle de timing

### 

4. Detec√ß√£o de Colis√µes

* Colis√£o ponto-a-ponto

* M√∫ltiplos tipos de colis√£o

* Ordem de verifica√ß√£o de colis√µes

### 

5. Valida√ß√£o de Entrada

* Filtrar input inv√°lido

* Prevenir estados inconsistentes

* Interface responsiva e segura

### 

6. Gera√ß√£o Procedural

* Algoritmos de spawn inteligente

* Tratamento de casos extremos

* Fallbacks para situa√ß√µes problem√°ticas

Este jogo Snake demonstra como um conceito simples pode envolver m√∫ltiplas t√©cnicas avan√ßadas de programa√ß√£o, desde estruturas de dados b√°sicas at√© algoritmos de valida√ß√£o robustos.



# Minesweeper

Este tutorial aprofunda a implementa√ß√£o do cl√°ssico jogo Campo Minado (Minesweeper) utilizando C++ e a biblioteca SFML. Abordaremos a arquitetura do jogo, as estruturas de dados subjacentes, os algoritmos centrais e a gest√£o da interface do utilizador de forma t√©cnica e detalhada.

## Vis√£o Geral T√©cnica

Minesweeper √© um jogo de l√≥gica baseado em uma grade, onde o jogador deve deduzir a localiza√ß√£o de minas ocultas. A implementa√ß√£o foca na gest√£o eficiente de estados, manipula√ß√£o de grades 2D e um algoritmo recursivo de "flood fill" para revelar √°reas do tabuleiro.

## Organizac√£o do Jogo

### Estados do Jogo - Uma M√°quina de Estados Finitos

O fluxo do jogo √© controlado por uma m√°quina de estados simples, definida por um `enum` e uma vari√°vel global `currentGameState`. Isso permite que o programa se comporte de maneira diferente dependendo do contexto (menu, jogo ativo, fim de jogo).

```CPP
enum GameState {
    MENU,        // Tela inicial, aguardando o jogador iniciar
    PLAYING,     // Jogo em andamento, processando intera√ß√µes do tabuleiro
    GAME_OVER,   // Jogo finalizado por derrota (mina detonada)
    GAME_WON     // Jogo finalizado por vit√≥ria (todas as c√©lulas seguras reveladas)
};

GameState currentGameState = MENU; // O jogo sempre inicia no estado de menu
```

As transi√ß√µes de estado s√£o acionadas por eventos do utilizador (cliques) ou por condi√ß√µes de jogo (detonar mina, revelar todas as c√©lulas seguras).

```MERMAID
graph LR
    A[MENU] -->|Clique em Start Game| B[PLAYING]
    B -->|Mina Clicada| C[GAME_OVER]
    B -->|Todas as c√©lulas seguras reveladas| D[GAME_WON]
    C -->|Qualquer Clique| B
    D -->|Qualquer Clique| B
```

### Estruturas de Dados - Representa√ß√£o do Tabuleiro

O tabuleiro do Minesweeper √© modelado por duas matrizes bidimensionais de inteiros, ambas de tamanho `12x12` para acomodar uma borda invis√≠vel de c√©lulas (√≠ndices 0 e 11) que simplifica a l√≥gica de verifica√ß√£o de vizinhos.

* `int grid[12][12]`: Esta matriz armazena o estado l√≥gico de cada c√©lula: * `0` a `8`: Indica o n√∫mero de minas adjacentes. * `9`: Representa uma mina. * As c√©lulas na borda (√≠ndices 0 e 11) s√£o geralmente inicializadas com `0` e n√£o s√£o exibidas ao jogador.

* `int sgrid[12][12]`: Esta matriz armazena o estado vis√≠vel de cada c√©lula para o jogador: * `10`: C√©lula coberta (n√£o revelada). * `11`: C√©lula marcada com uma bandeira. * `0` a `9`: C√©lula revelada, exibindo o n√∫mero de minas adjacentes ou uma mina (se detonada).

```CPP
int w = 32; // Tamanho em pixels de cada c√©lula (largura e altura)
int grid[12][12]; // Armazena o layout das minas e contagens
int sgrid[12][12]; // Armazena o que √© vis√≠vel para o jogador
```

### Sistema de Coordenadas

O jogo opera com dois sistemas de coordenadas:

1. Coordenadas L√≥gicas (Grid): Pares de inteiros `(i, j)` que representam a posi√ß√£o da c√©lula na matriz (ex: `grid[i][j]`). Estas s√£o usadas para toda a l√≥gica do jogo (c√°lculo de minas, verifica√ß√£o de vizinhos).

2. Coordenadas Visuais (Pixel): Pares de inteiros `(x, y)` em pixels, usadas para renderiza√ß√£o na janela SFML. A convers√£o √© feita multiplicando as coordenadas l√≥gicas pelo tamanho da c√©lula (`w`).

```CPP
// Convers√£o de coordenadas de pixel para grid
int x_grid = pos.x / w;
int y_grid = pos.y / w;

// Convers√£o de coordenadas de grid para pixel para posicionamento de sprites
s.setPosition(i * w, j * w);
```

## Mec√¢nicas e Algoritmos Centrais

### 

`resetGame()` - Inicializa√ß√£o e Reconfigura√ß√£o do Tabuleiro

Esta fun√ß√£o √© invocada no in√≠cio de cada nova partida. Seu algoritmo √©:

1. Inicializa√ß√£o de `sgrid`: Todas as c√©lulas vis√≠veis s√£o definidas como `10` (cobertas).

2. Inicializa√ß√£o de `grid`: Todas as c√©lulas l√≥gicas s√£o definidas como `0` (sem minas).

3. Posicionamento de Minas: Um loop duplo itera sobre as c√©lulas `(1,1)` a `(10,10)`. Para cada c√©lula, um n√∫mero aleat√≥rio √© gerado (`rand() % 5 == 0`). Se a condi√ß√£o for verdadeira (aproximadamente 20% de chance), a c√©lula em `grid[i][j]` √© definida como `9` (mina).

4. C√°lculo de N√∫meros: Outro loop duplo itera sobre as c√©lulas `(1,1)` a `(10,10)`. Se uma c√©lula n√£o contiver uma mina (`grid[i][j] != 9`), ela verifica seus 8 vizinhos (incluindo diagonais). Para cada vizinho que cont√©m uma mina (`grid[vizinho_x][vizinho_y] == 9`), um contador √© incrementado. O valor final do contador √© atribu√≠do a `grid[i][j]`. A borda invis√≠vel (`0` e `11`) garante que as verifica√ß√µes de vizinhos n√£o saiam dos limites da matriz.

```CPP
void resetGame() {
    // ... inicializa√ß√£o de grids ...
    for (int i = 1; i <= 10; i++) {
        for (int j = 1; j <= 10; j++) {
            if (grid[i][j] == 9) continue; // Ignora minas
            int n = 0;
            for (int dx = -1; dx <= 1; dx++) { // Itera sobre vizinhos
                for (int dy = -1; dy <= 1; dy++) {
                    if (grid[i + dx][j + dy] == 9) n++; // Conta minas vizinhas
                }
            }
            grid[i][j] = n;
        }
    }
}
```

```MERMAID
graph TD
    A[resetGame Invocado] --> B{Inicializar sgrid coberto e grid vazio}
    B --> C{Loop: Posicionar Minas Aleatoriamente}
    C --> D{Loop: Calcular N√∫meros de Minas Vizinhas}
    D --> E[Contagem de Minas Vizinhas]
    E --> F[Tabuleiro Pronto para Novo Jogo]
```

### 

`openCells()` - Algoritmo Recursivo de Flood Fill

Esta fun√ß√£o √© a espinha dorsal da mec√¢nica de revela√ß√£o de c√©lulas vazias. √â uma implementa√ß√£o cl√°ssica do algoritmo de flood fill:

1. Condi√ß√£o de Parada: A recurs√£o para se a c√©lula `(i, j)` j√° n√£o estiver coberta (`sgrid[i][j] != 10`). Isso evita loops infinitos e reprocessamento de c√©lulas j√° reveladas.

2. Revela√ß√£o: A c√©lula `sgrid[i][j]` √© atualizada para o valor correspondente em `grid[i][j]`, tornando-a vis√≠vel.

3. Propaga√ß√£o (para c√©lulas vazias): Se a c√©lula revelada for `0` (vazia, sem minas adjacentes), a fun√ß√£o chama a si mesma recursivamente para todos os seus 8 vizinhos (incluindo diagonais). As chamadas recursivas s√£o protegidas por verifica√ß√µes de limites (`i + dx >= 1 && i + dx <= 10`, etc.) para garantir que n√£o acessem √≠ndices inv√°lidos da matriz.

```CPP
void openCells(int i, int j) {
    if (sgrid[i][j] == 10) { // Se a c√©lula est√° coberta
        sgrid[i][j] = grid[i][j]; // Revela
        if (grid[i][j] == 0) { // Se for vazia, propaga
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    // Verifica limites e chama recursivamente
                    if (i + dx >= 1 && i + dx <= 10 && j + dy >= 1 && j + dy <= 10) {
                        openCells(i + dx, j + dy);
                    }
                }
            }
        }
    }
}
```

```MERMAID
graph TD
    A[Invocado] --> B{C√©lula Coberta?}
    B -- N√£o --> F[Retorna]
    B -- Sim --> C[Revela C√©lula]
    C --> D{C√©lula Vazia}
    D -- N√£o --> F
    D -- Sim --> E[Para cada Vizinho nx, ny]
    E --> G{Vizinho nx, ny V√°lido e Dentro dos Limites?}
    G -- Sim --> A
    G -- N√£o --> F
```

### Processamento de Entrada do Utilizador

O jogo responde a cliques do mouse, com o comportamento variando de acordo com o `currentGameState`:

* Estado `MENU`: Um clique esquerdo dentro da √°rea do texto "Start Game" transiciona o jogo para o estado `PLAYING` e inicia uma nova partida via `resetGame()`.

* Estados `GAME_OVER` / `GAME_WON`: Qualquer clique esquerdo reinicia o jogo, transicionando para `PLAYING` e chamando `resetGame()`.

* Estado `PLAYING`: * Clique Esquerdo: Se a c√©lula clicada estiver coberta (`sgrid[x][y] == 10`): * Se `grid[x][y] == 9` (mina): O estado muda para `GAME_OVER`. Todas as minas s√£o reveladas em `sgrid`. * Se `grid[x][y] == 0` (vazia): `openCells(x, y)` √© chamada para iniciar a revela√ß√£o recursiva. * Caso contr√°rio (n√∫mero `1-8`): A c√©lula √© simplesmente revelada (`sgrid[x][y] = grid[x][y]`). * Clique Direito: Alterna o estado da c√©lula entre coberta (`10`) e bandeira (`11`), mas apenas se a c√©lula estiver coberta ou j√° tiver uma bandeira.

### Condi√ß√µes de Vit√≥ria e Derrota

* Derrota: Detectada imediatamente quando um clique esquerdo revela uma mina (`grid[x][y] == 9`). O `currentGameState` √© definido como `GAME_OVER`.

* Vit√≥ria: Verificada a cada frame no estado `PLAYING`. O jogo √© ganho se: 1. O n√∫mero de c√©lulas cobertas (`sgrid[i][j] == 10` ou `sgrid[i][j] == 11`) for igual ao n√∫mero total de minas no tabuleiro. 2. E o n√∫mero de minas corretamente marcadas com bandeiras (`sgrid[i][j] == 11 && grid[i][j] == 9`) for igual ao n√∫mero total de minas. Esta l√≥gica garante que o jogador n√£o apenas revele todas as c√©lulas seguras, mas tamb√©m identifique corretamente todas as minas. Se a condi√ß√£o for satisfeita, `currentGameState` √© definido como `GAME_WON`.

## Interface do Utilizador (UI) e Renderiza√ß√£o

O SFML √© utilizado para desenhar todos os elementos visuais do jogo.

### 

Uso de Sprite Sheet (`images/tiles.jpg`)

O arquivo `tiles.jpg` √© uma sprite sheet contendo todas as imagens para os diferentes estados das c√©lulas. Cada imagem √© um quadrado de `32x32` pixels. A fun√ß√£o `s.setTextureRect(IntRect(sgrid[i][j] * w, 0, w, w))` √© crucial aqui: ela seleciona a por√ß√£o correta da sprite sheet (`sgrid[i][j] * w` pixels a partir da esquerda) para desenhar a c√©lula correspondente ao seu estado vis√≠vel.

* √çndices da Sprite Sheet: * `0` a `8`: Sprites para c√©lulas reveladas com 0 a 8 minas adjacentes. * `9`: Sprite da mina (exibida ao perder o jogo). * `10`: Sprite da c√©lula coberta. * `11`: Sprite da bandeira.

### 

Renderiza√ß√£o de Texto (`sf::Font`, `sf::Text`)

A fonte `Carlito-Regular.ttf` √© carregada para renderizar mensagens de status (`GAME OVER`, `YOU WIN!`, `Click to Play Again`) e elementos do menu (`MINESWEEPER`, `Start Game`).

* `sf::Font::loadFromFile()`: Carrega o arquivo da fonte.

* `sf::Text`: Objeto usado para configurar o texto (string, fonte, tamanho, cor, contorno).

* `setTextureRect()`: N√£o aplic√°vel a texto, mas `setPosition()` e `getGlobalBounds()` s√£o usados para centralizar e posicionar o texto dinamicamente na janela.

### 

Estrutura do Loop Principal (`main` function)

O loop principal do jogo √© o cora√ß√£o da aplica√ß√£o SFML, seguindo o padr√£o comum de jogos:

```MERMAID
graph TD
    A[In√≠cio do Loop Principal] --> B{Processar Eventos app.pollEvent}
    B --> C{currentGameState == MENU?}
    C -- Sim --> D[Verificar Clique em Start Game]
    C -- N√£o --> E{currentGameState == GAME_OVER ou GAME_WON?}
    E -- Sim --> F[Verificar Clique para Reiniciar]
    E -- N√£o --> G{currentGameState == PLAYING?}
    G -- Sim --> H[Processar Cliques Esquerdo/Direito]
    H --> I[Verificar Condi√ß√µes de Vit√≥ria]
    I --> J[Limpar Tela app.clear]
    J --> K{currentGameState == MENU?}
    K -- Sim --> L[Desenhar Menu]
    K -- N√£o --> M[Desenhar Tabuleiro]
    M --> N{currentGameState == GAME_OVER?}
    N -- Sim --> O[Desenhar Texto GAME OVER]
    N -- N√£o --> P{currentGameState == GAME_WON?}
    P -- Sim --> Q[Desenhar Texto YOU WIN!]
    Q --> R[Desenhar Texto Click to Play Again]
    R --> S[Apresentar Frame app.display]
    S --> A
```

## Conceitos de Programa√ß√£o Avan√ßados

### 1. M√°quinas de Estado Finitos (FSM)

* A implementa√ß√£o do `GameState` √© um exemplo claro de FSM, um padr√£o de design fundamental em desenvolvimento de jogos para gerenciar complexidade e fluxo de aplica√ß√£o.

### 2. Recurs√£o e Algoritmos de Busca (Flood Fill)

* A fun√ß√£o `openCells()` √© uma aplica√ß√£o pr√°tica e eficiente da recurs√£o para implementar o algoritmo de flood fill. √â essencial para a jogabilidade do Minesweeper, revelando grandes √°reas do tabuleiro com um √∫nico clique.

### 3. Manipula√ß√£o de Matrizes 2D e Verifica√ß√£o de Limites

* O uso de `grid` e `sgrid` demonstra a manipula√ß√£o de dados em estruturas 2D. A inclus√£o de uma borda invis√≠vel (`12x12` para um tabuleiro `10x10`) √© uma t√©cnica comum para simplificar a l√≥gica de verifica√ß√£o de vizinhos, evitando a necessidade de m√∫ltiplas verifica√ß√µes de `if` para os cantos e bordas do tabuleiro real.

### 4. Programa√ß√£o Orientada a Eventos

* O loop principal do SFML √© um exemplo cl√°ssico de programa√ß√£o orientada a eventos, onde o programa reage a intera√ß√µes do utilizador e eventos do sistema, em vez de seguir um fluxo linear.

### 5. Gera√ß√£o Procedural Simples

* A coloca√ß√£o aleat√≥ria de minas no `resetGame()` √© uma forma b√°sica de gera√ß√£o procedural de conte√∫do, onde elementos do jogo s√£o criados algoritmicamente em tempo de execu√ß√£o.

Este projeto de Minesweeper serve como um excelente estudo de caso para entender a aplica√ß√£o de algoritmos fundamentais, padr√µes de design e t√©cnicas de renderiza√ß√£o em um contexto de desenvolvimento de jogos.



# Fifteen-Puzzle

Este tutorial ensina como criar o jogo Fifteen-Puzzle do zero usando C++ e SFML, com foco nas melhorias de UI e no sistema de dicas. Vamos explorar o c√≥digo-fonte principal (`main.cpp`) passo a passo, explicando cada componente e sua fun√ß√£o.

## O que √© o Fifteen-Puzzle?

O Fifteen-Puzzle √© um quebra-cabe√ßa deslizante cl√°ssico, tamb√©m conhecido como Quebra-Cabe√ßa de 15. Ele consiste em uma moldura de pe√ßas quadradas numeradas de 1 a 15, com uma pe√ßa faltando, dispostas em uma grade 4x4.

### Como o Jogo Funciona

* Tabuleiro 4x4: O jogo √© jogado em uma grade de 4 linhas por 4 colunas.

* Pe√ßas Numeradas: 15 pe√ßas s√£o numeradas de 1 a 15.

* Espa√ßo Vazio: H√° um √∫nico espa√ßo vazio no tabuleiro.

* Movimento: O jogador pode mover qualquer pe√ßa adjacente (acima, abaixo, √† esquerda ou √† direita) para o espa√ßo vazio.

* Objetivo: Organizar as pe√ßas em ordem num√©rica crescente (da esquerda para a direita, de cima para baixo), deixando o espa√ßo vazio na √∫ltima posi√ß√£o (canto inferior direito).

## 

A Estrutura do C√≥digo (`main.cpp`)

O arquivo `main.cpp` cont√©m toda a l√≥gica do jogo, desde a inicializa√ß√£o da janela e dos elementos gr√°ficos at√© o manuseio das intera√ß√µes do usu√°rio e a renderiza√ß√£o na tela.

### 1. Inclus√µes e Namespace

Come√ßamos incluindo as bibliotecas necess√°rias. `SFML/Graphics.hpp` √© fundamental para todas as opera√ß√µes gr√°ficas e de janela. `iostream` √© para entrada/sa√≠da b√°sica, e `vector`, `random`, `algorithm` s√£o usados para o embaralhamento das pe√ßas.

```CPP
#include <SFML/Graphics.hpp> // Funcionalidades gr√°ficas e de janela
#include <iostream>          // Entrada/sa√≠da de console
#include <vector>            // Para usar std::vector
#include <random>            // Para gera√ß√£o de n√∫meros aleat√≥rios
#include <algorithm>         // Para usar std::shuffle

using namespace sf; // Simplifica o uso de classes e fun√ß√µes da SFML
```

### 

2. Estados do Jogo (`GameState`)

Para gerenciar as diferentes telas e comportamentos do jogo (menu, jogabilidade), utilizamos um `enum` simples chamado `GameState`. Isso permite que o programa saiba em qual "modo" ele est√° operando.

```CPP
enum GameState { MENU, GAME };
```

* `MENU`: O jogo est√° na tela inicial, onde o jogador pode escolher "Play" ou "Exit".

* `GAME`: O jogador est√° ativamente jogando o quebra-cabe√ßa.

### 

3. Embaralhamento do Tabuleiro (`shuffleGrid`)

A fun√ß√£o `shuffleGrid` √© respons√°vel por randomizar a disposi√ß√£o das pe√ßas no tabuleiro no in√≠cio de cada nova partida. Ela garante que o quebra-cabe√ßa seja sempre diferente e solucion√°vel.

```CPP
void shuffleGrid(int grid[6][6]) {
    std::vector<int> numbers;
    for (int i = 1; i <= 15; ++i) {
        numbers.push_back(i); // Adiciona n√∫meros de 1 a 15
    }
    std::random_device rd; // Gera uma semente aleat√≥ria baseada no hardware
    std::mt19937 g(rd());  // Motor de n√∫meros aleat√≥rios Mersenne Twister
    std::shuffle(numbers.begin(), numbers.end(), g); // Embaralha a ordem dos n√∫meros

    int k = 0;
    for (int i = 1; i <= 4; ++i) {
        for (int j = 1; j <= 4; ++j) {
            if (i == 4 && j == 4) {
                grid[i][j] = 16; // A √∫ltima posi√ß√£o (4,4) √© o espa√ßo vazio
            } else {
                grid[i][j] = numbers[k++]; // Preenche o grid com os n√∫meros embaralhados
            }
        }
    }
}
```

Explica√ß√£o:

* Um `std::vector<int> numbers` √© criado e preenchido com os valores de 1 a 15.

* `std::random_device` e `std::mt19937` s√£o usados para gerar uma sequ√™ncia de n√∫meros aleat√≥rios de alta qualidade.

* `std::shuffle` reorganiza os elementos do vetor `numbers` aleatoriamente.

* O tabuleiro (`grid`) √© ent√£o preenchido com esses n√∫meros embaralhados. A posi√ß√£o `grid[4][4]` (que corresponde √† √∫ltima c√©lula do tabuleiro 4x4) √© reservada para o espa√ßo vazio, representado pelo n√∫mero `16`.

### 

4. Verifica√ß√£o de Solu√ß√£o (`isSolved`)

A fun√ß√£o `isSolved` verifica se o jogador conseguiu organizar todas as pe√ßas na ordem correta. Ela percorre o tabuleiro e compara o valor de cada pe√ßa com o valor que deveria estar naquela posi√ß√£o em um tabuleiro resolvido.

```CPP
bool isSolved(int grid[6][6]) {
    int k = 1; // Valor esperado para a pe√ßa na posi√ß√£o atual
    for (int i = 1; i <= 4; ++i) {
        for (int j = 1; j <= 4; ++j) {
            if (k == 16) k = 0; // O valor 16 (espa√ßo vazio) n√£o √© verificado
            if (grid[i][j] != k && k != 0) {
                return false; // Se uma pe√ßa estiver fora de lugar, o puzzle n√£o est√° resolvido
            }
            k++; // Incrementa o valor esperado para a pr√≥xima posi√ß√£o
        }
    }
    return true; // Se todas as verifica√ß√µes passarem, o puzzle est√° resolvido
}
```

Explica√ß√£o:

* A vari√°vel `k` atua como um contador, representando o valor esperado para a pe√ßa na c√©lula atual (come√ßando de 1).

* O loop itera por todas as c√©lulas do tabuleiro.

* Se `k` for 16 (o valor do espa√ßo vazio), ele √© temporariamente ajustado para 0 para que a compara√ß√£o seja ignorada para o espa√ßo vazio.

* Se o valor da pe√ßa atual (`grid[i][j]`) n√£o corresponder ao valor esperado (`k`), a fun√ß√£o retorna `false`.

* Se o loop for conclu√≠do sem encontrar nenhuma pe√ßa fora de lugar, o tabuleiro est√° resolvido e a fun√ß√£o retorna `true`.

### 

5. Sistema de Dicas (`findHintMove`)

A fun√ß√£o `findHintMove` √© a intelig√™ncia por tr√°s do sistema de dicas. Ela localiza o espa√ßo vazio e, em seguida, procura por uma pe√ßa adjacente a ele que esteja fora de sua posi√ß√£o final correta. Se tal pe√ßa for encontrada, suas coordenadas s√£o retornadas como uma dica.

```CPP
Vector2i findHintMove(int grid[6][6]) {
    int emptyX = -1, emptyY = -1;
    // 1. Encontra a posi√ß√£o do espa√ßo vazio (valor 16)
    for (int i = 1; i <= 4; ++i) {
        for (int j = 1; j <= 4; ++j) {
            if (grid[i][j] == 16) {
                emptyX = i;
                emptyY = j;
                break;
            }
        }
        if (emptyX != -1) break;
    }

    // 2. Define as dire√ß√µes para verificar pe√ßas adjacentes (direita, esquerda, baixo, cima)
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    for (int i = 0; i < 4; ++i) {
        int nx = emptyX + dx[i]; // Coordenada X da pe√ßa adjacente
        int ny = emptyY + dy[i]; // Coordenada Y da pe√ßa adjacente

        // 3. Verifica se a pe√ßa adjacente est√° dentro dos limites do tabuleiro
        if (nx >= 1 && nx <= 4 && ny >= 1 && ny <= 4) {
            int tileValue = grid[nx][ny]; // Valor da pe√ßa adjacente
            // 4. Calcula o valor correto que deveria estar na posi√ß√£o (nx, ny)
            // A f√≥rmula (nx - 1) * 4 + ny converte coordenadas 1-baseadas (nx, ny)
            // para o valor esperado em um tabuleiro resolvido (1 a 16).
            if (tileValue != (nx - 1) * 4 + ny) {
                return Vector2i(nx, ny); // Retorna a posi√ß√£o da pe√ßa que pode ser movida
            }
        }
    }
    return Vector2i(-1, -1); // Nenhuma dica √∫til encontrada
}
```

Explica√ß√£o:

* A fun√ß√£o primeiro localiza as coordenadas `(emptyX, emptyY)` do espa√ßo vazio.

* Em seguida, ela itera sobre as quatro dire√ß√µes poss√≠veis (`dx`, `dy`) para encontrar pe√ßas adjacentes.

* Para cada pe√ßa adjacente, ela verifica se a pe√ßa est√° dentro dos limites do tabuleiro.

* A parte crucial √© a condi√ß√£o `tileValue != (nx - 1) * 4 + ny`. Isso compara o valor atual da pe√ßa com o valor que ela deveria ter se o tabuleiro estivesse resolvido. Se eles n√£o corresponderem, e a pe√ßa puder ser movida para o espa√ßo vazio, ela √© considerada uma dica.

* Se nenhuma dica for encontrada, `Vector2i(-1, -1)` √© retornado.

### 

6. Fun√ß√£o Principal (`main`)

A fun√ß√£o `main` √© o ponto de entrada do programa. Ela inicializa a janela, carrega recursos, configura os elementos da UI e cont√©m o loop principal do jogo, que gerencia eventos, atualiza o estado do jogo e renderiza tudo na tela.

```CPP
int main() {
    // 1. Inicializa√ß√£o da Janela
    RenderWindow app(VideoMode(256, 350), "15-Puzzle!"); // Cria a janela do jogo
    app.setFramerateLimit(60); // Define o limite de quadros por segundo

    GameState gameState = MENU; // O jogo come√ßa no estado de menu

    // 2. Carregamento da Fonte
    Font font;
    if (!font.loadFromFile("fonts/Carlito-Regular.ttf")) {
        return -1; // Erro se a fonte n√£o puder ser carregada
    }

    // 3. Configura√ß√£o dos Textos da UI (Menu, Vit√≥ria, Dica)
    // Cada texto √© configurado com sua string, fonte, tamanho, cor, origem (para centraliza√ß√£o) e posi√ß√£o.
    Text playText("Play", font, 50);
    // ... (configura√ß√µes de playText, exitText, winText, backToMenuText, hintText) ...

    // 4. Carregamento da Textura das Pe√ßas
    Texture t;
    t.loadFromFile("images/15.png"); // Carrega a imagem que cont√©m todas as pe√ßas

    int w = 64; // Largura/altura de cada pe√ßa (64x64 pixels)
    int grid[6][6] = {0}; // Representa√ß√£o interna do tabuleiro (com bordas para simplificar c√°lculos)
    Sprite sprite[20]; // Array de sprites, um para cada pe√ßa (1 a 16)

    // 5. Inicializa√ß√£o dos Sprites das Pe√ßas
    int n=0;
    for (int i=0; i<4; i++)
        for (int j=0; j<4; j++) {
            n++;
            sprite[n].setTexture(t); // Define a textura para o sprite
            // Define qual parte da imagem '15.png' corresponde a esta pe√ßa
            sprite[n].setTextureRect( IntRect(i*w,j*w,w,w) );
            grid[i+1][j+1]=n; // Preenche o grid inicial em ordem (para refer√™ncia)
        }

    // Vari√°veis para o sistema de dicas
    Vector2i hintedTile(-1, -1); // Armazena a posi√ß√£o da pe√ßa sugerida (-1,-1 se nenhuma)
    Clock hintClock; // Cron√¥metro para controlar a dura√ß√£o da dica
    float hintDuration = 2.0f; // Dura√ß√£o da dica em segundos

    // 6. Loop Principal do Jogo
    while (app.isOpen()) { // O loop continua enquanto a janela estiver aberta
        Event e;
        while (app.pollEvent(e)) { // Processa todos os eventos pendentes
            if (e.type == Event::Closed){
                app.close(); // Fecha a janela se o bot√£o 'X' for clicado
            }

            // 7. Manuseio de Eventos de Mouse (Movimento e Clique)
            // L√≥gica para efeitos de hover (mudar cor do texto ao passar o mouse)
            if (e.type == Event::MouseMoved) {
                // ... (l√≥gica de hover para playText, exitText, backToMenuText, hintText) ...
            }

            // L√≥gica para cliques do mouse
            if (e.type == Event::MouseButtonPressed) {
                if (e.key.code == Mouse::Left) { // Se o bot√£o esquerdo do mouse for clicado
                    Vector2i mousePos = Mouse::getPosition(app); // Posi√ß√£o do clique

                    if (gameState == MENU) {
                        // Transi√ß√£o para o estado GAME ao clicar em "Play"
                        if (playText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                            gameState = GAME;
                            shuffleGrid(grid); // Embaralha o tabuleiro para iniciar o jogo
                        }
                        // Fecha o aplicativo ao clicar em "Exit"
                        else if (exitText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                            app.close();
                        }
                    } else if (gameState == GAME) { // Se estiver no estado de jogo
                        if (isSolved(grid)) { // Se o puzzle estiver resolvido
                            // Volta para o menu se "Back to Menu" for clicado
                            if (backToMenuText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                                gameState = MENU;
                            }
                        }
                        // Ativa a dica ao clicar em "Hint"
                        else if (hintText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                            hintedTile = findHintMove(grid); // Encontra a dica
                            hintClock.restart(); // Reinicia o cron√¥metro da dica
                        }
                        // L√≥gica de movimento das pe√ßas do quebra-cabe√ßa
                        else {
                            int x = mousePos.x/w + 1; // Coluna clicada (1-baseada)
                            int y = mousePos.y/w + 1; // Linha clicada (1-baseada)

                            int dx=0; // Deslocamento em X para o espa√ßo vazio
                            int dy=0; // Deslocamento em Y para o espa√ßo vazio

                            // Verifica se a pe√ßa clicada √© adjacente ao espa√ßo vazio (16)
                            if (grid[x+1][y]==16) { dx=1; dy=0; }; // Espa√ßo vazio √† direita
                            if (grid[x][y+1]==16) { dx=0; dy=1; }; // Espa√ßo vazio abaixo
                            if (grid[x][y-1]==16) { dx=0; dy=-1; }; // Espa√ßo vazio acima
                            if (grid[x-1][y]==16) { dx=-1; dy=0; }; // Espa√ßo vazio √† esquerda

                            // Se a pe√ßa clicada pode se mover (dx ou dy n√£o s√£o 0)
                            if (dx != 0 || dy != 0) {
                                int n = grid[x][y]; // Valor da pe√ßa clicada
                                grid[x][y] = 16; // A posi√ß√£o da pe√ßa clicada se torna o espa√ßo vazio
                                grid[x+dx][y+dy] = n; // A pe√ßa clicada se move para a posi√ß√£o do espa√ßo vazio

                                // Anima√ß√£o do movimento da pe√ßa
                                sprite[16].move(-dx*w,-dy*w); // Move o sprite do espa√ßo vazio na dire√ß√£o oposta
                                float speed=3; // Velocidade da anima√ß√£o

                                for (int i=0; i<w; i+=speed) { // Loop para animar o movimento
                                    sprite[n].move(speed*dx,speed*dy);
                                    app.draw(sprite[16]);
                                    app.draw(sprite[n]);
                                    app.display();
                                }
                            }
                        }
                    }
                }
            }
        }

        // 8. L√≥gica de Renderiza√ß√£o (Desenho na Tela)
        app.clear(Color::White); // Limpa a tela com a cor branca

        if (gameState == MENU) {
            app.draw(playText); // Desenha o texto "Play"
            app.draw(exitText); // Desenha o texto "Exit"
        } else if (gameState == GAME) {
            // Desenha as pe√ßas do quebra-cabe√ßa
            for (int i=0; i<4; i++) {
                for (int j=0; j<4; j++) {
                    int n = grid[i+1][j+1]; // Obt√©m o valor da pe√ßa na posi√ß√£o
                    sprite[n].setPosition(i*w,j*w); // Define a posi√ß√£o do sprite na tela
                    app.draw(sprite[n]); // Desenha o sprite da pe√ßa
                }
            }
            // Se o jogo estiver resolvido, exibe a mensagem de vit√≥ria e o bot√£o "Back to Menu"
            if (isSolved(grid)) {
                app.draw(winText);
                app.draw(backToMenuText);
            }
            else {
                app.draw(hintText); // Caso contr√°rio, exibe o bot√£o "Hint"
            }

            // Desenha o destaque da dica se houver uma dica ativa e dentro do tempo
            if (hintedTile.x != -1 && hintClock.getElapsedTime().asSeconds() < hintDuration) {
                RectangleShape hintRect(Vector2f(w, w)); // Cria um ret√¢ngulo para o destaque
                hintRect.setFillColor(Color::Transparent); // Fundo transparente
                hintRect.setOutlineThickness(5); // Espessura da borda
                hintRect.setOutlineColor(Color::Yellow); // Cor da borda
                // Define a posi√ß√£o do destaque sobre a pe√ßa sugerida
                hintRect.setPosition((hintedTile.x - 1) * w, (hintedTile.y - 1) * w);
                app.draw(hintRect); // Desenha o destaque
            }
        }

        app.display(); // Exibe o que foi desenhado na tela (troca o buffer)
    }

    return 0; // O programa termina com sucesso
}
```



# Racing Game Top-Down

## Vis√£o Geral: O Que Vamos Construir?

Nosso objetivo √© criar um jogo de corrida onde voc√™ controla um carro em uma pista e compete contra outros quatro carros controlados por uma Intelig√™ncia Artificial (IA) b√°sica.

Recursos Principais:

1. Controle do Jogador: Voc√™ poder√° acelerar, frear e virar seu carro.

2. Oponentes de IA: Outros carros navegar√£o pela pista de forma aut√¥noma.

3. Pista com Checkpoints: A pista n√£o √© apenas uma imagem; ela √© definida por uma s√©rie de pontos de verifica√ß√£o (checkpoints) que os carros devem seguir.

4. C√¢mera Din√¢mica: A c√¢mera seguir√° o seu carro, mantendo a a√ß√£o sempre no centro da tela.

5. Interface de Usu√°rio (UI): Mostraremos informa√ß√µes essenciais como sua velocidade, o checkpoint atual e o n√∫mero de voltas completadas.

## Passo 1: A Estrutura Fundamental de um Jogo

Todo jogo, n√£o importa qu√£o complexo, √© constru√≠do sobre alguns pilares. Vamos come√ßar com eles.

### O Game Loop (La√ßo do Jogo)

O cora√ß√£o de qualquer jogo √© o game loop. √â um la√ßo `while` que continua executando enquanto a janela do jogo estiver aberta. Em cada "tick" ou itera√ß√£o desse la√ßo, o jogo faz tr√™s coisas:

1. Processa Entradas: Verifica se o jogador pressionou alguma tecla, clicou o mouse ou fechou a janela.

2. Atualiza a L√≥gica: Move os personagens, verifica colis√µes, atualiza a pontua√ß√£o, etc.

3. Renderiza a Tela: Desenha tudo na tela na sua nova posi√ß√£o.

No nosso c√≥digo, ele se parece com isto:

```CPP
while (app.isOpen()) {
    // 1. Processar Entradas (Eventos)
    // ...

    // 2. Atualizar a L√≥gica do Jogo
    // ...

    // 3. Renderizar a Tela
    // ...
}
```

### 

Gerenciamento de Estado (`GameState`)

Nosso jogo tem duas telas principais: o Menu Principal e a Corrida em si. N√£o podemos ter a l√≥gica da corrida rodando enquanto estamos no menu. Para gerenciar isso, usamos uma m√°quina de estados. √â mais simples do que parece. Usamos uma `enum` para definir os poss√≠veis estados:

```CPP
enum GameState { MENU, PLAYING };
GameState gameState = MENU; // O jogo sempre come√ßa no estado MENU
```

Dentro do nosso game loop, podemos verificar qual √© o estado atual e executar apenas a l√≥gica relevante:

```CPP
if (gameState == MENU) {
    // L√≥gica e desenho do menu
} else if (gameState == PLAYING) {
    // L√≥gica e desenho da corrida
}
```

## Passo 2: Construindo o Mundo do Jogo

Agora vamos definir os elementos que comp√µem nosso mundo de corrida.

### A Janela e os Recursos Gr√°ficos

Primeiro, criamos a janela do jogo com um tamanho fixo e um t√≠tulo:

```CPP
RenderWindow app(VideoMode(640, 480), "Car Racing Game!");
app.setFramerateLimit(60); // Limita o jogo a 60 quadros por segundo (FPS)
```

Limitar o FPS √© importante para que o jogo n√£o rode r√°pido demais em computadores potentes e para garantir uma experi√™ncia consistente.

Em seguida, carregamos nossos recursos (imagens e fontes) usando as classes `Texture` e `Font` do SFML. Uma `Texture` √© a imagem em si, carregada na mem√≥ria da placa de v√≠deo. Um `Sprite` √© um objeto que pode ser desenhado na tela e que usa uma `Texture`.

```CPP
Texture t1, t2;
t1.loadFromFile("images/background.png");
t2.loadFromFile("images/car.png");

Sprite sBackground(t1), sCar(t2);
```

### 

A Pista de Corrida (`points`)

Como a IA saber√° para onde ir? N√≥s definimos a pista usando uma s√©rie de checkpoints. Pense neles como pontos invis√≠veis que formam o caminho ideal da corrida. Armazenamos esses pontos em um array 2D:

```CPP
const int num = 8; // Temos 8 checkpoints
int points[num][2] = {
    {300, 610},
    {1270, 430},
    // ... e assim por diante
};
```

A IA simplesmente tentar√° ir do checkpoint 0 para o 1, depois para o 2, e assim por diante, em um ciclo. Esta √© uma maneira muito simples e eficaz de criar um comportamento de seguimento de caminho.

### 

A Planta Baixa do Carro (A Estrutura `Car`)

Para representar cada carro no jogo (tanto o jogador quanto a IA), usamos uma `struct`. Uma `struct` √© como uma planta baixa que agrupa v√°rias vari√°veis relacionadas em um √∫nico tipo de dado.

```CPP
struct Car {
    float x, y, speed, angle;
    int n; // √çndice do pr√≥ximo checkpoint alvo
    int lastCheckpoint;

    // Construtor: valores iniciais quando um novo Car √© criado
    Car() {
        speed = 2;
        angle = 0;
        n = 0;
        lastCheckpoint = 0;
    }

    void move();
    void findTarget();
};
```

* `x`, `y`: A posi√ß√£o exata do carro no mundo do jogo (coordenadas de mundo).

* `speed`: A velocidade atual.

* `angle`: O √¢ngulo para o qual o carro est√° virado. Importante: Em programa√ß√£o de jogos e matem√°tica, √¢ngulos s√£o quase sempre medidos em radianos, n√£o em graus.

* `n`: O √≠ndice do pr√≥ximo checkpoint que este carro est√° perseguindo. Para o `car[0]` (jogador), isso nos diz em que parte da pista ele est√°.

* `lastCheckpoint`: O √∫ltimo checkpoint que o carro passou. Isso √© crucial para a nossa l√≥gica de contagem de voltas.

## Passo 3: As Mec√¢nicas do Jogo - Dando Vida aos Carros

Esta √© a parte mais emocionante, onde implementamos a f√≠sica, a IA e os controles.

### Controle e F√≠sica do Jogador

O carro do jogador (`car[0]`) √© especial. Ele n√£o usa a IA. Em vez disso, ele responde diretamente √†s suas teclas.

```CPP
// Detecta quais teclas est√£o pressionadas
bool Up = Keyboard::isKeyPressed(Keyboard::Up);
// ...

// 1. Acelera√ß√£o e Desacelera√ß√£o
if (Up && speed < maxSpeed) {
    if (speed < 0) speed += dec; // Se estava de r√©, freia
    else speed += acc;           // Se estava indo para frente, acelera
}
// ...

// 2. Atrito (Fric√ß√£o)
if (!Up && !Down) {
    if (speed - dec > 0) speed -= dec; // Perde velocidade gradualmente
    else if (speed + dec < 0) speed += dec;
    else speed = 0; // Para completamente
}

// 3. Virar o Carro
if (Right && speed != 0) angle += turnSpeed * speed / maxSpeed;
```

An√°lise detalhada:

* `acc` (acelera√ß√£o) e `dec` (desacelera√ß√£o) s√£o pequenas constantes que controlam qu√£o r√°pido o carro ganha ou perde velocidade. Isso cria uma sensa√ß√£o de in√©rcia.

* A l√≥gica de virar √© interessante: `turnSpeed * speed / maxSpeed`. Isso faz com que o carro vire mais lentamente em baixas velocidades e mais rapidamente em altas velocidades, o que √© o oposto do realismo, mas torna o jogo mais divertido e control√°vel no estilo arcade.

### 

Movimento F√≠sico (`move`)

Uma vez que a velocidade e o √¢ngulo s√£o definidos, a fun√ß√£o `move` atualiza a posi√ß√£o do carro.

```CPP
void move() {
    x += sin(angle) * speed;
    y -= cos(angle) * speed;
}
```

Isto √© trigonometria. `sin(angle)` e `cos(angle)` decomp√µem o movimento diagonal em seus componentes horizontal (X) e vertical (Y).

* Por que `y -= ...`? Em muitos sistemas gr√°ficos, incluindo o do SFML, a coordenada (0,0) fica no canto superior esquerdo. O eixo Y aumenta para baixo. No entanto, matematicamente, o eixo Y aumenta para cima. Subtrair o cosseno corrige essa diferen√ßa, fazendo o carro se mover "para cima" na tela quando o √¢ngulo √© 0.

### 

A Intelig√™ncia Artificial (`findTarget`)

Esta √© a fun√ß√£o que faz os carros oponentes parecerem vivos. O objetivo deles √© simples: virar-se para o pr√≥ximo checkpoint e avan√ßar.

```CPP
void findTarget() {
    // 1. Pega as coordenadas do checkpoint alvo
    float tx = points[n][0];
    float ty = points[n][1];

    // 2. Calcula o √¢ngulo exato do carro at√© o alvo
    float beta = angle - atan2(tx - x, -ty + y);

    // 3. Vira o carro na dire√ß√£o certa
    if (sin(beta) < 0) angle += 0.005 * speed;
    else angle -= 0.005 * speed;

    // 4. Verifica se chegou ao alvo
    if ((x - tx) * (x - tx) + (y - ty) * (y - ty) < 25 * 25) {
        lastCheckpoint = n;
        n = (n + 1) % num; // Passa para o pr√≥ximo checkpoint
    }
}
```

An√°lise detalhada:

* `atan2(delta_x, -delta_y)`: Esta fun√ß√£o √© m√°gica. Ela nos d√° o √¢ngulo exato de um ponto a outro. Usamos `-ty + y` para o componente `y` para corrigir a invers√£o do eixo Y que mencionamos antes.

* `beta`: √â a diferen√ßa entre o √¢ngulo atual do carro e o √¢ngulo que ele deveria ter.

* `if (sin(beta) < 0)`: Este √© um truque inteligente. O sinal do seno de `beta` nos diz se o alvo est√° √† esquerda ou √† direita da dire√ß√£o atual do carro. Se for negativo, viramos em uma dire√ß√£o; se for positivo, na outra. Isso garante que o carro sempre tome o caminho mais curto para se alinhar com o alvo.

* Verifica√ß√£o de Dist√¢ncia: A linha `(x-tx)*(x-tx) + ...` √© a f√≥rmula da dist√¢ncia ao quadrado (`d¬≤ = dx¬≤ + dy¬≤`). Usamos a dist√¢ncia ao quadrado para evitar o c√°lculo da raiz quadrada (`sqrt`), que √© uma opera√ß√£o computacionalmente "cara". Como s√≥ queremos saber se a dist√¢ncia √© menor que um valor, comparar os quadrados funciona perfeitamente e √© mais r√°pido.

* `n = (n + 1) % num;`: O operador m√≥dulo (`%`) √© perfeito para criar ciclos. Quando `n` chega ao √∫ltimo checkpoint, `(n + 1)` se torna `num`, e `num % num` √© `0`. Isso faz a IA voltar ao primeiro checkpoint e continuar o ciclo.

### Sistema de Colis√£o

A colis√£o √© simples: se dois carros est√£o muito pr√≥ximos, n√≥s os empurramos para longe um do outro.

```CPP
// Loop dentro de loop para comparar cada carro com todos os outros
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        // ...
        // Calcula a dist√¢ncia ao quadrado
        while (dx * dx + dy * dy < 4 * R * R) {
            // Empurra os carros um pouco para longe um do outro
            car[i].x += dx / 10.0;
            car[j].x -= dx / 10.0;
            // ... e atualiza a dist√¢ncia para a pr√≥xima verifica√ß√£o do while
        }
    }
}
```

Este m√©todo √© chamado de "resolu√ß√£o por impulso" e √© muito b√°sico. Ele funciona, mas pode fazer os carros tremerem um pouco quando colidem. Para um jogo simples, √© suficiente.

## Passo 4: Renderiza√ß√£o e Interface

Agora que nossa l√≥gica est√° pronta, vamos mostrar tudo na tela.

### A C√¢mera que Segue o Jogador

N√£o movemos a c√¢mera. Em vez disso, movemos o mundo inteiro na dire√ß√£o oposta.

1. Calculamos um "deslocamento" (`offset`) para manter o carro do jogador (`car[0]`) no centro da tela.

```CPP
int offsetX = 0, offsetY = 0;
if (car[0].x > 320) offsetX = car[0].x - 320;
if (car[0].y > 240) offsetY = car[0].y - 240;
```

2. Ao desenhar qualquer objeto do mundo (o fundo, os carros), subtra√≠mos esse offset de sua posi√ß√£o.

```CPP
sBackground.setPosition(-offsetX, -offsetY);
sCar.setPosition(car[i].x - offsetX, car[i].y - offsetY);
```

O resultado √© que o jogador parece ficar parado no centro enquanto o mundo se move ao seu redor.

### A Interface do Usu√°rio (UI)

A UI (texto de velocidade, voltas, etc.) √© desenhada por √∫ltimo e sem o deslocamento da c√¢mera. Isso garante que ela permane√ßa fixa na tela, como um painel de controle.

```CPP
// Converte a velocidade (float) para uma string
std::string speedStr = "Speed: " + std::to_string(static_cast<int>(car[0].speed * 10));
speedText.setString(speedStr);
app.draw(speedText); // Desenhado em coordenadas de tela fixas
```

### L√≥gica de Contagem de Voltas

Esta √© uma das partes mais importantes da l√≥gica de um jogo de corrida.

```CPP
if (car[0].n == 0 && car[0].lastCheckpoint == num - 1) {
    laps++;
    car[0].lastCheckpoint = 0; // Reseta para a pr√≥xima volta
}
```

Vamos traduzir esta condi√ß√£o:

* `car[0].n == 0`: O pr√≥ximo alvo do meu carro √© o checkpoint inicial (o n√∫mero 0).

* `car[0].lastCheckpoint == num - 1`: O √∫ltimo checkpoint que eu passei foi o √∫ltimo da pista.

Quando ambas as condi√ß√µes s√£o verdadeiras, significa que o jogador acabou de cruzar a linha de chegada, completando uma volta. Ent√£o, incrementamos `laps` e resetamos `lastCheckpoint` para evitar contar a mesma volta v√°rias vezes.

## Conclus√£o: O Que Voc√™ Aprendeu?

Parab√©ns! Se voc√™ seguiu at√© aqui, voc√™ dissecou um jogo completo. Vamos revisar os conceitos-chave:

* Game Loop: A estrutura fundamental de `Entrada -> L√≥gica -> Renderiza√ß√£o`.

* M√°quinas de Estado: Como organizar seu jogo em se√ß√µes l√≥gicas (`Menu`, `Playing`).

* Trigonometria para Movimento: Como usar `sin` e `cos` para um movimento suave em 2D.

* IA Simples: Como fazer um objeto seguir uma s√©rie de pontos de forma aut√¥noma usando `atan2`.

* Otimiza√ß√£o: Como evitar c√°lculos caros (como `sqrt`) usando a dist√¢ncia ao quadrado.

* C√¢mera 2D: A t√©cnica de mover o mundo para simular uma c√¢mera que segue o jogador.

* L√≥gica de Jogo Espec√≠fica: Como implementar um sistema de contagem de voltas preciso.

Espero que este guia detalhado tenha sido √∫til. A melhor maneira de aprender √© experimentar. Tente mudar os valores de acelera√ß√£o, a velocidade de curva, ou adicione mais checkpoints √† pista. Divirta-se programando!



# Outrun

Este tutorial detalha a implementa√ß√£o do jogo "Outrun", um simulador de corrida com perspectiva 3D, desenvolvido em C++ e SFML. Abordaremos os conceitos fundamentais por tr√°s da cria√ß√£o de uma estrada infinita e da proje√ß√£o de objetos para simular um ambiente tridimensional.

## O que √© Outrun

"Outrun" √© um jogo de corrida cl√°ssico onde o jogador controla um carro em uma estrada que se estende ao horizonte, criando uma ilus√£o de profundidade e movimento. O objetivo √© dirigir pela estrada, desviando de obst√°culos e outros ve√≠culos, enquanto a paisagem se move para simular velocidade.

As principais caracter√≠sticas que exploraremos s√£o:

* Perspectiva 3D: Como a estrada e os objetos s√£o renderizados para simular uma vis√£o em tr√™s dimens√µes.

* Gera√ß√£o de Estrada: A cria√ß√£o de uma estrada "infinita" com curvas e eleva√ß√µes.

* Controle de Ve√≠culo: A movimenta√ß√£o do carro do jogador e o controle de velocidade.

* Objetos na Estrada: A inclus√£o de elementos como √°rvores e carros oponentes.

## A Base do Jogo: Segmentos da Estrada e Proje√ß√£o 3D

O cora√ß√£o do "Outrun" √© a forma como ele simula um ambiente 3D usando segmentos de estrada e proje√ß√£o. Em vez de um modelo 3D complexo, o jogo desenha a estrada como uma s√©rie de quadril√°teros, cada um representando um pequeno segmento da pista.

### 

A Estrutura `Line`

Cada segmento da estrada √© representado por uma inst√¢ncia da estrutura `Line`. Esta estrutura armazena as coordenadas 3D do centro do segmento (`x`, `y`, `z`), bem como suas propriedades na tela ap√≥s a proje√ß√£o (`X`, `Y`, `W`).

```CPP
struct Line {
	float x,y,z; // 3d center of line
	float X,Y,W; // screen coord
	float curve,spriteX,clip,scale;
	Sprite sprite;

	Line() {
		spriteX=curve=x=y=z=0;
	}

	void project(int camX,int camY,int camZ) {
		scale = camD/(z-camZ);
		X = (1 + scale*(x - camX)) * width/2;
		Y = (1 - scale*(y - camY)) * height/2;
		W = scale * roadW  * width/2;
	}

	void drawSprite(RenderWindow &app) {
		Sprite s = sprite;
		int w = s.getTextureRect().width;
		int h = s.getTextureRect().height;

		float destX = X + scale * spriteX * width/2;
		float destY = Y + 4;
		float destW  = w * W / 266;
		float destH  = h * W / 266;

		destX += destW * spriteX; // offsetX
		destY += destH * (-1);    // offsetY

		float clipH = destY+destH-clip;
		if (clipH<0) clipH=0;

		if (clipH>=destH) return;
		s.setTextureRect(IntRect(0,0,w,h-h*clipH/destH));
		s.setScale(destW/w,destH/h);
		s.setPosition(destX, destY);
		app.draw(s);
	}
};
```

* `x, y, z`: Coordenadas 3D do centro do segmento. `z` √© a profundidade, `y` a eleva√ß√£o e `x` a posi√ß√£o horizontal.

* `X, Y, W`: Coordenadas na tela ap√≥s a proje√ß√£o. `X` √© a posi√ß√£o horizontal, `Y` a vertical e `W` a largura do segmento na tela.

* `curve`: Determina a curvatura do segmento da estrada. Um valor positivo curva para a direita, negativo para a esquerda.

* `spriteX`: Posi√ß√£o horizontal de um sprite associado a este segmento (por exemplo, uma √°rvore ou um carro oponente).

* `project(camX, camY, camZ)`: Este m√©todo √© a chave para a proje√ß√£o 3D. Ele calcula as coordenadas `X`, `Y` e `W` na tela com base na posi√ß√£o da c√¢mera (`camX`, `camY`, `camZ`) e na profundidade (`z`) do segmento. Quanto maior `z` (mais distante), menor o `scale` e, consequentemente, menor o segmento na tela, criando a ilus√£o de profundidade.

* `drawSprite(RenderWindow &app)`: Desenha um sprite associado a este segmento na posi√ß√£o correta na tela, levando em conta a perspectiva.

### 

Desenhando a Estrada: `drawQuad`

A fun√ß√£o `drawQuad` √© respons√°vel por desenhar os quadril√°teros que comp√µem a estrada. Ela recebe as coordenadas de dois pontos (superior e inferior) e suas respectivas larguras, e desenha um `ConvexShape` (um quadril√°tero) entre eles.

```CPP
void drawQuad(RenderWindow &w, Color c, int x1,int y1,int w1,int x2,int y2,int w2) {
	ConvexShape shape(4);
	shape.setFillColor(c);
	shape.setPoint(0, Vector2f(x1-w1,y1));
	shape.setPoint(1, Vector2f(x2-w2,y2));
	shape.setPoint(2, Vector2f(x2+w2,y2));
	shape.setPoint(3, Vector2f(x1+w1,y1));
	w.draw(shape);
}
```

No loop principal do jogo, esta fun√ß√£o √© chamada repetidamente para desenhar a grama, o acostamento e a pista, com cores diferentes para cada parte.

## O Loop Principal do Jogo

O `main` function cont√©m o loop principal do jogo, onde a l√≥gica √© atualizada e a tela √© redesenhada a cada frame.

```CPP
int main() {
	RenderWindow app(VideoMode(width, height), "Outrun Racing!");
	app.setFramerateLimit(60);

	// Carregamento de Texturas e Sprites
	Texture t[50];
	Sprite object[50];
	for(int i=1; i<=7; i++) {
		t[i].loadFromFile("images/" + std::to_string(i) + ".png");
		t[i].setSmooth(true);
		object[i].setTexture(t[i]);
	}

	Texture bg;
	bg.loadFromFile("images/bg.png");
	bg.setRepeated(true);
	Sprite sBackground(bg);
	sBackground.setTextureRect(IntRect(0,0,5000,411));
	sBackground.setPosition(-2000,0);

	// Gera√ß√£o da Estrada (linhas)
	std::vector<Line> lines;

	for(int i=0; i<1600; i++) {
		Line line;
		line.z = i*segL;

		if (i>300 && i<700) line.curve=0.5;
		if (i>1100) line.curve=-0.7;

		// Adi√ß√£o de Sprites (√°rvores, carros oponentes, etc.)
		if (i<300 && i%20==0) {
			line.spriteX=-2.5;
			line.sprite=object[5];
		}
		if (i%17==0)          {
			line.spriteX=2.0;
			line.sprite=object[6];
		}
		if (i>300 && i%20==0) {
			line.spriteX=-0.7;
			line.sprite=object[4];
		}
		if (i>800 && i%20==0) {
			line.spriteX=-1.2;
			line.sprite=object[1];
		}
		if (i==400)           {
			line.spriteX=-1.2;
			line.sprite=object[7];
		}
		// Carros oponentes adicionados
		if (i>100 && i%100==0) {
			line.spriteX=0.5;
			line.sprite=object[1];
		}
		if (i>200 && i%150==0) {
			line.spriteX=-0.5;
			line.sprite=object[1];
		}

		if (i>750) line.y = sin(i/30.0)*1500; // Eleva√ß√£o da estrada

		lines.push_back(line);
	}

	int N = static_cast<int>(lines.size());
	float playerX = 0;
	int pos = 0;
	int H = 1500; // Altura da c√¢mera

	while (app.isOpen()) {
		Event e;
		while (app.pollEvent(e)) {
			if (e.type == Event::Closed)
				app.close();
		}

		int speed=0;

		// Input do Jogador
		if (Keyboard::isKeyPressed(Keyboard::Right)) playerX+=0.1;
		if (Keyboard::isKeyPressed(Keyboard::Left)) playerX-=0.1;
		if (Keyboard::isKeyPressed(Keyboard::Up)) speed=200;
		if (Keyboard::isKeyPressed(Keyboard::Down)) speed=-200;
		if (Keyboard::isKeyPressed(Keyboard::Tab)) speed*=3;

		// Atualiza√ß√£o da Posi√ß√£o na Estrada
		pos+=speed;
		while (pos >= N*segL) pos-=N*segL;
		while (pos < 0) pos += N*segL;

		app.clear(Color(105,205,4));
		app.draw(sBackground);

		int startPos = pos/segL;
		int camH = lines[startPos].y + H; // Altura da c√¢mera ajustada pela eleva√ß√£o da estrada
		if (speed>0) sBackground.move(-lines[startPos].curve*2,0);
		if (speed<0) sBackground.move( lines[startPos].curve*2,0);

		int maxy = height;
		float x=0,dx=0;

		/////// Desenho da Estrada ////////
		for(int n = startPos; n < startPos+300; n++) {
			Line &l = lines[n%N];
			l.project(playerX*roadW - x, camH, pos - (n >= N ? N*segL : 0));
			x+=dx;
			dx+=l.curve;

			l.clip=maxy;
			if (l.Y>=maxy) continue;
			maxy = l.Y;

			Color grass  = (n/3)%2?Color(16,200,16):Color(0,154,0);
			Color rumble = (n/3)%2?Color(255,255,255):Color(0,0,0);
			Color road   = (n/3)%2?Color(107,107,107):Color(105,105,105);

			Line p = lines[(n-1+N)%N]; // previous line

			drawQuad(app, grass, 0, p.Y, width, 0, l.Y, width);
			drawQuad(app, rumble,p.X, p.Y, p.W*1.2, l.X, l.Y, l.W*1.2);
			drawQuad(app, road,  p.X, p.Y, p.W, l.X, l.Y, l.W);
		}

		//////// Desenho de Objetos ////////
		for(int n=startPos+300; n>startPos; n--)
			lines[n%N].drawSprite(app);

		app.display();
	}

	return 0;
}
```

### Gera√ß√£o da Estrada

A estrada √© gerada como um vetor de objetos `Line`. Cada `Line` tem uma posi√ß√£o `z` (profundidade) e pode ter uma `curve` (curvatura) e `y` (eleva√ß√£o) para criar um percurso variado. Sprites (√°rvores, carros oponentes) s√£o adicionados a segmentos espec√≠ficos da estrada.

### Input do Jogador

O jogo responde √†s teclas de seta para controlar a posi√ß√£o horizontal do jogador (`playerX`) e a velocidade (`speed`). A tecla `Tab` atua como um "boost" de velocidade.

### Atualiza√ß√£o da Posi√ß√£o

A vari√°vel `pos` representa a posi√ß√£o atual do jogador na estrada. Ela √© incrementada pela `speed` a cada frame. O uso do operador `%` (`pos % (N*segL)`) garante que a estrada seja "infinita", reciclando os segmentos quando o jogador atinge o final.

### Desenho da Estrada e Objetos

O loop de desenho itera sobre os segmentos da estrada vis√≠veis. Para cada segmento, ele:

1. Projeta o segmento para as coordenadas da tela usando `l.project()`.

2. Calcula a curvatura acumulada (`x` e `dx`) para simular a perspectiva da estrada.

3. Desenha a grama, o acostamento e a pista usando `drawQuad`, com cores alternadas para criar um efeito de faixas.

4. Desenha os sprites associados a cada segmento (√°rvores, carros oponentes) usando `lines[n%N].drawSprite(app)`.

O desenho dos objetos √© feito em ordem inversa (`n=startPos+300; n>startPos; n--`) para garantir que os objetos mais distantes sejam desenhados primeiro, e os mais pr√≥ximos por cima, mantendo a ordem de profundidade correta.

## Carros Oponentes

Os carros oponentes s√£o implementados como sprites associados a segmentos espec√≠ficos da estrada. Eles s√£o adicionados durante a fase de gera√ß√£o da estrada:

```CPP
// Carros oponentes adicionados
if (i>100 && i%100==0) { // Adiciona um carro a cada 100 segmentos ap√≥s os primeiros 100
	line.spriteX=0.5; // Posi√ß√£o horizontal do carro
	line.sprite=object[1]; // Sprite do carro (placeholder)
}
if (i>200 && i%150==0) { // Adiciona outro carro a cada 150 segmentos ap√≥s os primeiros 200
	line.spriteX=-0.5; // Posi√ß√£o horizontal do carro
	line.sprite=object[1]; // Sprite do carro (placeholder)
}
```

Atualmente, eles usam `object[1]` como um sprite placeholder e s√£o posicionados em diferentes faixas da estrada usando `spriteX`.

## Extens√µes Poss√≠veis

Este jogo serve como uma excelente base para futuras extens√µes:

* Detec√ß√£o de Colis√£o: Implementar a l√≥gica para detectar quando o carro do jogador colide com os carros oponentes ou outros objetos na estrada.

* Sistema de Pontua√ß√£o: Adicionar um sistema de pontua√ß√£o baseado na dist√¢ncia percorrida, velocidade ou desvio de obst√°culos.

* Tipos de Oponentes Variados: Introduzir diferentes tipos de carros oponentes com comportamentos distintos.

* M√∫ltiplas Pistas/Cen√°rios: Criar diferentes ambientes e layouts de estrada para aumentar a variedade.

* Efeitos Sonoros: Adicionar sons para o motor, colis√µes e m√∫sica de fundo.

* Interface de Usu√°rio: Exibir informa√ß√µes como velocidade, pontua√ß√£o e dist√¢ncia percorrida.

Este tutorial cobriu os aspectos fundamentais da implementa√ß√£o do jogo "Outrun", desde a proje√ß√£o 3D da estrada at√© a inclus√£o de objetos e o controle do jogador. Com esta base, √© poss√≠vel expandir o jogo com diversas funcionalidades para torn√°-lo mais rico e interativo.



# Xonix

Este tutorial detalha a implementa√ß√£o do cl√°ssico jogo Xonix, uma fascinante mistura de a√ß√£o e estrat√©gia. Vamos explorar passo a passo como o jogo √© constru√≠do, desde a estrutura b√°sica at√© o algoritmo inteligente de captura de territ√≥rio, tornando-o um guia √∫til tanto para iniciantes quanto para desenvolvedores que buscam entender l√≥gicas de jogos mais complexas.

## O que √© Xonix?

Imagine um campo aberto (o "mar") com inimigos se movendo livremente. Voc√™ controla um cursor que come√ßa na borda segura (a "terra"). Seu objetivo √© se aventurar no mar para desenhar linhas e capturar novas por√ß√µes de terra.

* Captura de Territ√≥rio: Voc√™ desenha uma trilha na √°rea vazia. Ao retornar para a terra firme, a √°rea que voc√™ cercou (e que n√£o cont√©m inimigos) √© preenchida, tornando-se sua.

* Inimigos: V√°rios inimigos se movem pelo mar. Se eles tocarem sua trilha enquanto voc√™ a desenha, voc√™ perde.

* Risco e Recompensa: Quanto maior a √°rea que voc√™ tenta capturar de uma vez, maior o risco, mas tamb√©m maior a recompensa.

Este jogo ensina conceitos cruciais como manipula√ß√£o de grades (arrays 2D), algoritmos de preenchimento (flood fill) e gerenciamento de estados.

## Como Organizar o Jogo

### M√°quina de Estados do Jogo

Para gerenciar as diferentes telas e modos de jogo (menu, jogando, pausado, fim de jogo), usamos uma m√°quina de estados finitos. Isso nos ajuda a separar a l√≥gica e manter o c√≥digo organizado.

```CPP
enum GameState {
    MainMenu,
    Playing,
    Paused,
    GameOver
};

GameState gameState = MainMenu; // O jogo sempre come√ßa no menu
```

O fluxo entre os estados √© controlado pelas a√ß√µes do jogador:

```MERMAID
graph LR
    A[MainMenu] -->|Clique em Jogar| B(Playing)
    B -->|Pressiona 'P'| C{Paused}
    C -->|Pressiona 'P'| B
    B -->|Inimigo toca trilha| D[GameOver]
    B -->|Jogador toca trilha| D
    D -->|Clique em Jogar Novamente| B
```

### 

A Estrutura de Dados Central: A Grade (`grid`)

O cora√ß√£o do Xonix √© uma matriz 2D que representa o campo de jogo. Cada c√©lula da grade pode ter um de quatro valores, cada um com um significado especial:

* `grid[y][x] = 0`: Representa o "mar" ‚Äì a √°rea vazia e perigosa onde os inimigos se movem.

* `grid[y][x] = 1`: Representa a "terra" ‚Äì a √°rea segura e j√° capturada. As bordas come√ßam como terra.

* `grid[y][x] = 2`: A trilha do jogador. Esta √© a parte vulner√°vel que est√° sendo desenhada no mar.

* `grid[y][x] = -1`: Um valor tempor√°rio usado exclusivamente pelo algoritmo de captura de territ√≥rio.

```CPP
const int M = 25; // Altura da grade
const int N = 40; // Largura da grade
int grid[M][N] = {0}; // Inicializa tudo como 0 (mar)
```

## As Principais Mec√¢nicas do Jogo

### Movimento do Jogador e dos Inimigos

* Jogador: Controlado pelas setas do teclado. Ao se mover a partir da terra (`1`) para o mar (`0`), ele deixa uma trilha de `2`s.

* Inimigos: Cada inimigo (`Enemy`) tem uma posi√ß√£o e velocidade. Eles se movem em linha reta e ricocheteiam nas paredes (`grid == 1`), criando um movimento ca√≥tico e imprevis√≠vel.

```CPP
struct Enemy {
    int x, y, dx, dy; // Posi√ß√£o e velocidade

    void move() {
        x += dx;
        if (grid[y / ts][x / ts] == 1) { // Se bater na terra
            dx = -dx; // Inverte a dire√ß√£o horizontal
            x += dx;
        }
        y += dy;
        if (grid[y / ts][x / ts] == 1) { // Se bater na terra
            dy = -dy; // Inverte a dire√ß√£o vertical
            y += dy;
        }
    }
};
```

### Condi√ß√µes de Fim de Jogo

O jogo termina (estado `GameOver`) em duas situa√ß√µes:

1. Inimigo Colide com a Trilha: Se um inimigo tocar uma c√©lula com valor `2`.

2. Jogador Colide com a Pr√≥pria Trilha: Se o jogador, ao se mover, entrar em uma c√©lula que j√° faz parte de sua trilha atual (valor `2`).

```CPP
// No loop de atualiza√ß√£o do jogador
if (grid[y][x] == 2) gameState = GameOver;

// No loop de verifica√ß√£o de inimigos
for (int i = 0; i < enemyCount; i++)
    if (grid[a[i].y / ts][a[i].x / ts] == 2) gameState = GameOver;
```

### O Algoritmo de Captura de Territ√≥rio (Flood Fill)

Esta √© a parte mais engenhosa do jogo. Quando o jogador retorna √† terra firme (`grid == 1`), o jogo precisa decidir qual √°rea ser√° preenchida.

O processo ocorre em duas fases:

Fase 1: Marcar as √°reas dos inimigos

O jogo usa um algoritmo de flood fill (preenchimento de √°rea) para descobrir quais partes do "mar" s√£o alcan√ß√°veis pelos inimigos.

1. A fun√ß√£o `drop(y, x)` √© chamada para a posi√ß√£o de cada inimigo.

2. Esta fun√ß√£o √© recursiva: se uma c√©lula √© mar (`0`), ela a marca como tempor√°ria (`-1`) e chama a si mesma para todos os vizinhos que tamb√©m s√£o mar.

3. Ao final, todas as c√©lulas do mar que um inimigo pode alcan√ßar estar√£o marcadas com `-1`.

```CPP
void drop(int y, int x) {
    if (grid[y][x] == 0) grid[y][x] = -1; // Marca a c√©lula
    // Chama recursivamente para os vizinhos
    if (y > 0 && grid[y - 1][x] == 0) drop(y - 1, x);
    if (y < M - 1 && grid[y + 1][x] == 0) drop(y + 1, x);
    if (x > 0 && grid[y][x - 1] == 0) drop(y, x - 1);
    if (x < N - 1 && grid[y][x + 1] == 0) drop(y, x + 1);
}
```

Fase 2: Preencher a √°rea capturada

Ap√≥s marcar as √°reas dos inimigos, o jogo percorre toda a grade para tomar a decis√£o final:

```CPP
// Este loop √© executado ap√≥s a chamada de drop() para todos os inimigos
for (int i = 0; i < M; i++)
    for (int j = 0; j < N; j++)
        if (grid[i][j] == -1) grid[i][j] = 0; // Se foi alcan√ßada por um inimigo, volta a ser mar
        else grid[i][j] = 1; // Caso contr√°rio, torna-se terra firme!
```

Qualquer c√©lula que n√£o foi marcada com `-1` (ou seja, a trilha do jogador e qualquer por√ß√£o do mar que ficou isolada dos inimigos) √© convertida em terra (`1`).

```MERMAID
graph TD
    A[Jogador retorna √† terra] --> B{Iniciar Captura}
    B --> C[Para cada inimigo, chamar drop, inimigo.y, inimigo.x]
    C --> D{Flood Fill marca √°reas alcan√ß√°veis com -1}
    D --> E[Percorrer toda a grade]
    E --> F{C√©lula == -1?}
    F -- "Sim" --> G[Transformar em Mar - 0]
    F -- "N√£o" --> H[Transformar em Terra - 1]
    G --> E
    H --> E
    E --> I[Territ√≥rio Capturado]
```

## 

Estrutura do C√≥digo no `main.cpp`

O loop principal do jogo √© organizado em torno da m√°quina de estados.

```CPP
int main() {
    // ... Inicializa√ß√£o de janela, texturas, fontes, etc. ...
    GameState gameState = MainMenu;

    while (window.isOpen()) {
        // ... Processamento de eventos (input do jogador) ...
        // A l√≥gica de input muda com base no gameState (menu, jogo, etc.)

        // L√≥gica de atualiza√ß√£o do jogo
        if (gameState == Playing) {
            // Mover jogador
            // Mover inimigos
            // Verificar colis√µes
            // Verificar se o jogador capturou uma √°rea
        }

        // L√≥gica de renderiza√ß√£o
        window.clear();
        if (gameState == MainMenu) {
            // Desenhar menu
        } else {
            // Desenhar a grade (terra, mar, trilha)
            // Desenhar jogador
            // Desenhar inimigos
            if (gameState == Paused) {
                // Desenhar texto "Pausado"
            }
            if (gameState == GameOver) {
                // Desenhar tela de "Game Over" e menu
            }
        }
        window.display();
    }
    return 0;
}
```

## Conceitos Importantes Aprendidos

* Manipula√ß√£o de Grid 2D: Como usar uma matriz para representar um mundo de jogo complexo com diferentes tipos de terreno.

* Algoritmo de Flood Fill: Uma aplica√ß√£o pr√°tica e poderosa de recurs√£o para an√°lise de √°reas conectadas. √â um algoritmo fundamental em muitos jogos e aplica√ß√µes gr√°ficas.

* M√°quina de Estados Finitos: Um padr√£o de design essencial para organizar o fluxo de um jogo, tornando o c√≥digo mais limpo e f√°cil de gerenciar.

* L√≥gica de Risco vs. Recompensa: O design do jogo incentiva o jogador a tomar decis√µes estrat√©gicas, equilibrando o perigo de criar uma trilha longa com a vantagem de capturar mais territ√≥rio.

## Extens√µes Poss√≠veis

O c√≥digo atual √© uma base excelente para adicionar novas funcionalidades:

* Sistema de Pontua√ß√£o: Adicionar pontos com base no tamanho da √°rea capturada.

* N√≠veis e Dificuldade: Aumentar o n√∫mero ou a velocidade dos inimigos a cada n√≠vel.

* Vidas: Permitir que o jogador perca mais de uma vez antes do "Game Over".

* Power-ups: Itens que podem congelar os inimigos ou aumentar a velocidade do jogador temporariamente.



# Bejeweled

Este tutorial explora a fundo a cria√ß√£o do jogo Bejeweled, um cl√°ssico "match-3", utilizando C++ e SFML. Abordaremos desde os conceitos fundamentais do design de jogos at√© a implementa√ß√£o de mec√¢nicas complexas e a integra√ß√£o com um sistema de pontua√ß√£o persistente usando SQLite.

## O que √© Bejeweled?

Bejeweled √© um jogo de quebra-cabe√ßa onde o objetivo √© combinar tr√™s ou mais gemas da mesma cor, seja na horizontal ou na vertical. Ao fazer uma combina√ß√£o, as gemas desaparecem, novas gemas caem para preencher os espa√ßos vazios, e o jogador ganha pontos. O jogo continua at√© que o tempo se esgote ou n√£o haja mais movimentos poss√≠veis.

### Conceitos Fundamentais:

* Grade de Jogo: Um tabuleiro 8x8 (ou similar) preenchido com gemas.

* Gemas: Pe√ßas coloridas que o jogador manipula.

* Combina√ß√µes (Matches): Tr√™s ou mais gemas id√™nticas alinhadas.

* Troca (Swap): O jogador troca a posi√ß√£o de duas gemas adjacentes.

* Queda (Gravity): Gemas acima de espa√ßos vazios caem para preench√™-los.

* Preenchimento (Refill): Novas gemas aparecem no topo para completar a grade.

## O Ciclo de Jogo (Game Loop)

Todo jogo √© constru√≠do em torno de um ciclo de execu√ß√£o cont√≠nuo, conhecido como "Game Loop". Este ciclo √© respons√°vel por processar as entradas do jogador, atualizar o estado do jogo e renderizar os gr√°ficos na tela. No Bejeweled, este ciclo √© fundamental para a fluidez das anima√ß√µes e a resposta √†s intera√ß√µes.

```MERMAID
graph TD
    A[In√≠cio do Jogo] --> B{Loop Principal do Jogo};
    B --> C[Processar Eventos (Input do Jogador)];
    C --> D[Atualizar L√≥gica do Jogo (Mec√¢nicas, Tempo, Estados)];
    D --> E[Renderizar Gr√°ficos (Desenhar na Tela)];
    E --> B;
    B -- Fim do Jogo --> F[Encerrar Aplica√ß√£o];
```

## A Concep√ß√£o do Jogo: "Think Hard"

Para construir um jogo como Bejeweled, precisamos pensar em cada etapa, desde a representa√ß√£o dos dados at√© a l√≥gica de anima√ß√£o e persist√™ncia.

### 1. Representa√ß√£o da Grade e das Gemas

Como vamos armazenar as gemas na grade? Uma matriz 2D √© a escolha natural. Cada elemento da matriz representar√° uma c√©lula da grade, e seu valor indicar√° o tipo (cor) da gema.

```CPP
// Estrutura para representar cada pe√ßa (gema) na grade
struct piece
{
  int x, y, col, row, kind, match, alpha, special;
  piece(){match=0; alpha=255; special=0;}
} grid[10][10]; // Usamos 10x10 para facilitar bordas e c√°lculos
```

A escolha de uma matriz `grid[10][10]` para um tabuleiro de 8x8 n√£o √© arbitr√°ria. As linhas e colunas extras (√≠ndices 0 e 9) servem como "bordas sentinela" ou "padding". Isso simplifica significativamente a l√≥gica de verifica√ß√£o de vizinhos e limites, evitando a necessidade de m√∫ltiplas verifica√ß√µes `if` para os cantos e bordas do tabuleiro real (√≠ndices 1 a 8).

Cada campo da `struct piece` tem um prop√≥sito crucial:

* `x`, `y`: Coordenadas em pixels na tela. Estas s√£o as posi√ß√µes visuais da gema. Elas s√£o atualizadas durante as anima√ß√µes de queda e troca.

* `col`, `row`: Coordenadas l√≥gicas da gema na matriz `grid`. `col` refere-se √† coluna e `row` √† linha. Estas s√£o as posi√ß√µes "reais" da gema no tabuleiro l√≥gico do jogo.

* `kind`: O tipo da gema, geralmente representando sua cor ou design. Um valor inteiro (0-6) √© eficiente para mapear a texturas ou cores.

* `match`: Uma flag booleana (0 ou 1) que indica se esta gema faz parte de uma combina√ß√£o detectada. Gemas marcadas com `match = 1` ser√£o removidas.

* `alpha`: O canal alfa (transpar√™ncia) da gema. Usado para criar efeitos de desaparecimento suaves. Um valor de 255 significa totalmente opaco, 0 significa totalmente transparente.

* `special`: Uma flag para indicar se a gema √© um tipo especial (ex: uma bomba que explode gemas adjacentes, uma gema que limpa uma linha/coluna). Isso permite a cria√ß√£o de mec√¢nicas mais avan√ßadas.

### 2. Mec√¢nicas Principais

As mec√¢nicas de um jogo "match-3" operam em um ciclo cont√≠nuo: jogador interage -> jogo processa -> jogo reage -> jogo se prepara para pr√≥xima intera√ß√£o.

#### a) Troca de Gemas (Swap)

A troca √© a intera√ß√£o fundamental do jogador. Quando duas gemas s√£o clicadas, suas posi√ß√µes na grade s√£o trocadas.

```CPP
void swap(piece p1,piece p2)
{
  std::swap(p1.col,p2.col);
  std::swap(p1.row,p2.row);

  grid[p1.row][p1.col]=p1;
  grid[p2.row][p2.col]=p2;
}
```

An√°lise Detalhada da Troca:

1. Identifica√ß√£o da Troca: O jogador clica em uma gema (`click=1`), e depois em uma segunda gema adjacente (`click=2`). As coordenadas dessas gemas s√£o capturadas.

2. Valida√ß√£o da Adjac√™ncia: Antes de qualquer troca, o jogo verifica se as duas gemas selecionadas s√£o adjacentes (horizontal ou verticalmente). Se n√£o forem, a segunda gema clicada se torna a primeira, e o processo recome√ßa (`click=1`).

3. Troca L√≥gica: A fun√ß√£o `swap` √© chamada. √â importante notar que a fun√ß√£o `std::swap` dentro de `swap(piece p1, piece p2)` est√° trocando os valores das c√≥pias `p1` e `p2`, n√£o as gemas diretamente na `grid`. O c√≥digo fornecido √© uma simplifica√ß√£o. Na implementa√ß√£o real, voc√™ precisaria trocar os elementos da matriz `grid` diretamente, ou passar `p1` e `p2` por refer√™ncia, ou, mais comumente, trocar os `kind` (tipo/cor) das gemas nas posi√ß√µes `(y0, x0)` e `(y, x)` e ent√£o atualizar suas coordenadas `col` e `row` para refletir a nova posi√ß√£o.

```CPP
// Exemplo de como a troca real deveria ser implementada no contexto do jogo
// Assumindo que (y0, x0) e (y, x) s√£o as coordenadas das gemas clicadas
piece temp = grid[y0][x0];
grid[y0][x0] = grid[y][x];
grid[y][x] = temp;

// Atualizar as propriedades col/row das pe√ßas que foram movidas
grid[y0][x0].col = x0; grid[y0][x0].row = y0;
grid[y][x].col = x; grid[y][x].row = y;
```

4. Verifica√ß√£o P√≥s-Troca: Ap√≥s a troca l√≥gica, o jogo imediatamente verifica se essa troca resultou em qualquer combina√ß√£o.

5. Desfazer a Troca (se necess√°rio): Se a troca n√£o gerar nenhuma combina√ß√£o v√°lida, ela deve ser desfeita. Isso √© crucial para a jogabilidade do Bejeweled, onde apenas trocas que resultam em matches s√£o permitidas. O estado `isSwap` e a verifica√ß√£o `!hasMatches` no loop principal s√£o usados para isso: `if (isSwap && !isMoving) { if (!hasMatches) swap(grid[y0][x0],grid[y][x]); else score += currentMatchScore * 10; isSwap=0; }`.

Fluxo da Troca de Gemas (Tentar e Desfazer):

```MERMAID
graph TD
    A[Jogador Clica Gema 1] --> B[Jogador Clica Gema 2 Adjacente];
    B --> C{Trocar Gemas Logicamente};
    C --> D[Detectar Combina√ß√µes];
    D{Combina√ß√µes Encontradas?};
    D -- Sim --> E[Manter Troca];
    D -- N√£o --> F[Desfazer Troca Logicamente];
    E --> G[Continuar Ciclo do Jogo];
    F --> G;
```

#### b) Detec√ß√£o de Combina√ß√µes (Match Finding)

Ap√≥s cada troca, o jogo deve varrer a grade para encontrar combina√ß√µes de 3 ou mais gemas.

```CPP
// Simplifica√ß√£o da l√≥gica de detec√ß√£o de combina√ß√µes
bool hasMatches = false;
for(int i=1;i<=8;i++) { // Iterar sobre a grade (ignorar bordas)
    for(int j=1;j<=8;j++) {
        // Verificar combina√ß√µes horizontais
        if (j<=6 && grid[i][j].kind==grid[i][j+1].kind && grid[i][j].kind==grid[i][j+2].kind) {
            for(int k=0;k<3;k++) grid[i][j+k].match = 1; // Marcar como combinada
            hasMatches = true;
        }
        // Verificar combina√ß√µes verticais
        if (i<=6 && grid[i][j].kind==grid[i+1][j].kind && grid[i][j].kind==grid[i+2][j].kind) {
            for(int k=0;k<3;k++) grid[i+k][j].match = 1; // Marcar como combinada
            hasMatches = true;
        }
    }
}
```

An√°lise Detalhada da Detec√ß√£o de Combina√ß√µes:

1. Varredura Exaustiva: O algoritmo percorre cada c√©lula do tabuleiro (ignorando as bordas sentinela, da√≠ `i=1` a `8` e `j=1` a `8`). Para cada c√©lula, ele verifica se h√° uma combina√ß√£o de 3 ou mais gemas id√™nticas come√ßando naquela posi√ß√£o, tanto na horizontal quanto na vertical.

2. Condi√ß√µes de Verifica√ß√£o:

* `j<=6`: Garante que h√° pelo menos duas c√©lulas √† direita para verificar uma combina√ß√£o horizontal de 3.

* `i<=6`: Garante que h√° pelo menos duas c√©lulas abaixo para verificar uma combina√ß√£o vertical de 3.

* `grid[i][j].kind==grid[i][j+1].kind && grid[i][j].kind==grid[i][j+2].kind`: Compara os tipos (cores) das gemas.

3. Marca√ß√£o de Combina√ß√µes: Se uma combina√ß√£o √© encontrada, as gemas envolvidas s√£o marcadas com `grid[...].match = 1`. Esta marca√ß√£o √© crucial para as fases subsequentes de desaparecimento e queda.

4. Complexidade: A complexidade deste algoritmo √© O(NM), onde N √© o n√∫mero de linhas e M √© o n√∫mero de colunas. Para um tabuleiro 8x8, isso √© 88 = 64 verifica√ß√µes por tipo de combina√ß√£o (horizontal/vertical), o que √© extremamente r√°pido.

5. Gemas Especiais (Think Ultra Hard):

* Cria√ß√£o: Se uma combina√ß√£o de 4 gemas √© feita, a gema que foi trocada para formar a combina√ß√£o (ou uma gema central) pode se tornar uma gema especial (ex: `grid[y][x].special = 1`). O c√≥digo j√° tem a flag `special`.

* Ativa√ß√£o: Quando uma gema especial marcada com `match = 1` √© processada, ela pode ativar um efeito secund√°rio. Por exemplo, uma gema "bomba" pode marcar todas as gemas adjacentes (3x3) com `match = 1`, criando uma rea√ß√£o em cadeia. O c√≥digo j√° tem uma l√≥gica de "Bomb activation" que faz isso.

* Rea√ß√µes em Cadeia: A detec√ß√£o de combina√ß√µes e a ativa√ß√£o de gemas especiais podem ser iterativas. Ap√≥s uma rodada de matches e ativa√ß√µes, o jogo pode precisar re-verificar por novas combina√ß√µes criadas pelas explos√µes, at√© que n√£o haja mais matches.

Visualiza√ß√£o da Detec√ß√£o de Combina√ß√µes:
Imagine o tabuleiro. O algoritmo varre cada c√©lula e "olha" para a direita e para baixo para encontrar 3 gemas iguais.

```
[G1] [G1] [G1] [G2] ...  (Horizontal Match)
[G3]
[G3]
[G3]
[G4]
...                      (Vertical Match)
```

#### c) Anima√ß√£o de Desaparecimento e Pontua√ß√£o

Gemas combinadas n√£o desaparecem instantaneamente. Elas diminuem a transpar√™ncia (`alpha`) para criar um efeito visual suave. Durante essa fase, a pontua√ß√£o √© atualizada.

```CPP
// L√≥gica de anima√ß√£o de desaparecimento
if (!isMoving) // Se n√£o houver gemas caindo
    for (int i=1;i<=8;i++)
        for (int j=1;j<=8;j++)
            if (grid[i][j].match) // Se a gema faz parte de uma combina√ß√£o
                if (grid[i][j].alpha>10) {grid[i][j].alpha-=10; isMoving=true;} // Diminuir alpha
```

An√°lise Detalhada da Anima√ß√£o de Desaparecimento:

1. Controle de Fluxo (`isMoving`): A anima√ß√£o de desaparecimento s√≥ ocorre se `!isMoving` for verdadeiro. Isso garante que as gemas n√£o desapare√ßam enquanto outras gemas ainda est√£o caindo ou se movendo.

2. Diminui√ß√£o Gradual do `alpha`: Para cada gema marcada com `match = 1`, seu valor `alpha` √© gradualmente reduzido (ex: `alpha-=10`). Isso cria um efeito de "fade out".

3. Sinaliza√ß√£o de Anima√ß√£o: Se qualquer gema estiver em processo de desaparecimento (`alpha > 10`), a flag `isMoving` √© definida como `true`. Isso impede que outras fases do jogo (como a queda de gemas) comecem antes que a anima√ß√£o atual termine.

4. Pontua√ß√£o: A pontua√ß√£o √© geralmente calculada e adicionada ao `score` quando as gemas s√£o marcadas como `match = 1`, ou quando a anima√ß√£o de desaparecimento est√° completa. O c√≥digo mostra `score += currentMatchScore * 10;` ap√≥s a verifica√ß√£o de matches, o que √© um bom ponto para adicionar a pontua√ß√£o.

#### d) Queda de Gemas (Gravity)

Ap√≥s as gemas combinadas desaparecerem, as gemas acima delas devem cair para preencher os espa√ßos vazios.

```CPP
// Atualiza√ß√£o da grade ap√≥s combina√ß√µes
if (!isMoving) // Se n√£o houver anima√ß√µes de movimento
{
    // Mover gemas para baixo para preencher espa√ßos vazios
    for(int i=8;i>0;i--) // De baixo para cima
        for(int j=1;j<=8;j++) // Da esquerda para a direita
            if (grid[i][j].match) // Se a gema foi combinada (espa√ßo vazio)
                for(int n=i;n>0;n--) // Procurar gema acima
                    if (!grid[n][j].match) {swap(grid[n][j],grid[i][j]); break;}; // Trocar com a gema acima
    // ... (l√≥gica para preencher o topo com novas gemas)
}
```

An√°lise Detalhada da Queda de Gemas:

1. Itera√ß√£o de Baixo para Cima: O loop externo (`for(int i=8;i>0;i--)`) itera as linhas de baixo para cima. Isso √© crucial. Se iter√°ssemos de cima para baixo, uma gema poderia cair em um espa√ßo vazio, mas o espa√ßo vazio abaixo dela n√£o seria preenchido na mesma itera√ß√£o.

2. Identifica√ß√£o de Espa√ßos Vazios: Uma c√©lula √© considerada "vazia" se sua gema foi marcada com `match = 1` (e j√° desapareceu).

3. Busca por Gema Acima: Para cada espa√ßo vazio, o loop interno (`for(int n=i;n>0;n--)`) procura a primeira gema n√£o combinada (`!grid[n][j].match`) diretamente acima na mesma coluna.

4. Troca e Deslocamento: Uma vez encontrada uma gema acima, ela √© trocada com o espa√ßo vazio. Isso efetivamente faz a gema "cair". O `break` √© importante para que apenas a primeira gema acima caia para aquele espa√ßo.

5. Anima√ß√£o de Queda (Think Ultra Hard): A troca l√≥gica (`swap`) apenas atualiza as posi√ß√µes na matriz. Para uma anima√ß√£o suave, as coordenadas `x` e `y` em pixels das gemas precisam ser atualizadas gradualmente ao longo do tempo. A flag `isMoving` seria definida como `true` durante essa anima√ß√£o, e as gemas se moveriam pixel a pixel at√© suas novas posi√ß√µes `(row*ts, col*ts)`.

Visualiza√ß√£o da Queda de Gemas:
Imagine uma coluna de gemas. O algoritmo encontra um espa√ßo vazio (X) e move a gema acima (G) para baixo.

```
[G]   [ ]
[ ]   [G]
[X]   [X]
[B]   [B]
```

#### e) Preenchimento da Grade (Refill)

Finalmente, os espa√ßos vazios no topo da grade s√£o preenchidos com novas gemas geradas aleatoriamente.

```CPP
// Preencher o topo com novas gemas
for(int j=1;j<=8;j++) // Para cada coluna
    for(int i=8,n=0;i>0;i--) // De baixo para cima
        if (grid[i][j].match) // Se a gema foi combinada (espa√ßo vazio)
        {
            grid[i][j].kind = rand()%7; // Nova gema aleat√≥ria
            grid[i][j].y = -ts*n++; // Posi√ß√£o inicial acima da tela para anima√ß√£o de queda
            grid[i][j].match=0; // Resetar flag de combina√ß√£o
            grid[i][j].alpha = 255; // Resetar transpar√™ncia
            grid[i][j].special = 0; // Resetar flag de especial
        }
```

An√°lise Detalhada do Preenchimento da Grade:

1. Identifica√ß√£o de Espa√ßos Vazios Remanescentes: Ap√≥s a queda das gemas existentes, ainda pode haver espa√ßos vazios no topo da grade (onde as gemas ca√≠ram de fora da tela ou onde as gemas originais foram removidas). Estes s√£o identificados novamente pela flag `match = 1`.

2. Gera√ß√£o Aleat√≥ria: Para cada um desses espa√ßos, uma nova gema √© gerada com um `kind` aleat√≥rio (`rand()%7`).

3. Posicionamento para Anima√ß√£o de "Chuva": A linha `grid[i][j].y = -ts*n++;` √© a chave para a anima√ß√£o de "chuva".

* `ts`: Tamanho do tile (gema) em pixels.

* `n++`: Um contador que garante que cada nova gema na mesma coluna comece progressivamente mais acima da tela. Por exemplo, a primeira gema a ser preenchida no topo de uma coluna pode ter `y = -ts`, a pr√≥xima `y = -2*ts`, e assim por diante. Isso cria um efeito visual de que as gemas est√£o caindo de fora da tela.

4. Reset de Flags: As flags `match`, `alpha` e `special` s√£o resetadas para as novas gemas, preparando-as para futuras intera√ß√µes.

5. Ciclo Cont√≠nuo: Ap√≥s o preenchimento, o jogo pode precisar re-verificar por novas combina√ß√µes, pois as gemas rec√©m-ca√≠das podem ter formado novos matches. Este ciclo de "detec√ß√£o -> desaparecimento -> queda -> preenchimento -> re-detec√ß√£o" continua at√© que n√£o haja mais combina√ß√µes.

Visualiza√ß√£o da Anima√ß√£o de "Chuva":
Imagine novas gemas (N) aparecendo acima da tela e caindo para preencher os espa√ßos vazios (X).

```
[N]
[N]
[X]
[X]
[G]
```

### 3. Sistema de Pontua√ß√£o e Tempo

O jogo tem um cron√¥metro regressivo (`gameTimer`) e uma pontua√ß√£o (`score`).

```CPP
float gameTimer; // Tempo restante de jogo
int score = 0;   // Pontua√ß√£o atual
```

An√°lise Detalhada do Sistema de Pontua√ß√£o e Tempo:

1. `gameTimer`: Inicializado com um valor (ex: 60 segundos). A cada frame, o `deltaTime` (tempo decorrido desde o √∫ltimo frame) √© subtra√≠do de `gameTimer`.

2. Game Over: Quando `gameTimer` atinge ou passa de zero, o `gameState` muda para `GameOver`. Neste ponto, a pontua√ß√£o final do jogador √© salva no sistema de persist√™ncia.

3. `score`: Incrementado com base no n√∫mero de gemas combinadas. Combina√ß√µes maiores ou rea√ß√µes em cadeia podem conceder b√¥nus de pontua√ß√£o.

### 4. Estados do Jogo (Game State Management)

Para gerenciar as diferentes telas (menu, jogo, game over, high scores), usamos um `enum`.

```CPP
enum GameState { MainMenu, Playing, GameOver, HighScores };
GameState gameState = MainMenu;
```

An√°lise Detalhada dos Estados do Jogo:

1. M√°quina de Estados Finitos (FSM): A utiliza√ß√£o de um `enum GameState` √© uma implementa√ß√£o simples de uma FSM. Isso √© um padr√£o de design crucial em jogos para organizar o fluxo do programa.

2. Transi√ß√µes: As transi√ß√µes entre os estados s√£o controladas por eventos do usu√°rio (cliques em bot√µes do menu) ou por condi√ß√µes do jogo (cron√¥metro zerado).

* `MainMenu`: Exibe op√ß√µes como "Jogar", "Melhores Pontua√ß√µes", "Sair". Um clique em "Jogar" muda para `Playing`.

* `Playing`: O estado ativo do jogo. Toda a l√≥gica de mec√¢nicas (troca, matches, queda, etc.) √© executada apenas neste estado.

* `GameOver`: Exibido quando o jogo termina. Mostra a pontua√ß√£o final e op√ß√µes como "Jogar Novamente" (volta para `Playing` ap√≥s reset) ou "Voltar ao Menu" (volta para `MainMenu`).

* `HighScores`: Exibe a lista das melhores pontua√ß√µes carregadas do banco de dados. Um bot√£o "Voltar ao Menu" permite retornar.

3. Benef√≠cios da FSM:

* Organiza√ß√£o: O c√≥digo fica mais limpo, pois a l√≥gica de cada estado √© encapsulada.

* Controle: Evita que l√≥gicas de diferentes telas se misturem ou executem em momentos inadequados.

* Manuten√ß√£o: Facilita a adi√ß√£o de novos estados ou a modifica√ß√£o de estados existentes.

Diagrama da M√°quina de Estados:

```MERMAID
graph LR
    A[MainMenu] --> B{Jogar};
    B --> C[Playing];
    C --> D{Cron√¥metro = 0};
    D --> E[GameOver];
    E --> F{Jogar Novamente};
    F --> C;
    E --> G{Voltar ao Menu};
    G --> A;
    A --> H{Melhores Pontua√ß√µes};
    H --> I[HighScores];
    I --> G;
```

### 5. Persist√™ncia de Dados: SQLite

Um recurso avan√ßado implementado √© o sistema de pontua√ß√£o persistente usando SQLite. Isso permite que as pontua√ß√µes sejam salvas e carregadas entre as sess√µes do jogo.

```CPP
sqlite3 *db; // Ponteiro para o banco de dados SQLite

void openDatabase() { /* ... */ }
void createTable() { /* ... */ }
void saveHighScore(int score) { /* ... */ }
void loadHighScores() { /* ... */ }
```

An√°lise Detalhada da Persist√™ncia com SQLite:

1. SQLite como Banco de Dados Embarcado: SQLite √© uma biblioteca de banco de dados SQL leve, sem servidor, que pode ser incorporada diretamente em um aplicativo. √â ideal para jogos e aplicativos m√≥veis que precisam de persist√™ncia de dados local sem a complexidade de um servidor de banco de dados.

2. `sqlite3 *db`: Um ponteiro para a estrutura `sqlite3` que representa a conex√£o com o banco de dados.

3. `openDatabase()`:

* Chama `sqlite3_open("bejeweled_scores.db", &db)`. Se o arquivo `bejeweled_scores.db` n√£o existir, ele ser√° criado. Caso contr√°rio, a conex√£o ser√° estabelecida com o banco de dados existente.

* Inclui tratamento de erros para verificar se a abertura foi bem-sucedida.

4. `createTable()`:

* Executa uma instru√ß√£o SQL `CREATE TABLE IF NOT EXISTS highscores (...)`. O `IF NOT EXISTS` √© crucial para evitar erros se a tabela j√° existir.

* A tabela `highscores` armazena `id` (chave prim√°ria auto-incrementada), `score` (pontua√ß√£o do jogador) e `timestamp` (data e hora em que a pontua√ß√£o foi registrada).

* Usa `sqlite3_exec` para executar a instru√ß√£o SQL.

5. `saveHighScore(int score)`:

* Formata uma instru√ß√£o `INSERT` usando `sprintf` para incluir a pontua√ß√£o e um timestamp atual.

* O timestamp √© gerado usando fun√ß√µes de tempo do C (`time`, `localtime`, `strftime`).

* Executa a instru√ß√£o `INSERT` via `sqlite3_exec`.

6. `loadHighScores()`:

* Executa uma instru√ß√£o `SELECT score, timestamp FROM highscores ORDER BY score DESC LIMIT 10;` para obter as 10 maiores pontua√ß√µes.

* Usa um callback function (`static int callback(...)`) que √© invocada para cada linha de resultado. Dentro do callback, os dados s√£o lidos e armazenados em uma estrutura de dados (ex: `std::vector<std::pair<int, std::string>> highScores`).

7. Fechamento da Conex√£o: √â fundamental chamar `sqlite3_close(db)` ao final do programa para liberar os recursos do banco de dados.

## 

Estrutura do C√≥digo (`main.cpp`)

O arquivo `main.cpp` do Bejeweled segue uma estrutura comum para jogos SFML, organizada para clareza e modularidade.

1. Includes:

* `SFML/Graphics.hpp`: Para todas as funcionalidades gr√°ficas (janela, texturas, sprites, texto).

* `time.h`: Para fun√ß√µes de tempo (gera√ß√£o de n√∫meros aleat√≥rios, timestamps).

* `vector`, `iostream`, `string`, `iomanip`: Utilit√°rios C++ padr√£o.

* `sqlite3.h`: Para a integra√ß√£o com o banco de dados SQLite.

2. Constantes e Estruturas Globais:

* `ts`: Tamanho do tile (gema) em pixels.

* `offset`: Um `Vector2i` para ajustar a posi√ß√£o de desenho da grade na tela, centralizando-a ou posicionando-a conforme o design da UI.

* `struct piece`: A estrutura que define as propriedades de cada gema.

* `grid[10][10]`: A matriz global que representa o tabuleiro de jogo.

* `enum GameState`: Define os estados poss√≠veis do jogo.

* `sqlite3 *db`: O ponteiro global para a conex√£o com o banco de dados.

3. Fun√ß√µes Auxiliares:

* `swap(piece p1, piece p2)`: L√≥gica para trocar duas gemas.

* `resetGame()`: Inicializa o tabuleiro com gemas aleat√≥rias e reinicia o cron√¥metro.

* Fun√ß√µes SQLite (`openDatabase`, `createTable`, `saveHighScore`, `loadHighScores`): Gerenciam a intera√ß√£o com o banco de dados.

4. Fun√ß√£o `main()`: O ponto de entrada do programa.

* Inicializa√ß√£o: * `srand(time(0))`: Inicializa o gerador de n√∫meros aleat√≥rios. * `RenderWindow app(...)`: Cria a janela do jogo. * `app.setFramerateLimit(60)`: Limita o FPS para garantir consist√™ncia. * Carregamento de `Texture` (fundo, gemas), cria√ß√£o de `Sprite`. * Carregamento de `Font` e cria√ß√£o de objetos `Text` para todos os elementos da UI (t√≠tulos, bot√µes, pontua√ß√£o, tempo, mensagens de game over, high scores). * `openDatabase()` e `createTable()`: Inicializam o sistema de persist√™ncia. * `resetGame()`: Prepara o tabuleiro inicial.

* Loop Principal do Jogo (`while (app.isOpen())`): Este √© o cora√ß√£o do jogo, executando continuamente enquanto a janela est√° aberta. * Controle de Tempo (`deltaTime`): Calcula o tempo decorrido entre os frames para garantir que as anima√ß√µes e o cron√¥metro sejam independentes da taxa de quadros. * Processamento de Eventos (`while (app.pollEvent(e))`): Captura e responde a eventos do usu√°rio (cliques do mouse, fechamento da janela). A l√≥gica de resposta varia de acordo com o `gameState` atual. * Atualiza√ß√£o da L√≥gica do Jogo (`if (gameState == Playing)`): Toda a l√≥gica de jogo (movimento de gemas, detec√ß√£o de matches, anima√ß√µes, atualiza√ß√£o do cron√¥metro) √© executada apenas quando o jogo est√° no estado `Playing`. * Renderiza√ß√£o (`app.draw(...)`): Limpa a tela e desenha todos os elementos visuais. A interface desenhada tamb√©m depende do `gameState` atual.

* Fechamento: `sqlite3_close(db)`: Garante que a conex√£o com o banco de dados seja encerrada corretamente.

## Conceitos de Programa√ß√£o Aprendidos

Ao estudar e modificar o c√≥digo do Bejeweled, voc√™ aprender√° uma vasta gama de conceitos essenciais em desenvolvimento de jogos e programa√ß√£o geral:

1. Programa√ß√£o Orientada a Eventos: Compreender como o jogo reage de forma ass√≠ncrona √†s intera√ß√µes do usu√°rio (cliques do mouse, pressionamento de teclas). O loop de eventos (`app.pollEvent`) √© o cerne dessa abordagem.

2. Gerenciamento de Estados (M√°quina de Estados Finitos - FSM): A utiliza√ß√£o do `enum GameState` demonstra um padr√£o de design fundamental para organizar o fluxo do jogo. Voc√™ aprender√° a controlar as transi√ß√µes entre diferentes telas (menu, jogo, game over) e a executar l√≥gicas espec√≠ficas para cada estado, tornando o c√≥digo mais modular e f√°cil de depurar.

3. Manipula√ß√£o de Matrizes 2D: O tabuleiro de jogo √© uma matriz 2D (`grid[10][10]`). Voc√™ aprender√° a acessar, modificar e iterar sobre elementos em uma estrutura bidimensional, essencial para jogos baseados em grade. A t√©cnica de "bordas sentinela" (usando uma matriz 10x10 para um tabuleiro 8x8) √© um exemplo pr√°tico de como simplificar a l√≥gica de limites.

4. Algoritmos de Busca e Varredura: A detec√ß√£o de combina√ß√µes (`Match Finding`) envolve varrer a matriz em busca de padr√µes. Voc√™ entender√° como implementar algoritmos eficientes para identificar grupos de gemas id√™nticas na horizontal e na vertical.

5. Anima√ß√£o e Interpola√ß√£o: O controle de `alpha` para o desaparecimento e a atualiza√ß√£o gradual das coordenadas `x` e `y` para a queda de gemas s√£o exemplos de t√©cnicas de anima√ß√£o. Voc√™ aprender√° a criar movimentos e transi√ß√µes visuais suaves, essenciais para uma boa experi√™ncia de usu√°rio.

6. Persist√™ncia de Dados com SQLite: A integra√ß√£o com SQLite √© uma introdu√ß√£o pr√°tica a bancos de dados embarcados. Voc√™ aprender√° a abrir/criar um banco de dados, definir esquemas de tabela, inserir dados (pontua√ß√µes) e consultar informa√ß√µes (melhores pontua√ß√µes), permitindo que o jogo salve o progresso entre as sess√µes.

7. Timing e Controle de Jogo: O uso de `sf::Clock` e `deltaTime` √© crucial para garantir que a velocidade do jogo e das anima√ß√µes seja consistente, independentemente da taxa de quadros do computador. Voc√™ aprender√° a gerenciar cron√¥metros e a sincronizar eventos baseados no tempo.

8. Design de UI/UX B√°sico: A cria√ß√£o de menus interativos, bot√µes e a exibi√ß√£o de informa√ß√µes como pontua√ß√£o e tempo s√£o elementos fundamentais de UI (User Interface) e UX (User Experience). Voc√™ ver√° como organizar e renderizar esses elementos para fornecer feedback claro ao jogador.

9. Gera√ß√£o de Conte√∫do Procedural: A gera√ß√£o aleat√≥ria de gemas no in√≠cio do jogo e durante o preenchimento da grade √© um exemplo simples de gera√ß√£o procedural, onde o conte√∫do do jogo √© criado algoritmicamente em tempo de execu√ß√£o.

Bejeweled √© um excelente projeto para aprofundar seus conhecimentos em desenvolvimento de jogos, combinando l√≥gica de quebra-cabe√ßa com elementos visuais e persist√™ncia de dados.



# NetWalk

## Introdu√ß√£o

Bem-vindo ao guia de desenvolvimento do NetWalk! Este documento detalha o processo de cria√ß√£o do jogo, desde a ideia inicial at√© a implementa√ß√£o do c√≥digo em C++ com a biblioteca SFML. O objetivo √© fornecer um passo a passo claro para desenvolvedores j√∫nior que desejam entender a l√≥gica por tr√°s de um jogo de quebra-cabe√ßa.

### O que √© o NetWalk?

NetWalk √© um jogo de quebra-cabe√ßa onde o jogador deve rotacionar pe√ßas de canos em uma grade para conectar todos os computadores a um servidor central. √â um teste de l√≥gica e vis√£o espacial.

### Tecnologias Utilizadas

* C++: A linguagem de programa√ß√£o principal, escolhida por sua performance e controle.

* SFML (Simple and Fast Multimedia Library): Uma biblioteca de multim√≠dia f√°cil de usar para criar jogos 2D, cuidando de gr√°ficos, √°udio, janelas e eventos.

## 2. Da Concep√ß√£o ao Design

Todo jogo come√ßa com uma ideia. A concep√ß√£o do NetWalk foi baseada em quebra-cabe√ßas de conex√£o cl√°ssicos.

### A Ideia Central

A ideia era criar uma rede. O jogador n√£o move as pe√ßas, mas muda sua orienta√ß√£o para formar um caminho cont√≠nuo. Isso cria uma mec√¢nica de jogo simples, mas com um potencial de complexidade crescente.

### Elementos de Design

* Grade: Uma grade 2D foi a escolha natural para organizar as pe√ßas de forma clara.

* Pe√ßas (Canos): As pe√ßas s√£o os elementos que o jogador manipula. Elas podem ser retas, curvas ou ter m√∫ltiplas conex√µes (T, cruzamento).

* Servidor e Computadores: Para dar um objetivo claro, definimos um ponto de partida (o servidor) e pontos de chegada (os computadores). O desafio √© conectar todos os computadores ao servidor.

* Rota√ß√£o: A intera√ß√£o principal do jogador √© a rota√ß√£o das pe√ßas, uma a√ß√£o simples que tem um impacto direto na rede.

## 3. Estruturas de Dados: A Base do Jogo

Para implementar a l√≥gica, precisamos de estruturas de dados eficientes.

### 

A Estrutura `pipe`

Cada pe√ßa na grade √© representada pela struct `pipe`. Ela cont√©m toda a informa√ß√£o necess√°ria sobre uma pe√ßa individual.

```CSHARP
struct pipe
{
  // Vetor que armazena as dire√ß√µes para onde o cano aponta.
  // Ex: um cano reto vertical teria os vetores Up e Down.
  std::vector<Vector2i> dirs;

  // A orienta√ß√£o da pe√ßa em m√∫ltiplos de 90 graus. Usado para anima√ß√£o.
  int orientation;

  // O √¢ngulo atual da pe√ßa. Usado para a anima√ß√£o suave de rota√ß√£o.
  float angle;

  // Um booleano que indica se a pe√ßa est√° recebendo energia do servidor.
  bool on;
};
```

### 

A Grade `grid`

A grade √© uma matriz 2D que armazena todas as pe√ßas do jogo.

```CSHARP
// N √© uma constante que define o tamanho da grade (6x6)
const int N = 6;
pipe grid[N][N];
```

### Vetores de Dire√ß√£o

Para facilitar o trabalho com dire√ß√µes, definimos vetores `Vector2i` para representar Cima, Baixo, Esquerda e Direita.

```CSHARP
Vector2i Up(0,-1);
Vector2i Down(0,1);
Vector2i Right(1,0);
Vector2i Left(-1,0);

Vector2i DIR[4] = {Up,Right,Down,Left};
```

## 4. L√≥gica do Jogo em Detalhes

Esta se√ß√£o detalha os algoritmos centrais do jogo.

### 

Gera√ß√£o do Quebra-Cabe√ßa (`generatePuzzle`)

Criar um quebra-cabe√ßa que tenha solu√ß√£o √© crucial. Usamos um algoritmo de gera√ß√£o procedural:

1. In√≠cio: Come√ßamos com uma grade vazia e uma lista de "n√≥s ativos", adicionando uma c√©lula aleat√≥ria a ela.

2. Expans√£o: Enquanto a lista de n√≥s n√£o estiver vazia, pegamos um n√≥ e tentamos conect√°-lo a um vizinho aleat√≥rio que ainda n√£o faz parte da rede.

3. Cria√ß√£o de Conex√µes: Se uma conex√£o √© feita, o vizinho √© adicionado √† lista de n√≥s ativos, e o processo continua. Isso cria um caminho cont√≠nuo e garante que todas as pe√ßas estejam conectadas.

```MERMAID
graph TD
    A[In√≠cio] --> B[Limpar Grade];
    B --> C[Adicionar N√≥ Aleat√≥rio √† Lista];
    C --> D{Lista de N√≥s Vazia?};
    D -- N√£o --> E[Selecionar N√≥ da Lista];
    E --> F[Escolher Dire√ß√£o Aleat√≥ria];
    F --> G{Vizinho V√°lido e Vazio?};
    G -- Sim --> H[Conectar N√≥ ao Vizinho];
    H --> I[Adicionar Vizinho √† Lista];
    I --> D;
    G -- N√£o --> E;
    D -- Sim --> J[Fim];
```

### 

Energizando a Rede (`drop`)

Para saber quais pe√ßas est√£o conectadas ao servidor, usamos uma fun√ß√£o recursiva chamada `drop`.

1. A fun√ß√£o come√ßa no servidor (`servPos`).

2. Ela marca a pe√ßa atual como energizada (`on = true`).

3. Em seguida, ela olha para todos os vizinhos. Se um vizinho est√° conectado √† pe√ßa atual (e vice-versa), a fun√ß√£o `drop` √© chamada para o vizinho.

4. Este processo continua at√© que todos os canos conectados ao servidor estejam marcados como `on`.

### 

Condi√ß√£o de Vit√≥ria (`checkWin`)

A vit√≥ria ocorre quando todos os computadores (pe√ßas com apenas uma conex√£o) est√£o energizados. A fun√ß√£o `checkWin` simplesmente itera pela grade e retorna `false` se encontrar qualquer computador com `on == false`.

### Gerenciamento de Estado

O fluxo do jogo √© controlado por uma m√°quina de estados simples.

```MERMAID
stateDiagram-v2
    [*] --> MENU
    MENU --> PLAYING: Clique em "Novo Jogo"
    PLAYING --> MENU: Pressionar ESC
    MENU --> [*]: Clique em "Sair"
    PLAYING --> PLAYING: N√≠vel Conclu√≠do
```

## 5. Implementa√ß√£o com SFML

A SFML torna a parte gr√°fica relativamente simples.

* Janela e Loop Principal: A `RenderWindow` da SFML cria a janela, e o `while (app.isOpen())` forma o loop principal do jogo.

* Carregamento de Recursos: Texturas para os canos, fundo, servidor e computadores, bem como a fonte para o texto, s√£o carregadas no in√≠cio do `main`.

* Renderiza√ß√£o: A cada frame, a tela √© limpa (`app.clear()`) e todos os elementos vis√≠veis (sprites e textos) s√£o desenhados (`app.draw()`).

* Eventos: O loop `while (app.pollEvent(e))` captura as a√ß√µes do jogador, como cliques do mouse e pressionamento de teclas, permitindo que o jogo responda a elas.

## Conclus√£o

O NetWalk √© um exemplo de como mec√¢nicas simples podem criar um jogo de quebra-cabe√ßa desafiador e divertido. A combina√ß√£o de um algoritmo de gera√ß√£o procedural com uma l√≥gica de verifica√ß√£o de vit√≥ria clara e uma implementa√ß√£o gr√°fica limpa com SFML resulta em uma experi√™ncia de jogo completa.

Como pr√≥ximos passos, voc√™ pode tentar expandir o jogo:

* Aumentar o tamanho da grade (`N`) a cada n√≠vel.

* Adicionar novos tipos de pe√ßas.

* Implementar um sistema de pontua√ß√£o baseado em tempo.



# Mahjong Solitaire

Imagine um quebra-cabe√ßa tridimensional onde voc√™ precisa encontrar pares de pe√ßas id√™nticas para remov√™-las, revelando novas oportunidades por baixo. Assim como um arque√≥logo que remove camadas de terra para descobrir artefatos escondidos, no Mahjong Solitaire voc√™ remove pe√ßas para desvendar o que est√° por baixo, sempre buscando o pr√≥ximo par "livre".

Este tutorial explora a fundo a implementa√ß√£o do cl√°ssico jogo Mahjong Solitaire, tamb√©m conhecido como Mahjong Patience, utilizando C++ e a biblioteca SFML (Simple and Fast Multimedia Library). Abordaremos a l√≥gica do jogo, a estrutura do c√≥digo, e as funcionalidades adicionadas recentemente, como menu, temporizador e pontua√ß√£o, que transformaram o jogo em uma experi√™ncia mais completa e desafiadora.

## O que √© Mahjong Solitaire?

Mahjong Solitaire √© um jogo de paci√™ncia para um jogador que utiliza um conjunto de pe√ßas de Mahjong. O objetivo √© remover todas as pe√ßas do tabuleiro, combinando pares de pe√ßas id√™nticas que estejam "livres".

### Regras B√°sicas:

* Pares: Duas pe√ßas s√£o consideradas um par se tiverem o mesmo desenho.

* Pe√ßa Livre: Uma pe√ßa est√° livre se n√£o houver outras pe√ßas diretamente sobre ela e se ela tiver pelo menos um lado (esquerdo ou direito) completamente desobstru√≠do.

Para ilustrar o conceito de "Pe√ßa Livre", considere o diagrama abaixo:

```MERMAID
graph TD
    subgraph Camada Superior
        A[Pe√ßa A]
    end
    subgraph Camada Intermedi√°ria
        B[Pe√ßa B] --- C[Pe√ßa C]
    end
    subgraph Camada Inferior
        D[Pe√ßa D] --- E[Pe√ßa E] --- F[Pe√ßa F]
    end

    A -- "sobre" --> B
    A -- "sobre" --> C

    B -- "lado esquerdo livre" --> G(Espa√ßo Vazio)
    C -- "lado direito livre" --> H(Espa√ßo Vazio)

    D --- E
    E --- F

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style D fill:#bfb,stroke:#333,stroke-width:2px
    style E fill:#bfb,stroke:#333,stroke-width:2px
    style F fill:#bfb,stroke:#333,stroke-width:2px

    style B fill:#8f8,stroke:#333,stroke-width:4px
    style C fill:#8f8,stroke:#333,stroke-width:4px

    linkStyle 0 stroke:#f66,stroke-width:2px,fill:none;
    linkStyle 1 stroke:#f66,stroke-width:2px,fill:none;

    linkStyle 2 stroke:#3c3,stroke-width:2px,fill:none;
    linkStyle 3 stroke:#3c3,stroke-width:2px,fill:none;

    linkStyle 4 stroke:#999,stroke-width:1px,fill:none;
    linkStyle 5 stroke:#999,stroke-width:1px,fill:none;
```

No diagrama acima, podemos ver exemplos de pe√ßas livres e bloqueadas:

* Pe√ßa A: N√£o est√° livre, pois as pe√ßas B e C est√£o sob ela.

* Pe√ßa B: Est√° livre, pois n√£o h√° nenhuma pe√ßa sobre ela e seu lado esquerdo est√° desobstru√≠do.

* Pe√ßa C: Est√° livre, pois n√£o h√° nenhuma pe√ßa sobre ela e seu lado direito est√° desobstru√≠do.

* Pe√ßa D: N√£o est√° livre. No contexto do jogo, a pe√ßa B (da camada intermedi√°ria) estaria sobre ela, bloqueando-a.

* Objetivo: Remover todas as pe√ßas do tabuleiro.

## 

Estrutura do C√≥digo (`main.cpp`)

O arquivo `main.cpp` cont√©m toda a l√≥gica do jogo, desde a inicializa√ß√£o da janela e dos elementos gr√°ficos at√© o manuseio das intera√ß√µes do usu√°rio e a renderiza√ß√£o na tela.

### 1. Inclus√µes e Vari√°veis Globais

O jogo utiliza a biblioteca SFML (Simple and Fast Multimedia Library) para todas as opera√ß√µes gr√°ficas, de √°udio e de entrada. SFML √© uma biblioteca C++ que simplifica o desenvolvimento de jogos 2D, fornecendo m√≥dulos para gr√°ficos, janelas, √°udio e entrada do usu√°rio. Al√©m disso, `fstream` √© usado para carregar o layout do tabuleiro de arquivos, e `time.h` para a gera√ß√£o de n√∫meros aleat√≥rios. `sstream` (para manipula√ß√£o de strings) e `iostream` (para entrada/sa√≠da padr√£o) foram adicionados para o sistema de pontua√ß√£o e temporizador.

```CSHARP
#include <SFML/Graphics.hpp> // M√≥dulo gr√°fico da SFML
#include <fstream>           // Para manipula√ß√£o de arquivos (leitura do mapa)
#include <time.h>            // Para inicializar o gerador de n√∫meros aleat√≥rios (srand)
#include <sstream>           // Para formatar strings (usado no score e timer)
#include <iostream>          // Para entrada/sa√≠da padr√£o (ex: depura√ß√£o)

using namespace sf; // Simplifica o uso de classes da SFML (ex: RenderWindow, Texture)

// Representa√ß√£o 3D do tabuleiro do Mahjong.
// Cada elemento armazena o tipo de pe√ßa ou 0 se estiver vazio.
// As dimens√µes s√£o maiores (50x50x50) para acomodar bordas de seguran√ßa e evitar acessos inv√°lidos.
int field[50][50][50] = {0};
```

Termos T√©cnicos Explicados:

* SFML (Simple and Fast Multimedia Library): Uma biblioteca C++ de c√≥digo aberto que facilita a cria√ß√£o de jogos e aplica√ß√µes multim√≠dia, abstraindo as complexidades de APIs gr√°ficas e de √°udio.

* `#include`: Diretiva de pr√©-processador em C++ que inclui o conte√∫do de outro arquivo no c√≥digo-fonte atual, permitindo o uso de funcionalidades definidas nesses arquivos.

* `fstream`: Biblioteca padr√£o do C++ para opera√ß√µes de entrada/sa√≠da com arquivos.

* `time.h`: Biblioteca padr√£o do C que fornece fun√ß√µes para manipula√ß√£o de tempo, como `time()` para obter o tempo atual do sistema, frequentemente usado para semear geradores de n√∫meros aleat√≥rios.

* `sstream`: Biblioteca padr√£o do C++ que permite manipular strings como se fossem fluxos de entrada/sa√≠da, √∫til para construir strings formatadas (como as do score e timer).

* `iostream`: Biblioteca padr√£o do C++ para opera√ß√µes de entrada/sa√≠da, como imprimir no console (`std::cout`).

* `using namespace sf;`: Declara√ß√£o que permite usar os nomes das classes e fun√ß√µes da SFML diretamente (ex: `RenderWindow` em vez de `sf::RenderWindow`).

* `int field[50][50][50]`: Um array tridimensional de inteiros. No Mahjong, ele representa o tabuleiro de jogo, onde cada `field[y][x][z]` indica a presen√ßa e o tipo de uma pe√ßa em uma coordenada espec√≠fica (coluna `x`, linha `y`, camada `z`). O valor `0` geralmente indica um espa√ßo vazio.

### 2. Fun√ß√µes Auxiliares

#### 

`f(x, y, z)`

Esta √© uma fun√ß√£o auxiliar simples que fornece uma maneira mais conveniente de acessar os elementos do array tridimensional `field`. Em vez de escrever `field[y + 2][x + 2][z]` repetidamente, podemos usar `f(x, y, z)`. Os offsets `+2` s√£o usados para criar uma "borda" ao redor do tabuleiro l√≥gico, simplificando as verifica√ß√µes de limites em outras fun√ß√µes.

```CSHARP
int& f(int x,int y,int z){return field[y+2][x+2][z];}
int& f(Vector3i v){return f(v.x,v.y,v.z);}
```

Termos T√©cnicos Explicados:

* `int&`: Indica que a fun√ß√£o retorna uma refer√™ncia para um inteiro. Isso significa que a fun√ß√£o n√£o retorna uma c√≥pia do valor, mas sim o pr√≥prio local na mem√≥ria, permitindo que voc√™ modifique o elemento do array diretamente atrav√©s da fun√ß√£o `f`.

* `Vector3i`: Uma estrutura de dados da SFML que representa um vetor tridimensional de inteiros, com componentes `x`, `y` e `z`. √â √∫til para agrupar coordenadas.

#### 

`isOpen(x, y, z)`

Esta fun√ß√£o √© crucial para a l√≥gica do jogo, pois determina se uma pe√ßa na posi√ß√£o `(x, y, z)` est√° "livre" e pode ser selecionada pelo jogador. Uma pe√ßa √© considerada livre se:

1. N√£o houver nenhuma pe√ßa diretamente sobre ela (na camada `z+1`).

2. Tiver pelo menos um lado (esquerdo ou direito) completamente desobstru√≠do, ou seja, n√£o h√° pe√ßas adjacentes que a bloqueiem em ambos os lados.

```CSHARP
bool isOpen(int x,int y,int z)
{
  // Verifica se h√° pe√ßas bloqueando os lados (esquerda e direita)
  // Se houver pe√ßas em (x+2, y+i, z) E (x-2, y+j, z) para qualquer i,j de -1 a 1,
  // significa que a pe√ßa est√° "presa" entre outras duas.
  for(int i=-1;i<=1;i++)
   for(int j=-1;j<=1;j++)
    if (f(x+2,y+i,z)>0 && f(x-2,y+j,z)>0) return false; // Retorna false se ambos os lados est√£o bloqueados

  // Verifica se h√° pe√ßas diretamente sobre ela (na camada superior)
  // Se houver qualquer pe√ßa em (x+i, y+j, z+1) para qualquer i,j de -1 a 1,
  // significa que h√° uma pe√ßa sobre ela.
  for(int i=-1;i<=1;i++)
   for(int j=-1;j<=1;j++)
    if ( f(x+i,y+j,z+1)>0 ) return false; // Retorna false se houver pe√ßa sobre ela

  return true; // Se nenhuma das condi√ß√µes acima for verdadeira, a pe√ßa est√° livre
}
```

Diagrama da L√≥gica `isOpen`:

```MERMAID
graph TD
    A[Verificar isOpen x,y,z] --> B{H√° pe√ßas bloqueando ambos os lados x+2 E x-2?}
    B -- Sim --> C[Retorna false N√£o est√° livre]
    B -- N√£o --> D{H√° pe√ßas diretamente sobre x,y,z+1?}
    D -- Sim --> C
    D -- N√£o --> E[Retorna true Est√° livre]
```

Termos T√©cnicos Explicados:

* `bool`: Um tipo de dado que pode ter apenas dois valores: `true` (verdadeiro) ou `false` (falso). Usado para indicar sucesso ou falha de uma condi√ß√£o.

* `for` loop: Uma estrutura de controle de fluxo que permite executar um bloco de c√≥digo repetidamente um n√∫mero espec√≠fico de vezes. Essencial para iterar sobre vizinhos ou camadas.

* `return`: Uma palavra-chave que encerra a execu√ß√£o de uma fun√ß√£o e, opcionalmente, retorna um valor para o chamador.

#### 

`resetGame(score, timer, moves)`

Esta fun√ß√£o √© o ponto de partida para cada nova partida de Mahjong Solitaire. Ela √© respons√°vel por inicializar ou reiniciar completamente o estado do jogo, garantindo um tabuleiro fresco e solucion√°vel.

Passos da Fun√ß√£o `resetGame`:

1. Reinicializa√ß√£o de Vari√°veis: A pontua√ß√£o (`score`) √© zerada, o temporizador (`timer`) √© configurado para 5 minutos (300 segundos), e o hist√≥rico de movimentos (`moves`) √© limpo.

2. Limpeza do Tabuleiro: O array `field` (que representa o tabuleiro 3D) √© completamente zerado, removendo todas as pe√ßas de uma partida anterior.

3. Carregamento do Layout do Tabuleiro: O jogo l√™ um arquivo de texto (por exemplo, `files/map.txt`) que define a estrutura b√°sica do tabuleiro. Cada caractere no arquivo representa a altura das pilhas de pe√ßas em uma determinada posi√ß√£o `(x, y)`. Isso permite criar layouts de tabuleiro pr√©-definidos.

```CPLUSPLUS
// Carrega o layout do tabuleiro a partir de um arquivo (ex: files/map.txt)
std::fstream myfile("files/map.txt");
for(int y=0;y<18;y++)
 for(int x=0;x<30;x++)
  {
    char a;  myfile >> a;
    int n = a - '0'; // Converte o caractere para um n√∫mero (altura da pilha)
    for(int z=0;z<n;z++)
      // Preenche as camadas inferiores com 1 (indicando pe√ßa presente)
      if (f(x-1,y-1,z)) f(x-1,y,z)=f(x,y-1,z)=0; // L√≥gica original, pode ser simplificada
      else f(x,y,z)=1;
  }
```

4. Gera√ß√£o Aleat√≥ria de Pares de Pe√ßas: Esta √© a parte mais inteligente da fun√ß√£o. Em vez de simplesmente preencher o tabuleiro com pe√ßas aleat√≥rias, o algoritmo garante que cada pe√ßa tenha um par correspondente e que o tabuleiro seja solucion√°vel. Ele faz isso encontrando posi√ß√µes "abertas" (`opens`) e atribuindo pares de IDs de pe√ßas (`-k`) a elas. O `k` √© incrementado e modulado para ciclar pelos diferentes tipos de pe√ßas.

```CSHARP
// Cria o mapa de pe√ßas, garantindo que cada pe√ßa tenha um par e o tabuleiro seja solucion√°vel
for(int k=1;;k++) // k representa o ID do tipo de pe√ßa
{
 std::vector<Vector3i> opens; // Armazena posi√ß√µes de pe√ßas "abertas" (livres)
 for(int z=0;z<10;z++)
  for(int y=0;y<18;y++)
   for(int x=0;x<30;x++)
    if (f(x,y,z)>0 && isOpen(x,y,z)) opens.push_back(Vector3i(x,y,z));

 int n=opens.size();
 if (n<2) break; // Se menos de 2 pe√ßas abertas, n√£o h√° mais pares para formar
 int a=0,b=0;
 while(a==b){a=rand()%n;b=rand()%n;} // Seleciona duas posi√ß√µes abertas aleatoriamente
 f(opens[a])=-k;  if (k>34) k++; // Atribui o ID da pe√ßa (negativo para indicar que √© um tipo de pe√ßa)
 f(opens[b])=-k; // Atribui o mesmo ID para o par
 k%=42; // Cicla pelos IDs de pe√ßas (42 tipos diferentes)
}

// Converte os IDs de pe√ßa para valores positivos para o jogo
for(int z=0;z<10;z++)
 for(int y=0;y<18;y++)
  for(int x=0;x<30;x++) f(x,y,z)*=-1;
```

Termos T√©cnicos Explicados:

* `std::fstream`: Um objeto para lidar com opera√ß√µes de arquivo, como leitura (`myfile >> a;`).

* `srand(time(0))`: Fun√ß√£o usada para "semear" o gerador de n√∫meros pseudoaleat√≥rios. `time(0)` fornece um valor baseado no tempo atual, garantindo que a sequ√™ncia de n√∫meros aleat√≥rios seja diferente a cada execu√ß√£o do programa.

* `std::vector<Vector3i> opens`: Um `std::vector` √© um cont√™iner din√¢mico que pode armazenar uma cole√ß√£o de objetos (neste caso, `Vector3i`). Ele cresce e encolhe automaticamente conforme necess√°rio. Aqui, ele armazena as coordenadas de todas as pe√ßas que est√£o "livres" no momento da gera√ß√£o do tabuleiro.

* `rand()%n`: Gera um n√∫mero pseudoaleat√≥rio entre 0 e `n-1`. Usado para selecionar aleatoriamente as posi√ß√µes das pe√ßas.

### 

3. Estados do Jogo (`GameState`)

Para gerenciar as diferentes telas e fluxos do jogo, utilizamos um `enum` (enumera√ß√£o) para definir os estados. Isso √© uma pr√°tica comum em desenvolvimento de jogos para controlar o que est√° acontecendo no jogo a qualquer momento e como ele deve reagir √†s intera√ß√µes do jogador.

```CPLUSPLUS
enum GameState {
    MENU,      // O jogo est√° na tela inicial, aguardando o jogador iniciar.
    PLAYING,   // O jogo est√° em andamento, com a l√≥gica de jogo ativa.
    GAME_OVER  // O jogo terminou, exibindo a pontua√ß√£o final e op√ß√µes de rein√≠cio.
};
```

Diagrama de Estados do Jogo:

```MERMAID
stateDiagram-v2
    [*] --> MENU
    MENU --> PLAYING: Clique em 'Play'
    PLAYING --> GAME_OVER: Tempo esgotado
    PLAYING --> GAME_OVER: Todas as pe√ßas removidas (Vit√≥ria)
    GAME_OVER --> PLAYING: Clique em 'Play Again'
    GAME_OVER --> MENU: Voltar ao Menu (se implementado)
```

Termos T√©cnicos Explicados:

* `enum` (Enumera√ß√£o): Um tipo de dado que permite definir um conjunto de constantes nomeadas. √â √∫til para criar um c√≥digo mais leg√≠vel e menos propenso a erros, usando nomes significativos em vez de n√∫meros "m√°gicos" para representar estados ou op√ß√µes.

### 

4. Loop Principal (`main` function)

A fun√ß√£o `main` √© o cora√ß√£o de qualquer aplica√ß√£o SFML e de muitos jogos. Ela cont√©m o loop principal do jogo, que √© um ciclo cont√≠nuo que se repete muitas vezes por segundo. A cada repeti√ß√£o (chamada de "frame"), o jogo realiza as seguintes etapas:

1. Processamento de Eventos: Captura as intera√ß√µes do usu√°rio (cliques do mouse, fechamento da janela) e eventos do sistema.

2. Atualiza√ß√£o da L√≥gica do Jogo: Calcula o tempo, atualiza o temporizador, verifica condi√ß√µes de vit√≥ria/derrota, e processa a l√≥gica de sele√ß√£o e remo√ß√£o de pe√ßas.

3. Renderiza√ß√£o: Desenha todos os elementos visuais na tela (fundo, pe√ßas, score, timer, mensagens).

```CPLUSPLUS
int main() {
    srand(time(0)); // Inicializa o gerador de n√∫meros aleat√≥rios

    RenderWindow app(VideoMode(940, 570), "Mahjong Solitaire!"); // Cria a janela do jogo
    app.setFramerateLimit(60); // Limita a taxa de quadros a 60 FPS

    // ... Carregamento de Texturas (pe√ßas, fundo) e Sprites ...
    // ... Configura√ß√£o de Fontes e Textos (score, timer, menu, game over) ...

    // Vari√°veis de estado do jogo
    GameState gameState = MENU;
    int score = 0;
    float timer = 300; // 5 minutos
    Clock clock; // Cron√¥metro para o jogo

    resetGame(score, timer, moves); // Inicializa o tabuleiro e vari√°veis

    while (app.isOpen()) { // Loop principal do jogo
        Event e; // Objeto para eventos
        while (app.pollEvent(e)) { // Processa todos os eventos pendentes
            if (e.type == Event::Closed) // Se o evento for fechar a janela
                app.close(); // Fecha a aplica√ß√£o

            // L√≥gica de manuseio de eventos baseada no estado atual do jogo
            if (gameState == MENU) {
                // ... (l√≥gica para clique no bot√£o 'Play') ...
            } else if (gameState == PLAYING) {
                // ... (l√≥gica para cliques do mouse para selecionar pe√ßas e desfazer) ...
            } else if (gameState == GAME_OVER) {
                // ... (l√≥gica para clique no bot√£o 'Play Again') ...
            }
        }

        app.clear(); // Limpa a tela
        app.draw(sBackground); // Desenha o fundo

        // L√≥gica de desenho baseada no estado atual do jogo
        if (gameState == MENU) {
            // ... (desenha o menu 'Play') ...
        } else if (gameState == PLAYING) {
            // ... (atualiza e desenha o timer e score, desenha as pe√ßas do tabuleiro) ...
        } else if (gameState == GAME_OVER) {
            // ... (desenha a tela de 'Game Over' com pontua√ß√£o final) ...
        }

        app.display(); // Exibe o que foi desenhado na tela
    }
    return 0;
}
```

Diagrama de Sequ√™ncia: Sele√ß√£o e Remo√ß√£o de Pe√ßas

```MERMAID
sequenceDiagram
    participant Jogador
    participant Jogo
    participant Tabuleiro

    Jogador->>Jogo: Clica na Pe√ßa 1
    Jogo->>Tabuleiro: Verifica se Pe√ßa 1 est√° livre
    Tabuleiro-->>Jogo: Pe√ßa 1 est√° livre
    Jogo->>Jogo: Marca Pe√ßa 1 como selecionada (v1)

    Jogador->>Jogo: Clica na Pe√ßa 2
    Jogo->>Tabuleiro: Verifica se Pe√ßa 2 est√° livre
    Tabuleiro-->>Jogo: Pe√ßa 2 est√° livre
    Jogo->>Jogo: Marca Pe√ßa 2 como selecionada (v2)

    Jogo->>Jogo: Compara Pe√ßa 1 (v1) e Pe√ßa 2 (v2)
    alt Pe√ßas s√£o um par
        Jogo->>Tabuleiro: Remove Pe√ßa 1 e Pe√ßa 2
        Tabuleiro-->>Jogo: Pe√ßas removidas
        Jogo->>Jogo: Incrementa Pontua√ß√£o
        Jogo->>Jogo: Limpa sele√ß√µes (v1, v2)
    else Pe√ßas n√£o s√£o um par
        Jogo->>Jogo: Desseleciona Pe√ßa 1
        Jogo->>Jogo: Marca Pe√ßa 2 como nova Pe√ßa 1 (v1 = v2)
    end

    Note over Jogador,Jogo: O processo se repete at√© todas as pe√ßas serem removidas ou o tempo esgotar.
```

Termos T√©cnicos Explicados:

* `RenderWindow`: Uma classe da SFML que representa a janela principal do aplicativo, onde todo o conte√∫do gr√°fico √© desenhado.

* `VideoMode`: Define a resolu√ß√£o (largura e altura) da janela do jogo.

* `app.setFramerateLimit(60)`: Define o n√∫mero m√°ximo de quadros por segundo (FPS) que o jogo tentar√° renderizar. Isso ajuda a garantir que o jogo rode de forma consistente em diferentes m√°quinas.

* `Texture`: Um objeto da SFML que armazena dados de imagem na mem√≥ria da GPU, otimizado para renderiza√ß√£o r√°pida. Usado para carregar `tiles.png` e `background.png`.

* `Sprite`: Um objeto da SFML que representa uma imagem 2D que pode ser desenhada na tela. Um `Sprite` usa uma `Texture` como sua fonte de imagem.

* `Event e`: Um objeto da SFML que representa um evento do usu√°rio (como um clique do mouse, pressionar uma tecla, ou fechar a janela) ou um evento do sistema.

* `app.pollEvent(e)`: Uma fun√ß√£o que verifica se h√° eventos pendentes na fila de eventos da janela. Se houver, ela preenche o objeto `e` com os detalhes do evento e retorna `true`.

* `e.type`: Um membro do objeto `Event` que indica o tipo de evento que ocorreu (ex: `Event::Closed`, `Event::MouseButtonPressed`).

* `e.mouseButton.button`: Um membro do objeto `Event` (usado quando `e.type` √© um evento de mouse) que indica qual bot√£o do mouse foi pressionado (ex: `Mouse::Left`, `Mouse::Right`).

* `Mouse::getPosition(app)`: Retorna a posi√ß√£o atual do cursor do mouse em rela√ß√£o √† janela do aplicativo.

* `getGlobalBounds()`: Um m√©todo de objetos `sf::Text` (e outros objetos desenh√°veis) que retorna um ret√¢ngulo (`FloatRect`) que envolve o objeto na tela, √∫til para detec√ß√£o de cliques em bot√µes.

* `Clock clock`: Um objeto da SFML usado para medir o tempo. `clock.restart()` zera o cron√¥metro e `clock.getElapsedTime().asSeconds()` retorna o tempo decorrido desde o √∫ltimo `restart`.

* `std::stringstream ss`: Um objeto que permite construir strings de forma eficiente, concatenando diferentes tipos de dados (inteiros, floats, etc.) em uma √∫nica string, usada para exibir o score e o timer.

* `static_cast<int>(timer)`: Uma opera√ß√£o de type casting que converte o valor `float` de `timer` para um `int`, truncando a parte decimal. Usado para exibir o tempo em segundos inteiros.

* `app.clear()`: Limpa o conte√∫do da janela, geralmente preenchendo-a com uma cor s√≥lida (padr√£o √© preto).

* `app.draw()`: Desenha um objeto (`Sprite`, `Text`, etc.) na janela. Os objetos s√£o desenhados na ordem em que `app.draw()` √© chamado.

* `app.display()`: Atualiza a janela, mostrando todo o conte√∫do que foi desenhado desde a √∫ltima chamada a `app.clear()`.

* `srand(time(0))`: Fun√ß√£o usada para "semear" o gerador de n√∫meros pseudoaleat√≥rios. `time(0)` fornece um valor baseado no tempo atual, garantindo que a sequ√™ncia de n√∫meros aleat√≥rios seja diferente a cada execu√ß√£o do programa.

#### Funcionalidades Adicionadas:

* Menu Inicial: Permite ao jogador iniciar o jogo.

* Temporizador: Um contador regressivo de 5 minutos. Se o tempo acabar, o jogo termina.

* Pontua√ß√£o: Aumenta a cada par de pe√ßas combinado.

* Tela de Game Over: Exibida quando o tempo se esgota, mostrando a pontua√ß√£o final e a op√ß√£o de jogar novamente.

* Redimensionamento da Janela: A janela do jogo foi ampliada para acomodar o temporizador e a pontua√ß√£o sem sobrepor o tabuleiro.

* Escala do Background: A imagem de fundo agora se ajusta ao novo tamanho da janela.

## Conceitos de Programa√ß√£o Aprendidos

Ao explorar o c√≥digo do Mahjong Solitaire, voc√™ ter√° a oportunidade de aprender e aplicar diversos conceitos fundamentais em desenvolvimento de software e jogos:

* Gerenciamento de Estados (Finite State Machine - FSM): A utiliza√ß√£o do `enum GameState` e a l√≥gica condicional (`if/else if`) no loop principal demonstram como organizar o fluxo de um aplicativo em diferentes "modos" (menu, jogo, game over). Isso torna o c√≥digo mais modular, f√°cil de entender e de manter, pois cada estado tem responsabilidades bem definidas.

* Manipula√ß√£o de Arrays 3D: O tabuleiro do Mahjong √© representado por um array tridimensional (`int field[50][50][50]`). Voc√™ aprender√° a acessar, modificar e iterar sobre dados em tr√™s dimens√µes, o que √© essencial para jogos com elementos empilhados ou em camadas.

* L√≥gica de Jogo Complexa: A implementa√ß√£o das regras de Mahjong Solitaire, especialmente a fun√ß√£o `isOpen()` para determinar se uma pe√ßa est√° "livre" e a l√≥gica de gera√ß√£o de tabuleiros solucion√°veis em `resetGame()`, oferece um excelente estudo de caso sobre como traduzir regras complexas de um jogo para algoritmos de programa√ß√£o.

* Gerenciamento de Tempo (`sf::Clock`): A utiliza√ß√£o da classe `sf::Clock` para criar um temporizador de contagem regressiva (`timer`) e para controlar a taxa de atualiza√ß√£o do jogo (`app.setFramerateLimit()`) √© fundamental para garantir que a experi√™ncia de jogo seja consistente, independentemente da velocidade do hardware do usu√°rio.

* Sistema de Pontua√ß√£o e UI B√°sica (`sf::Text`): A implementa√ß√£o de um sistema de pontua√ß√£o simples e a exibi√ß√£o de informa√ß√µes na tela (score, timer, mensagens de menu/game over) usando `sf::Text` e `std::stringstream` ensinam os fundamentos da cria√ß√£o de uma interface de usu√°rio (UI) funcional e informativa.

* Gera√ß√£o Procedural (Tabuleiro Solucion√°vel): A l√≥gica em `resetGame()` que garante que o tabuleiro gerado aleatoriamente seja sempre solucion√°vel √© um exemplo de gera√ß√£o procedural de conte√∫do. Em vez de criar manualmente todos os layouts de tabuleiro, o jogo os gera dinamicamente, mas de forma inteligente para garantir a jogabilidade.

* Programa√ß√£o Orientada a Eventos: O loop `while (app.pollEvent(e))` √© o cerne da programa√ß√£o orientada a eventos, onde o programa reage a a√ß√µes do usu√°rio (cliques do mouse) e eventos do sistema (fechar janela) de forma ass√≠ncrona.

Mahjong Solitaire √© um excelente projeto para entender a aplica√ß√£o de estruturas de dados complexas e a implementa√ß√£o de regras de jogo detalhadas em um ambiente gr√°fico, preparando voc√™ para desafios maiores no desenvolvimento de jogos.



# Troubleshooting

Este guia resolve os problemas mais comuns encontrados durante a configura√ß√£o e execu√ß√£o dos 16 jogos em C++. üîß

## üö® Problemas Mais Comuns

### 1. SFML n√£o encontrado

#### Sintomas

```
CMake Error: Could not find SFML
pkg-config: sfml-all not found
```

#### Solu√ß√µes

Linux:

```BASH
# Ubuntu/Debian
sudo apt update
sudo apt install libsfml-dev

# Fedora
sudo dnf install SFML-devel

# Arch Linux
sudo pacman -S sfml

# Verificar instala√ß√£o
pkg-config --exists sfml-all && echo "OK" || echo "ERRO"
```

macOS:

```BASH
# Usando Homebrew
brew install sfml

# Se Homebrew n√£o estiver instalado
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

Windows:

* Baixe SFML do [site oficial](https://www.sfml-dev.org/download.php)

* Extraia para `C:\SFML`

* Configure vari√°vel de ambiente `SFML_ROOT=C:\SFML`

### 2. CMake vers√£o muito antiga

#### Sintomas

```
CMake Error: CMake 3.5 or higher is required. You are running version 2.8.12
```

#### Solu√ß√µes

Ubuntu/Debian:

```BASH
# Remover vers√£o antiga
sudo apt remove cmake

# Adicionar reposit√≥rio oficial
wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc | sudo apt-key add -
sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ focal main'
sudo apt update
sudo apt install cmake
```

Compilar do c√≥digo fonte:

```BASH
wget https://github.com/Kitware/CMake/releases/download/v3.25.1/cmake-3.25.1.tar.gz
tar -xzf cmake-3.25.1.tar.gz
cd cmake-3.25.1
./bootstrap --prefix=/usr/local
make -j$(nproc)
sudo make install
```

### 3. Compilador n√£o suporta C++17

#### Sintomas

```
error: 'auto' type specifier is a C++11 extension
error: range-based for loop is a C++11 extension
```

#### Solu√ß√µes

Ubuntu/Debian:

```BASH
# Instalar GCC mais recente
sudo apt install gcc-9 g++-9

# Configurar como padr√£o
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 90

# Verificar vers√£o
g++ --version
```

For√ßar compilador no CMake:

```BASH
cmake .. -DCMAKE_CXX_COMPILER=g++-9
```

### 4. Erro de linking com SFML

### 5. SQLite3 n√£o encontrado ou erro de linking

#### Sintomas

```
CMake Error: Could not find SQLite3
undefined reference to `sqlite3_open'
```

#### Solu√ß√µes

Linux:

```BASH
# Ubuntu/Debian
sudo apt update
sudo apt install libsqlite3-dev

# Fedora
sudo dnf install sqlite-devel

# Arch Linux
sudo pacman -S sqlite
```

macOS (com Homebrew):

```BASH
brew install sqlite
```

Windows (com vcpkg):

```BASH
vcpkg install sqlite3:x64-windows
```

Verificar instala√ß√£o:

```BASH
pkg-config --exists sqlite3 && echo "‚úÖ SQLite3 OK" || echo "‚ùå SQLite3 n√£o encontrado"
```

For√ßar CMake a encontrar SQLite3 (se instalado manualmente):

```BASH
cmake .. -DSQLITE3_INCLUDE_DIR=/path/to/sqlite3/include -DSQLITE3_LIBRARY=/path/to/sqlite3/lib/libsqlite3.so
```

### 6. Jogos n√£o iniciam (sem janela)

#### Sintomas

```
undefined reference to `sf::RenderWindow::RenderWindow()'
undefined reference to `sf::Texture::loadFromFile()'
```

#### Solu√ß√µes

Verificar bibliotecas SFML:

```BASH
# Linux
ldconfig -p | grep sfml
find /usr -name "*sfml*" 2>/dev/null

# Verificar pkg-config
pkg-config --cflags --libs sfml-all
```

Reinstalar SFML:

```BASH
# Ubuntu/Debian
sudo apt remove libsfml-dev
sudo apt autoremove
sudo apt install libsfml-dev

# Verificar novamente
pkg-config --modversion sfml-all
```

### 6. Jogos n√£o iniciam (sem janela)

#### Sintomas

* Execut√°vel compila mas n√£o abre janela

* Erro "Failed to create OpenGL context"

* Tela preta

#### Solu√ß√µes

Verificar drivers gr√°ficos:

```BASH
# Linux - informa√ß√µes da GPU
lspci | grep -i vga
glxinfo | grep "OpenGL version"

# Instalar drivers se necess√°rio
# NVIDIA:
sudo apt install nvidia-driver-470

# AMD:
sudo apt install mesa-vulkan-drivers

# Intel:
sudo apt install intel-media-va-driver
```

Testar OpenGL:

```BASH
# Instalar mesa-utils
sudo apt install mesa-utils

# Testar OpenGL
glxgears
```

Executar com debug:

```BASH
# Executar com informa√ß√µes de debug
DISPLAY=:0 ./games/tetris/tetris
```

### 7. Assets n√£o encontrados

#### Sintomas

```
Failed to load image: images/tiles.png
Failed to load font: fonts/arial.ttf
```

#### Solu√ß√µes

Verificar estrutura de arquivos:

```BASH
# Ver se assets foram copiados
ls build/games/tetris/
ls build/games/tetris/images/

# Se n√£o existirem, recompilar
make clean
make tetris
```

Executar do diret√≥rio correto:

```BASH
# CORRETO - executar de dentro do diret√≥rio do jogo
cd build/games/tetris
./tetris

# INCORRETO - executar de outro lugar
cd build
./games/tetris/tetris  # Pode n√£o encontrar assets
```

### 8. Erro de permiss√£o

#### Sintomas

```
Permission denied
make: *** [CMakeFiles/tetris.dir/all] Error 2
```

#### Solu√ß√µes

Corrigir permiss√µes:

```BASH
# Dar permiss√£o de execu√ß√£o aos scripts
chmod +x setup.sh
chmod +x *.sh

# Corrigir permiss√µes do projeto
chmod -R 755 .
```

Problemas de sudo:

```BASH
# Se instalou com sudo, corrigir ownership
sudo chown -R $USER:$USER ~/.cmake
sudo chown -R $USER:$USER ./build
```

## üêõ Problemas Espec√≠ficos por Sistema

### Ubuntu/Debian Espec√≠ficos

#### Erro: "Package sfml-all was not found"

```BASH
# Atualizar lista de pacotes
sudo apt update

# Verificar se universe repository est√° habilitado
sudo add-apt-repository universe
sudo apt update

# Instalar SFML
sudo apt install libsfml-dev
```

#### Erro: "Unable to locate package"

```BASH
# Verificar vers√£o do Ubuntu
lsb_release -a

# Ubuntu muito antigo - usar PPA
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt update
```

### Fedora/CentOS Espec√≠ficos

#### Erro: "No package SFML-devel available"

```BASH
# Fedora - habilitar RPM Fusion
sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm

# CentOS - habilitar EPEL
sudo dnf install epel-release
```

### macOS Espec√≠ficos

#### Erro: "xcrun: error: invalid active developer path"

```BASH
# Instalar Command Line Tools
xcode-select --install

# Se j√° instalado, resetar
sudo xcode-select --reset
```

#### Homebrew n√£o funciona

```BASH
# Reinstalar Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Adicionar ao PATH
echo 'export PATH="/opt/homebrew/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc
```

### Windows Espec√≠ficos

#### Visual Studio n√£o encontra SFML

```CMAKE
# No CMakeLists.txt, adicionar:
set(SFML_ROOT "C:/SFML")
find_package(SFML 2.5 COMPONENTS system window graphics audio REQUIRED)
```

#### MinGW problemas de linking

```BASH
# Usar bibliotecas est√°ticas
cmake .. -DSFML_STATIC_LIBRARIES=TRUE
```

## üîç Ferramentas de Diagn√≥stico

### Script de Diagn√≥stico Completo

```BASH
# Criar script de diagn√≥stico
cat > diagnose.sh << 'EOF'
#!/bin/bash

echo "üîç Diagn√≥stico do Sistema - 16 Games in C++"
echo "============================================="

# Sistema operacional
echo "üì± Sistema:"
uname -a
echo ""

# Compilador
echo "üîß Compilador:"
if command -v g++ &> /dev/null; then
    g++ --version | head -1
    echo "‚úÖ G++ dispon√≠vel"
else
    echo "‚ùå G++ n√£o encontrado"
fi

if command -v clang++ &> /dev/null; then
    clang++ --version | head -1
    echo "‚úÖ Clang++ dispon√≠vel"
else
    echo "‚ùå Clang++ n√£o encontrado"
fi
echo ""

# CMake
echo "üèóÔ∏è CMake:"
if command -v cmake &> /dev/null; then
    cmake --version | head -1
    echo "‚úÖ CMake dispon√≠vel"
else
    echo "‚ùå CMake n√£o encontrado"
fi
echo ""

# SFML
echo "üéÆ SFML:"
if pkg-config --exists sfml-all; then
    echo "‚úÖ SFML $(pkg-config --modversion sfml-all) encontrado"
    echo "üìç Flags: $(pkg-config --cflags --libs sfml-all)"
else
    echo "‚ùå SFML n√£o encontrado via pkg-config"
    
    # Procurar manualmente
    if find /usr -name "*sfml*" 2>/dev/null | head -5; then
        echo "üí° SFML pode estar instalado mas n√£o configurado para pkg-config"
    fi
fi
echo ""

# OpenGL
echo "üñ•Ô∏è OpenGL:"
if command -v glxinfo &> /dev/null; then
    echo "OpenGL: $(glxinfo | grep "OpenGL version" | cut -d':' -f2)"
    echo "‚úÖ OpenGL dispon√≠vel"
else
    echo "‚ö†Ô∏è glxinfo n√£o dispon√≠vel (instale mesa-utils)"
fi
echo ""

# Espa√ßo em disco
echo "üíæ Espa√ßo em disco:"
df -h . | tail -1
echo ""

# Resumo
echo "üìã Resumo:"
echo "=========="

issues=0

if ! command -v g++ &> /dev/null && ! command -v clang++ &> /dev/null; then
    echo "‚ùå Nenhum compilador C++ encontrado"
    ((issues++))
fi

if ! command -v cmake &> /dev/null; then
    echo "‚ùå CMake n√£o encontrado"
    ((issues++))
fi

if ! pkg-config --exists sfml-all; then
    echo "‚ùå SFML n√£o encontrado"
    ((issues++))
fi

if [ $issues -eq 0 ]; then
    echo "üéâ Sistema parece estar configurado corretamente!"
    echo "üí° Se ainda h√° problemas, execute: ./setup.sh"
else
    echo "‚ö†Ô∏è $issues problema(s) encontrado(s)"
    echo "üí° Consulte a documenta√ß√£o para resolver os problemas acima"
fi
EOF

chmod +x diagnose.sh
./diagnose.sh
```

### Verifica√ß√£o de Build

```BASH
# Script para verificar build espec√≠fico
cat > check_build.sh << 'EOF'
#!/bin/bash

if [ ! -d "build" ]; then
    echo "‚ùå Diret√≥rio build n√£o existe"
    echo "Execute: mkdir build && cd build && cmake .."
    exit 1
fi

cd build

if [ ! -f "CMakeCache.txt" ]; then
    echo "‚ùå CMake n√£o foi configurado"
    echo "Execute: cmake .."
    exit 1
fi

echo "‚úÖ Build configurado"
echo "üìÅ Jogos compilados:"

count=0
for game_dir in games/*/; do
    if [ -d "$game_dir" ]; then
        game_name=$(basename "$game_dir")
        if [ -f "$game_dir/$game_name" ]; then
            echo "  ‚úÖ $game_name"
            ((count++))
        else
            echo "  ‚ùå $game_name (n√£o compilado)"
        fi
    fi
done

echo ""
echo "üìä Total: $count jogos compilados"

if [ $count -eq 0 ]; then
    echo "üí° Execute: make all_games"
fi
EOF

chmod +x check_build.sh
./check_build.sh
```

## üÜò √öltimos Recursos

### Resetar Ambiente Completamente

```BASH
# Script de reset total
cat > reset_environment.sh << 'EOF'
#!/bin/bash

echo "üö® RESETANDO AMBIENTE COMPLETAMENTE"
echo "===================================="

# Fazer backup se necess√°rio
if [ -d "build" ]; then
    echo "üì¶ Fazendo backup do build atual..."
    mv build build_backup_$(date +%Y%m%d_%H%M%S)
fi

# Limpar completamente
echo "üßπ Limpando arquivos tempor√°rios..."
rm -rf build
rm -rf .cache
find . -name "*.o" -delete
find . -name "*.cmake" -delete 2>/dev/null

# Recriar build
echo "üìÅ Recriando estrutura..."
mkdir build
cd build

# Configurar do zero
echo "‚öôÔ∏è Configurando CMake do zero..."
cmake .. -DCMAKE_BUILD_TYPE=Debug

# Compilar teste
echo "üî® Testando compila√ß√£o..."
make tetris

if [ $? -eq 0 ]; then
    echo "‚úÖ Reset conclu√≠do com sucesso!"
    echo "üéÆ Teste: make run_tetris"
else
    echo "‚ùå Ainda h√° problemas ap√≥s reset"
    echo "üí° Execute o diagn√≥stico: ../diagnose.sh"
fi
EOF

chmod +x reset_environment.sh
```

### Suporte da Comunidade

Se nenhuma solu√ß√£o funcionou:

1. Execute o diagn√≥stico completo: `./diagnose.sh`

2. Tente o reset total: `./reset_environment.sh`

3. Procure ajuda online:

* Stack Overflow: tag `sfml` + `cmake`

* Reddit: r/cpp, r/gamedev

* Discord: servidores de C++ e game dev

4. Documente seu problema:

* Sistema operacional e vers√£o

* Sa√≠da do script de diagn√≥stico

* Mensagens de erro completas

* Passos que j√° tentou

## üéØ Preven√ß√£o de Problemas

### Manuten√ß√£o Regular

```BASH
# Atualizar depend√™ncias mensalmente
sudo apt update && sudo apt upgrade  # Linux
brew update && brew upgrade          # macOS

# Limpar builds antigos
find . -name "build*" -type d -mtime +30 -exec rm -rf {} \;
```

### Backup de Configura√ß√£o

```BASH
# Backup da configura√ß√£o funcionando
tar -czf working_config_$(date +%Y%m%d).tar.gz \
    CMakeLists.txt setup.sh build/CMakeCache.txt
```

Lembre-se: A maioria dos problemas pode ser resolvida com `./setup.sh`. Em caso de d√∫vida, sempre comece pelo diagn√≥stico autom√°tico!



