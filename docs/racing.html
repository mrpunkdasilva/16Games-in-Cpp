<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-08-28T18:41:49.694048768"><title>Racing Game Top-Down | 16 Games in C++</title><script type="application/json" id="virtual-toc-data">[{"id":"vis-o-geral-o-que-vamos-construir","level":0,"title":"Visão Geral: O Que Vamos Construir?","anchor":"#vis-o-geral-o-que-vamos-construir"},{"id":"passo-1-a-estrutura-fundamental-de-um-jogo","level":0,"title":"Passo 1: A Estrutura Fundamental de um Jogo","anchor":"#passo-1-a-estrutura-fundamental-de-um-jogo"},{"id":"passo-2-construindo-o-mundo-do-jogo","level":0,"title":"Passo 2: Construindo o Mundo do Jogo","anchor":"#passo-2-construindo-o-mundo-do-jogo"},{"id":"passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros","level":0,"title":"Passo 3: As Mecânicas do Jogo - Dando Vida aos Carros","anchor":"#passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros"},{"id":"passo-4-renderiza-o-e-interface","level":0,"title":"Passo 4: Renderização e Interface","anchor":"#passo-4-renderiza-o-e-interface"},{"id":"conclus-o-o-que-voc-aprendeu","level":0,"title":"Conclusão: O Que Você Aprendeu?","anchor":"#conclus-o-o-que-voc-aprendeu"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="images/logo.svg"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Racing Game Top-Down | 16 Games in C++"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="16 Games in C++ Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/racing.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Racing Game Top-Down | 16 Games in C++"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/racing.html#webpage",
    "url": "writerside-documentation/racing.html",
    "name": "Racing Game Top-Down | 16 Games in C++",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "16 Games in C++ Help"
}</script><!-- End Schema.org --></head><body data-id="racing" data-main-title="Racing Game Top-Down" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="jogos.md|Jogos"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>16 Games in C++  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="racing" id="racing.md">Racing Game Top-Down</h1><section class="chapter"><h2 id="vis-o-geral-o-que-vamos-construir" data-toc="vis-o-geral-o-que-vamos-construir">Vis&atilde;o Geral: O Que Vamos Construir?</h2><p id="m1ofyp_9">Nosso objetivo &eacute; criar um jogo de corrida onde voc&ecirc; controla um carro em uma pista e compete contra outros quatro carros controlados por uma Intelig&ecirc;ncia Artificial (IA) b&aacute;sica.</p><p id="m1ofyp_10"><span class="control" id="m1ofyp_13">Recursos Principais:</span></p><ol class="list _decimal" id="m1ofyp_11" type="1"><li class="list__item" id="m1ofyp_14"><p id="m1ofyp_19"><span class="control" id="m1ofyp_20">Controle do Jogador:</span> Voc&ecirc; poder&aacute; acelerar, frear e virar seu carro.</p></li><li class="list__item" id="m1ofyp_15"><p id="m1ofyp_21"><span class="control" id="m1ofyp_22">Oponentes de IA:</span> Outros carros navegar&atilde;o pela pista de forma aut&ocirc;noma.</p></li><li class="list__item" id="m1ofyp_16"><p id="m1ofyp_23"><span class="control" id="m1ofyp_24">Pista com Checkpoints:</span> A pista n&atilde;o &eacute; apenas uma imagem; ela &eacute; definida por uma s&eacute;rie de pontos de verifica&ccedil;&atilde;o (checkpoints) que os carros devem seguir.</p></li><li class="list__item" id="m1ofyp_17"><p id="m1ofyp_25"><span class="control" id="m1ofyp_26">C&acirc;mera Din&acirc;mica:</span> A c&acirc;mera seguir&aacute; o seu carro, mantendo a a&ccedil;&atilde;o sempre no centro da tela.</p></li><li class="list__item" id="m1ofyp_18"><p id="m1ofyp_27"><span class="control" id="m1ofyp_28">Interface de Usu&aacute;rio (UI):</span> Mostraremos informa&ccedil;&otilde;es essenciais como sua velocidade, o checkpoint atual e o n&uacute;mero de voltas completadas.</p></li></ol></section><section class="chapter"><h2 id="passo-1-a-estrutura-fundamental-de-um-jogo" data-toc="passo-1-a-estrutura-fundamental-de-um-jogo">Passo 1: A Estrutura Fundamental de um Jogo</h2><p id="m1ofyp_29">Todo jogo, n&atilde;o importa qu&atilde;o complexo, &eacute; constru&iacute;do sobre alguns pilares. Vamos come&ccedil;ar com eles.</p><section class="chapter"><h3 id="o-game-loop-la-o-do-jogo" data-toc="o-game-loop-la-o-do-jogo">O Game Loop (La&ccedil;o do Jogo)</h3><p id="m1ofyp_32">O cora&ccedil;&atilde;o de qualquer jogo &eacute; o <span class="control" id="m1ofyp_36">game loop</span>. &Eacute; um la&ccedil;o <code class="code" id="m1ofyp_37">while</code> que continua executando enquanto a janela do jogo estiver aberta. Em cada &quot;tick&quot; ou itera&ccedil;&atilde;o desse la&ccedil;o, o jogo faz tr&ecirc;s coisas:</p><ol class="list _decimal" id="m1ofyp_33" type="1"><li class="list__item" id="m1ofyp_38"><p id="m1ofyp_41"><span class="control" id="m1ofyp_42">Processa Entradas:</span> Verifica se o jogador pressionou alguma tecla, clicou o mouse ou fechou a janela.</p></li><li class="list__item" id="m1ofyp_39"><p id="m1ofyp_43"><span class="control" id="m1ofyp_44">Atualiza a L&oacute;gica:</span> Move os personagens, verifica colis&otilde;es, atualiza a pontua&ccedil;&atilde;o, etc.</p></li><li class="list__item" id="m1ofyp_40"><p id="m1ofyp_45"><span class="control" id="m1ofyp_46">Renderiza a Tela:</span> Desenha tudo na tela na sua nova posi&ccedil;&atilde;o.</p></li></ol><p id="m1ofyp_34">No nosso c&oacute;digo, ele se parece com isto:</p><div class="code-block" data-lang="cpp">
while (app.isOpen()) {
    // 1. Processar Entradas (Eventos)
    // ...

    // 2. Atualizar a Lógica do Jogo
    // ...

    // 3. Renderizar a Tela
    // ...
}
</div></section><section class="chapter"><h3 id="gerenciamento-de-estado-gamestate" data-toc="gerenciamento-de-estado-gamestate">Gerenciamento de Estado (<code class="code" id="m1ofyp_53">GameState</code>)</h3><p id="m1ofyp_48">Nosso jogo tem duas telas principais: o <span class="control" id="m1ofyp_54">Menu Principal</span> e a <span class="control" id="m1ofyp_55">Corrida</span> em si. N&atilde;o podemos ter a l&oacute;gica da corrida rodando enquanto estamos no menu. Para gerenciar isso, usamos uma <span class="control" id="m1ofyp_56">m&aacute;quina de estados</span>. &Eacute; mais simples do que parece. Usamos uma <code class="code" id="m1ofyp_57">enum</code> para definir os poss&iacute;veis estados:</p><div class="code-block" data-lang="cpp">
enum GameState { MENU, PLAYING };
GameState gameState = MENU; // O jogo sempre começa no estado MENU
</div><p id="m1ofyp_50">Dentro do nosso game loop, podemos verificar qual &eacute; o estado atual e executar apenas a l&oacute;gica relevante:</p><div class="code-block" data-lang="cpp">
if (gameState == MENU) {
    // Lógica e desenho do menu
} else if (gameState == PLAYING) {
    // Lógica e desenho da corrida
}
</div></section></section><section class="chapter"><h2 id="passo-2-construindo-o-mundo-do-jogo" data-toc="passo-2-construindo-o-mundo-do-jogo">Passo 2: Construindo o Mundo do Jogo</h2><p id="m1ofyp_58">Agora vamos definir os elementos que comp&otilde;em nosso mundo de corrida.</p><section class="chapter"><h3 id="a-janela-e-os-recursos-gr-ficos" data-toc="a-janela-e-os-recursos-gr-ficos">A Janela e os Recursos Gr&aacute;ficos</h3><p id="m1ofyp_62">Primeiro, criamos a janela do jogo com um tamanho fixo e um t&iacute;tulo:</p><div class="code-block" data-lang="cpp">
RenderWindow app(VideoMode(640, 480), &quot;Car Racing Game!&quot;);
app.setFramerateLimit(60); // Limita o jogo a 60 quadros por segundo (FPS)
</div><p id="m1ofyp_64">Limitar o FPS &eacute; importante para que o jogo n&atilde;o rode r&aacute;pido demais em computadores potentes e para garantir uma experi&ecirc;ncia consistente.</p><p id="m1ofyp_65">Em seguida, carregamos nossos recursos (imagens e fontes) usando as classes <code class="code" id="m1ofyp_67">Texture</code> e <code class="code" id="m1ofyp_68">Font</code> do SFML. Uma <code class="code" id="m1ofyp_69">Texture</code> &eacute; a imagem em si, carregada na mem&oacute;ria da placa de v&iacute;deo. Um <code class="code" id="m1ofyp_70">Sprite</code> &eacute; um objeto que pode ser desenhado na tela e que usa uma <code class="code" id="m1ofyp_71">Texture</code>.</p><div class="code-block" data-lang="cpp">
Texture t1, t2;
t1.loadFromFile(&quot;images/background.png&quot;);
t2.loadFromFile(&quot;images/car.png&quot;);

Sprite sBackground(t1), sCar(t2);
</div></section><section class="chapter"><h3 id="a-pista-de-corrida-points" data-toc="a-pista-de-corrida-points">A Pista de Corrida (<code class="code" id="m1ofyp_76">points</code>)</h3><p id="m1ofyp_73">Como a IA saber&aacute; para onde ir? N&oacute;s definimos a pista usando uma s&eacute;rie de <span class="control" id="m1ofyp_77">checkpoints</span>. Pense neles como pontos invis&iacute;veis que formam o caminho ideal da corrida. Armazenamos esses pontos em um array 2D:</p><div class="code-block" data-lang="cpp">
const int num = 8; // Temos 8 checkpoints
int points[num][2] = {
    {300, 610},
    {1270, 430},
    // ... e assim por diante
};
</div><p id="m1ofyp_75">A IA simplesmente tentar&aacute; ir do checkpoint 0 para o 1, depois para o 2, e assim por diante, em um ciclo. Esta &eacute; uma maneira muito simples e eficaz de criar um comportamento de seguimento de caminho.</p></section><section class="chapter"><h3 id="a-planta-baixa-do-carro-a-estrutura-car" data-toc="a-planta-baixa-do-carro-a-estrutura-car">A Planta Baixa do Carro (A Estrutura <code class="code" id="m1ofyp_83">Car</code>)</h3><p id="m1ofyp_79">Para representar cada carro no jogo (tanto o jogador quanto a IA), usamos uma <code class="code" id="m1ofyp_84">struct</code>. Uma <code class="code" id="m1ofyp_85">struct</code> &eacute; como uma planta baixa que agrupa v&aacute;rias vari&aacute;veis relacionadas em um &uacute;nico tipo de dado.</p><div class="code-block" data-lang="cpp">
struct Car {
    float x, y, speed, angle;
    int n; // Índice do próximo checkpoint alvo
    int lastCheckpoint;

    // Construtor: valores iniciais quando um novo Car é criado
    Car() {
        speed = 2;
        angle = 0;
        n = 0;
        lastCheckpoint = 0;
    }

    void move();
    void findTarget();
};
</div><ul class="list _bullet" id="m1ofyp_81"><li class="list__item" id="m1ofyp_86"><p id="m1ofyp_91"><code class="code" id="m1ofyp_92">x</code>, <code class="code" id="m1ofyp_93">y</code>: A posi&ccedil;&atilde;o exata do carro no mundo do jogo (coordenadas de mundo).</p></li><li class="list__item" id="m1ofyp_87"><p id="m1ofyp_94"><code class="code" id="m1ofyp_95">speed</code>: A velocidade atual.</p></li><li class="list__item" id="m1ofyp_88"><p id="m1ofyp_96"><code class="code" id="m1ofyp_97">angle</code>: O &acirc;ngulo para o qual o carro est&aacute; virado. <span class="control" id="m1ofyp_98">Importante:</span> Em programa&ccedil;&atilde;o de jogos e matem&aacute;tica, &acirc;ngulos s&atilde;o quase sempre medidos em <span class="control" id="m1ofyp_99">radianos</span>, n&atilde;o em graus.</p></li><li class="list__item" id="m1ofyp_89"><p id="m1ofyp_100"><code class="code" id="m1ofyp_101">n</code>: O &iacute;ndice do pr&oacute;ximo checkpoint que este carro est&aacute; perseguindo. Para o <code class="code" id="m1ofyp_102">car[0]</code> (jogador), isso nos diz em que parte da pista ele est&aacute;.</p></li><li class="list__item" id="m1ofyp_90"><p id="m1ofyp_103"><code class="code" id="m1ofyp_104">lastCheckpoint</code>: O &uacute;ltimo checkpoint que o carro passou. Isso &eacute; crucial para a nossa l&oacute;gica de contagem de voltas.</p></li></ul></section></section><section class="chapter"><h2 id="passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros" data-toc="passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros">Passo 3: As Mec&acirc;nicas do Jogo - Dando Vida aos Carros</h2><p id="m1ofyp_105">Esta &eacute; a parte mais emocionante, onde implementamos a f&iacute;sica, a IA e os controles.</p><section class="chapter"><h3 id="controle-e-f-sica-do-jogador" data-toc="controle-e-f-sica-do-jogador">Controle e F&iacute;sica do Jogador</h3><p id="m1ofyp_110">O carro do jogador (<code class="code" id="m1ofyp_114">car[0]</code>) &eacute; especial. Ele n&atilde;o usa a IA. Em vez disso, ele responde diretamente &agrave;s suas teclas.</p><div class="code-block" data-lang="cpp">
// Detecta quais teclas estão pressionadas
bool Up = Keyboard::isKeyPressed(Keyboard::Up);
// ...

// 1. Aceleração e Desaceleração
if (Up &amp;&amp; speed &lt; maxSpeed) {
    if (speed &lt; 0) speed += dec; // Se estava de ré, freia
    else speed += acc;           // Se estava indo para frente, acelera
}
// ...

// 2. Atrito (Fricção)
if (!Up &amp;&amp; !Down) {
    if (speed - dec &gt; 0) speed -= dec; // Perde velocidade gradualmente
    else if (speed + dec &lt; 0) speed += dec;
    else speed = 0; // Para completamente
}

// 3. Virar o Carro
if (Right &amp;&amp; speed != 0) angle += turnSpeed * speed / maxSpeed;
</div><p id="m1ofyp_112"><span class="control" id="m1ofyp_115">An&aacute;lise detalhada:</span></p><ul class="list _bullet" id="m1ofyp_113"><li class="list__item" id="m1ofyp_116"><p id="m1ofyp_118"><code class="code" id="m1ofyp_119">acc</code> (acelera&ccedil;&atilde;o) e <code class="code" id="m1ofyp_120">dec</code> (desacelera&ccedil;&atilde;o) s&atilde;o pequenas constantes que controlam qu&atilde;o r&aacute;pido o carro ganha ou perde velocidade. Isso cria uma sensa&ccedil;&atilde;o de <span class="control" id="m1ofyp_121">in&eacute;rcia</span>.</p></li><li class="list__item" id="m1ofyp_117"><p id="m1ofyp_122">A l&oacute;gica de virar &eacute; interessante: <code class="code" id="m1ofyp_123">turnSpeed * speed / maxSpeed</code>. Isso faz com que o carro vire mais lentamente em baixas velocidades e mais rapidamente em altas velocidades, o que &eacute; o oposto do realismo, mas torna o jogo mais divertido e control&aacute;vel no estilo arcade.</p></li></ul></section><section class="chapter"><h3 id="movimento-f-sico-move" data-toc="movimento-f-sico-move">Movimento F&iacute;sico (<code class="code" id="m1ofyp_129">move</code>)</h3><p id="m1ofyp_125">Uma vez que a velocidade e o &acirc;ngulo s&atilde;o definidos, a fun&ccedil;&atilde;o <code class="code" id="m1ofyp_130">move</code> atualiza a posi&ccedil;&atilde;o do carro.</p><div class="code-block" data-lang="cpp">
void move() {
    x += sin(angle) * speed;
    y -= cos(angle) * speed;
}
</div><p id="m1ofyp_127">Isto &eacute; trigonometria. <code class="code" id="m1ofyp_131">sin(angle)</code> e <code class="code" id="m1ofyp_132">cos(angle)</code> decomp&otilde;em o movimento diagonal em seus componentes horizontal (X) e vertical (Y).</p><ul class="list _bullet" id="m1ofyp_128"><li class="list__item" id="m1ofyp_133"><p id="m1ofyp_134"><span class="control" id="m1ofyp_135">Por que <code class="code" id="m1ofyp_137">y -= ...</code>?</span> Em muitos sistemas gr&aacute;ficos, incluindo o do SFML, a coordenada (0,0) fica no canto superior esquerdo. O eixo Y aumenta para <span class="control" id="m1ofyp_136">baixo</span>. No entanto, matematicamente, o eixo Y aumenta para cima. Subtrair o cosseno corrige essa diferen&ccedil;a, fazendo o carro se mover &quot;para cima&quot; na tela quando o &acirc;ngulo &eacute; 0.</p></li></ul></section><section class="chapter"><h3 id="a-intelig-ncia-artificial-findtarget" data-toc="a-intelig-ncia-artificial-findtarget">A Intelig&ecirc;ncia Artificial (<code class="code" id="m1ofyp_143">findTarget</code>)</h3><p id="m1ofyp_139">Esta &eacute; a fun&ccedil;&atilde;o que faz os carros oponentes parecerem vivos. O objetivo deles &eacute; simples: virar-se para o pr&oacute;ximo checkpoint e avan&ccedil;ar.</p><div class="code-block" data-lang="cpp">
void findTarget() {
    // 1. Pega as coordenadas do checkpoint alvo
    float tx = points[n][0];
    float ty = points[n][1];

    // 2. Calcula o ângulo exato do carro até o alvo
    float beta = angle - atan2(tx - x, -ty + y);

    // 3. Vira o carro na direção certa
    if (sin(beta) &lt; 0) angle += 0.005 * speed;
    else angle -= 0.005 * speed;

    // 4. Verifica se chegou ao alvo
    if ((x - tx) * (x - tx) + (y - ty) * (y - ty) &lt; 25 * 25) {
        lastCheckpoint = n;
        n = (n + 1) % num; // Passa para o próximo checkpoint
    }
}
</div><p id="m1ofyp_141"><span class="control" id="m1ofyp_144">An&aacute;lise detalhada:</span></p><ul class="list _bullet" id="m1ofyp_142"><li class="list__item" id="m1ofyp_145"><p id="m1ofyp_150"><code class="code" id="m1ofyp_151">atan2(delta_x, -delta_y)</code>: Esta fun&ccedil;&atilde;o &eacute; m&aacute;gica. Ela nos d&aacute; o &acirc;ngulo exato de um ponto a outro. Usamos <code class="code" id="m1ofyp_152">-ty + y</code> para o componente <code class="code" id="m1ofyp_153">y</code> para corrigir a invers&atilde;o do eixo Y que mencionamos antes.</p></li><li class="list__item" id="m1ofyp_146"><p id="m1ofyp_154"><code class="code" id="m1ofyp_155">beta</code>: &Eacute; a diferen&ccedil;a entre o &acirc;ngulo atual do carro e o &acirc;ngulo que ele <span class="emphasis" id="m1ofyp_156">deveria</span> ter.</p></li><li class="list__item" id="m1ofyp_147"><p id="m1ofyp_157"><code class="code" id="m1ofyp_158">if (sin(beta) &lt; 0)</code>: Este &eacute; um truque inteligente. O sinal do seno de <code class="code" id="m1ofyp_159">beta</code> nos diz se o alvo est&aacute; &agrave; esquerda ou &agrave; direita da dire&ccedil;&atilde;o atual do carro. Se for negativo, viramos em uma dire&ccedil;&atilde;o; se for positivo, na outra. Isso garante que o carro sempre tome o caminho mais curto para se alinhar com o alvo.</p></li><li class="list__item" id="m1ofyp_148"><p id="m1ofyp_160"><span class="control" id="m1ofyp_161">Verifica&ccedil;&atilde;o de Dist&acirc;ncia:</span> A linha <code class="code" id="m1ofyp_162">(x-tx)*(x-tx) + ...</code> &eacute; a f&oacute;rmula da dist&acirc;ncia ao quadrado (<code class="code" id="m1ofyp_163">d&sup2; = dx&sup2; + dy&sup2;</code>). Usamos a dist&acirc;ncia ao quadrado para evitar o c&aacute;lculo da raiz quadrada (<code class="code" id="m1ofyp_164">sqrt</code>), que &eacute; uma opera&ccedil;&atilde;o computacionalmente &quot;cara&quot;. Como s&oacute; queremos saber se a dist&acirc;ncia &eacute; <span class="emphasis" id="m1ofyp_165">menor</span> que um valor, comparar os quadrados funciona perfeitamente e &eacute; mais r&aacute;pido.</p></li><li class="list__item" id="m1ofyp_149"><p id="m1ofyp_166"><code class="code" id="m1ofyp_167">n = (n + 1) % num;</code>: O operador m&oacute;dulo (<code class="code" id="m1ofyp_168">%</code>) &eacute; perfeito para criar ciclos. Quando <code class="code" id="m1ofyp_169">n</code> chega ao &uacute;ltimo checkpoint, <code class="code" id="m1ofyp_170">(n + 1)</code> se torna <code class="code" id="m1ofyp_171">num</code>, e <code class="code" id="m1ofyp_172">num % num</code> &eacute; <code class="code" id="m1ofyp_173">0</code>. Isso faz a IA voltar ao primeiro checkpoint e continuar o ciclo.</p></li></ul></section><section class="chapter"><h3 id="sistema-de-colis-o" data-toc="sistema-de-colis-o">Sistema de Colis&atilde;o</h3><p id="m1ofyp_174">A colis&atilde;o &eacute; simples: se dois carros est&atilde;o muito pr&oacute;ximos, n&oacute;s os empurramos para longe um do outro.</p><div class="code-block" data-lang="cpp">
// Loop dentro de loop para comparar cada carro com todos os outros
for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt; N; j++) {
        // ...
        // Calcula a distância ao quadrado
        while (dx * dx + dy * dy &lt; 4 * R * R) {
            // Empurra os carros um pouco para longe um do outro
            car[i].x += dx / 10.0;
            car[j].x -= dx / 10.0;
            // ... e atualiza a distância para a próxima verificação do while
        }
    }
}
</div><p id="m1ofyp_176">Este m&eacute;todo &eacute; chamado de &quot;resolu&ccedil;&atilde;o por impulso&quot; e &eacute; muito b&aacute;sico. Ele funciona, mas pode fazer os carros tremerem um pouco quando colidem. Para um jogo simples, &eacute; suficiente.</p></section></section><section class="chapter"><h2 id="passo-4-renderiza-o-e-interface" data-toc="passo-4-renderiza-o-e-interface">Passo 4: Renderiza&ccedil;&atilde;o e Interface</h2><p id="m1ofyp_178">Agora que nossa l&oacute;gica est&aacute; pronta, vamos mostrar tudo na tela.</p><section class="chapter"><h3 id="a-c-mera-que-segue-o-jogador" data-toc="a-c-mera-que-segue-o-jogador">A C&acirc;mera que Segue o Jogador</h3><p id="m1ofyp_182">N&atilde;o movemos a c&acirc;mera. Em vez disso, movemos o <span class="control" id="m1ofyp_185">mundo inteiro</span> na dire&ccedil;&atilde;o oposta.</p><ol class="list _decimal" id="m1ofyp_183" type="1"><li class="list__item" id="m1ofyp_186"><p id="m1ofyp_188">Calculamos um &quot;deslocamento&quot; (<code class="code" id="m1ofyp_190">offset</code>) para manter o carro do jogador (<code class="code" id="m1ofyp_191">car[0]</code>) no centro da tela.</p><div class="code-block" data-lang="cpp">
int offsetX = 0, offsetY = 0;
if (car[0].x &gt; 320) offsetX = car[0].x - 320;
if (car[0].y &gt; 240) offsetY = car[0].y - 240;
</div></li><li class="list__item" id="m1ofyp_187"><p id="m1ofyp_192">Ao desenhar qualquer objeto do mundo (o fundo, os carros), subtra&iacute;mos esse offset de sua posi&ccedil;&atilde;o.</p><div class="code-block" data-lang="cpp">
sBackground.setPosition(-offsetX, -offsetY);
sCar.setPosition(car[i].x - offsetX, car[i].y - offsetY);
</div></li></ol><p id="m1ofyp_184">O resultado &eacute; que o jogador parece ficar parado no centro enquanto o mundo se move ao seu redor.</p></section><section class="chapter"><h3 id="a-interface-do-usu-rio-ui" data-toc="a-interface-do-usu-rio-ui">A Interface do Usu&aacute;rio (UI)</h3><p id="m1ofyp_194">A UI (texto de velocidade, voltas, etc.) &eacute; desenhada por &uacute;ltimo e <span class="control" id="m1ofyp_196">sem</span> o deslocamento da c&acirc;mera. Isso garante que ela permane&ccedil;a fixa na tela, como um painel de controle.</p><div class="code-block" data-lang="cpp">
// Converte a velocidade (float) para uma string
std::string speedStr = &quot;Speed: &quot; + std::to_string(static_cast&lt;int&gt;(car[0].speed * 10));
speedText.setString(speedStr);
app.draw(speedText); // Desenhado em coordenadas de tela fixas
</div></section><section class="chapter"><h3 id="l-gica-de-contagem-de-voltas" data-toc="l-gica-de-contagem-de-voltas">L&oacute;gica de Contagem de Voltas</h3><p id="m1ofyp_197">Esta &eacute; uma das partes mais importantes da l&oacute;gica de um jogo de corrida.</p><div class="code-block" data-lang="cpp">
if (car[0].n == 0 &amp;&amp; car[0].lastCheckpoint == num - 1) {
    laps++;
    car[0].lastCheckpoint = 0; // Reseta para a próxima volta
}
</div><p id="m1ofyp_199">Vamos traduzir esta condi&ccedil;&atilde;o:</p><ul class="list _bullet" id="m1ofyp_200"><li class="list__item" id="m1ofyp_203"><p id="m1ofyp_205"><code class="code" id="m1ofyp_206">car[0].n == 0</code>: O pr&oacute;ximo alvo do meu carro &eacute; o checkpoint inicial (o n&uacute;mero 0).</p></li><li class="list__item" id="m1ofyp_204"><p id="m1ofyp_207"><code class="code" id="m1ofyp_208">car[0].lastCheckpoint == num - 1</code>: O &uacute;ltimo checkpoint que eu passei foi o &uacute;ltimo da pista.</p></li></ul><p id="m1ofyp_201">Quando ambas as condi&ccedil;&otilde;es s&atilde;o verdadeiras, significa que o jogador acabou de cruzar a linha de chegada, completando uma volta. Ent&atilde;o, incrementamos <code class="code" id="m1ofyp_209">laps</code> e resetamos <code class="code" id="m1ofyp_210">lastCheckpoint</code> para evitar contar a mesma volta v&aacute;rias vezes.</p></section></section><section class="chapter"><h2 id="conclus-o-o-que-voc-aprendeu" data-toc="conclus-o-o-que-voc-aprendeu">Conclus&atilde;o: O Que Voc&ecirc; Aprendeu?</h2><p id="m1ofyp_211">Parab&eacute;ns! Se voc&ecirc; seguiu at&eacute; aqui, voc&ecirc; dissecou um jogo completo. Vamos revisar os conceitos-chave:</p><ul class="list _bullet" id="m1ofyp_212"><li class="list__item" id="m1ofyp_214"><p id="m1ofyp_221"><span class="control" id="m1ofyp_222">Game Loop:</span> A estrutura fundamental de <code class="code" id="m1ofyp_223">Entrada -&gt; L&oacute;gica -&gt; Renderiza&ccedil;&atilde;o</code>.</p></li><li class="list__item" id="m1ofyp_215"><p id="m1ofyp_224"><span class="control" id="m1ofyp_225">M&aacute;quinas de Estado:</span> Como organizar seu jogo em se&ccedil;&otilde;es l&oacute;gicas (<code class="code" id="m1ofyp_226">Menu</code>, <code class="code" id="m1ofyp_227">Playing</code>).</p></li><li class="list__item" id="m1ofyp_216"><p id="m1ofyp_228"><span class="control" id="m1ofyp_229">Trigonometria para Movimento:</span> Como usar <code class="code" id="m1ofyp_230">sin</code> e <code class="code" id="m1ofyp_231">cos</code> para um movimento suave em 2D.</p></li><li class="list__item" id="m1ofyp_217"><p id="m1ofyp_232"><span class="control" id="m1ofyp_233">IA Simples:</span> Como fazer um objeto seguir uma s&eacute;rie de pontos de forma aut&ocirc;noma usando <code class="code" id="m1ofyp_234">atan2</code>.</p></li><li class="list__item" id="m1ofyp_218"><p id="m1ofyp_235"><span class="control" id="m1ofyp_236">Otimiza&ccedil;&atilde;o:</span> Como evitar c&aacute;lculos caros (como <code class="code" id="m1ofyp_237">sqrt</code>) usando a dist&acirc;ncia ao quadrado.</p></li><li class="list__item" id="m1ofyp_219"><p id="m1ofyp_238"><span class="control" id="m1ofyp_239">C&acirc;mera 2D:</span> A t&eacute;cnica de mover o mundo para simular uma c&acirc;mera que segue o jogador.</p></li><li class="list__item" id="m1ofyp_220"><p id="m1ofyp_240"><span class="control" id="m1ofyp_241">L&oacute;gica de Jogo Espec&iacute;fica:</span> Como implementar um sistema de contagem de voltas preciso.</p></li></ul><p id="m1ofyp_213">Espero que este guia detalhado tenha sido &uacute;til. A melhor maneira de aprender &eacute; experimentar. Tente mudar os valores de acelera&ccedil;&atilde;o, a velocidade de curva, ou adicione mais checkpoints &agrave; pista. Divirta-se programando!</p></section><div class="last-modified">28 August 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="fifteen-puzzle.html" class="navigation-links__prev">Fifteen-Puzzle</a><a href="outrun.html" class="navigation-links__next">Outrun</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>