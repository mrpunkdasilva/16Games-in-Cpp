<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-19T17:29:35.414809654"><title>Racing Game Top-Down | 16 Games in C++</title><script type="application/json" id="virtual-toc-data">[{"id":"vis-o-geral-o-que-vamos-construir","level":0,"title":"Visão Geral: O Que Vamos Construir?","anchor":"#vis-o-geral-o-que-vamos-construir"},{"id":"passo-1-a-estrutura-fundamental-de-um-jogo","level":0,"title":"Passo 1: A Estrutura Fundamental de um Jogo","anchor":"#passo-1-a-estrutura-fundamental-de-um-jogo"},{"id":"passo-2-construindo-o-mundo-do-jogo","level":0,"title":"Passo 2: Construindo o Mundo do Jogo","anchor":"#passo-2-construindo-o-mundo-do-jogo"},{"id":"passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros","level":0,"title":"Passo 3: As Mecânicas do Jogo - Dando Vida aos Carros","anchor":"#passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros"},{"id":"passo-4-renderiza-o-e-interface","level":0,"title":"Passo 4: Renderização e Interface","anchor":"#passo-4-renderiza-o-e-interface"},{"id":"conclus-o-o-que-voc-aprendeu","level":0,"title":"Conclusão: O Que Você Aprendeu?","anchor":"#conclus-o-o-que-voc-aprendeu"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Racing Game Top-Down | 16 Games in C++"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="16 Games in C++ Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/racing.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Racing Game Top-Down | 16 Games in C++"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/racing.html#webpage",
    "url": "writerside-documentation/racing.html",
    "name": "Racing Game Top-Down | 16 Games in C++",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "16 Games in C++ Help"
}</script><!-- End Schema.org --></head><body data-id="racing" data-main-title="Racing Game Top-Down" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="jogos.md|Jogos"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>16 Games in C++  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="racing" id="racing.md">Racing Game Top-Down</h1><p id="-2otnp9_3">Ol&aacute;! Seja bem-vindo a este guia detalhado para a cria&ccedil;&atilde;o de um jogo de corrida 2D com vis&atilde;o de cima (Top-Down) usando C++ e a biblioteca SFML. Meu nome &eacute; Gemini, e serei seu guia. Pense em mim como um programador s&ecirc;nior que est&aacute; aqui para ensinar a voc&ecirc;, um desenvolvedor iniciante, n&atilde;o apenas o que fazer, mas por que fazemos. Vamos construir este jogo do zero, um conceito de cada vez.</p><section class="chapter"><h2 id="vis-o-geral-o-que-vamos-construir" data-toc="vis-o-geral-o-que-vamos-construir">Vis&atilde;o Geral: O Que Vamos Construir?</h2><p id="-2otnp9_10">Nosso objetivo &eacute; criar um jogo de corrida onde voc&ecirc; controla um carro em uma pista e compete contra outros quatro carros controlados por uma Intelig&ecirc;ncia Artificial (IA) b&aacute;sica.</p><p id="-2otnp9_11"><span class="control" id="-2otnp9_14">Recursos Principais:</span></p><ol class="list _decimal" id="-2otnp9_12" type="1"><li class="list__item" id="-2otnp9_15"><p id="-2otnp9_20"><span class="control" id="-2otnp9_21">Controle do Jogador:</span> Voc&ecirc; poder&aacute; acelerar, frear e virar seu carro.</p></li><li class="list__item" id="-2otnp9_16"><p id="-2otnp9_22"><span class="control" id="-2otnp9_23">Oponentes de IA:</span> Outros carros navegar&atilde;o pela pista de forma aut&ocirc;noma.</p></li><li class="list__item" id="-2otnp9_17"><p id="-2otnp9_24"><span class="control" id="-2otnp9_25">Pista com Checkpoints:</span> A pista n&atilde;o &eacute; apenas uma imagem; ela &eacute; definida por uma s&eacute;rie de pontos de verifica&ccedil;&atilde;o (checkpoints) que os carros devem seguir.</p></li><li class="list__item" id="-2otnp9_18"><p id="-2otnp9_26"><span class="control" id="-2otnp9_27">C&acirc;mera Din&acirc;mica:</span> A c&acirc;mera seguir&aacute; o seu carro, mantendo a a&ccedil;&atilde;o sempre no centro da tela.</p></li><li class="list__item" id="-2otnp9_19"><p id="-2otnp9_28"><span class="control" id="-2otnp9_29">Interface de Usu&aacute;rio (UI):</span> Mostraremos informa&ccedil;&otilde;es essenciais como sua velocidade, o checkpoint atual e o n&uacute;mero de voltas completadas.</p></li></ol></section><section class="chapter"><h2 id="passo-1-a-estrutura-fundamental-de-um-jogo" data-toc="passo-1-a-estrutura-fundamental-de-um-jogo">Passo 1: A Estrutura Fundamental de um Jogo</h2><p id="-2otnp9_30">Todo jogo, n&atilde;o importa qu&atilde;o complexo, &eacute; constru&iacute;do sobre alguns pilares. Vamos come&ccedil;ar com eles.</p><section class="chapter"><h3 id="o-game-loop-la-o-do-jogo" data-toc="o-game-loop-la-o-do-jogo">O Game Loop (La&ccedil;o do Jogo)</h3><p id="-2otnp9_33">O cora&ccedil;&atilde;o de qualquer jogo &eacute; o <span class="control" id="-2otnp9_37">game loop</span>. &Eacute; um la&ccedil;o <code class="code" id="-2otnp9_38">while</code> que continua executando enquanto a janela do jogo estiver aberta. Em cada &quot;tick&quot; ou itera&ccedil;&atilde;o desse la&ccedil;o, o jogo faz tr&ecirc;s coisas:</p><ol class="list _decimal" id="-2otnp9_34" type="1"><li class="list__item" id="-2otnp9_39"><p id="-2otnp9_42"><span class="control" id="-2otnp9_43">Processa Entradas:</span> Verifica se o jogador pressionou alguma tecla, clicou o mouse ou fechou a janela.</p></li><li class="list__item" id="-2otnp9_40"><p id="-2otnp9_44"><span class="control" id="-2otnp9_45">Atualiza a L&oacute;gica:</span> Move os personagens, verifica colis&otilde;es, atualiza a pontua&ccedil;&atilde;o, etc.</p></li><li class="list__item" id="-2otnp9_41"><p id="-2otnp9_46"><span class="control" id="-2otnp9_47">Renderiza a Tela:</span> Desenha tudo na tela na sua nova posi&ccedil;&atilde;o.</p></li></ol><p id="-2otnp9_35">No nosso c&oacute;digo, ele se parece com isto:</p><div class="code-block" data-lang="cpp">
while (app.isOpen()) {
    // 1. Processar Entradas (Eventos)
    // ...

    // 2. Atualizar a Lógica do Jogo
    // ...

    // 3. Renderizar a Tela
    // ...
}
</div></section><section class="chapter"><h3 id="gerenciamento-de-estado-gamestate" data-toc="gerenciamento-de-estado-gamestate">Gerenciamento de Estado (<code class="code" id="-2otnp9_54">GameState</code>)</h3><p id="-2otnp9_49">Nosso jogo tem duas telas principais: o <span class="control" id="-2otnp9_55">Menu Principal</span> e a <span class="control" id="-2otnp9_56">Corrida</span> em si. N&atilde;o podemos ter a l&oacute;gica da corrida rodando enquanto estamos no menu. Para gerenciar isso, usamos uma <span class="control" id="-2otnp9_57">m&aacute;quina de estados</span>. &Eacute; mais simples do que parece. Usamos uma <code class="code" id="-2otnp9_58">enum</code> para definir os poss&iacute;veis estados:</p><div class="code-block" data-lang="cpp">
enum GameState { MENU, PLAYING };
GameState gameState = MENU; // O jogo sempre começa no estado MENU
</div><p id="-2otnp9_51">Dentro do nosso game loop, podemos verificar qual &eacute; o estado atual e executar apenas a l&oacute;gica relevante:</p><div class="code-block" data-lang="cpp">
if (gameState == MENU) {
    // Lógica e desenho do menu
} else if (gameState == PLAYING) {
    // Lógica e desenho da corrida
}
</div></section></section><section class="chapter"><h2 id="passo-2-construindo-o-mundo-do-jogo" data-toc="passo-2-construindo-o-mundo-do-jogo">Passo 2: Construindo o Mundo do Jogo</h2><p id="-2otnp9_59">Agora vamos definir os elementos que comp&otilde;em nosso mundo de corrida.</p><section class="chapter"><h3 id="a-janela-e-os-recursos-gr-ficos" data-toc="a-janela-e-os-recursos-gr-ficos">A Janela e os Recursos Gr&aacute;ficos</h3><p id="-2otnp9_63">Primeiro, criamos a janela do jogo com um tamanho fixo e um t&iacute;tulo:</p><div class="code-block" data-lang="cpp">
RenderWindow app(VideoMode(640, 480), &quot;Car Racing Game!&quot;);
app.setFramerateLimit(60); // Limita o jogo a 60 quadros por segundo (FPS)
</div><p id="-2otnp9_65">Limitar o FPS &eacute; importante para que o jogo n&atilde;o rode r&aacute;pido demais em computadores potentes e para garantir uma experi&ecirc;ncia consistente.</p><p id="-2otnp9_66">Em seguida, carregamos nossos recursos (imagens e fontes) usando as classes <code class="code" id="-2otnp9_68">Texture</code> e <code class="code" id="-2otnp9_69">Font</code> do SFML. Uma <code class="code" id="-2otnp9_70">Texture</code> &eacute; a imagem em si, carregada na mem&oacute;ria da placa de v&iacute;deo. Um <code class="code" id="-2otnp9_71">Sprite</code> &eacute; um objeto que pode ser desenhado na tela e que usa uma <code class="code" id="-2otnp9_72">Texture</code>.</p><div class="code-block" data-lang="cpp">
Texture t1, t2;
t1.loadFromFile(&quot;images/background.png&quot;);
t2.loadFromFile(&quot;images/car.png&quot;);

Sprite sBackground(t1), sCar(t2);
</div></section><section class="chapter"><h3 id="a-pista-de-corrida-points" data-toc="a-pista-de-corrida-points">A Pista de Corrida (<code class="code" id="-2otnp9_77">points</code>)</h3><p id="-2otnp9_74">Como a IA saber&aacute; para onde ir? N&oacute;s definimos a pista usando uma s&eacute;rie de <span class="control" id="-2otnp9_78">checkpoints</span>. Pense neles como pontos invis&iacute;veis que formam o caminho ideal da corrida. Armazenamos esses pontos em um array 2D:</p><div class="code-block" data-lang="cpp">
const int num = 8; // Temos 8 checkpoints
int points[num][2] = {
    {300, 610},
    {1270, 430},
    // ... e assim por diante
};
</div><p id="-2otnp9_76">A IA simplesmente tentar&aacute; ir do checkpoint 0 para o 1, depois para o 2, e assim por diante, em um ciclo. Esta &eacute; uma maneira muito simples e eficaz de criar um comportamento de seguimento de caminho.</p></section><section class="chapter"><h3 id="a-planta-baixa-do-carro-a-estrutura-car" data-toc="a-planta-baixa-do-carro-a-estrutura-car">A Planta Baixa do Carro (A Estrutura <code class="code" id="-2otnp9_84">Car</code>)</h3><p id="-2otnp9_80">Para representar cada carro no jogo (tanto o jogador quanto a IA), usamos uma <code class="code" id="-2otnp9_85">struct</code>. Uma <code class="code" id="-2otnp9_86">struct</code> &eacute; como uma planta baixa que agrupa v&aacute;rias vari&aacute;veis relacionadas em um &uacute;nico tipo de dado.</p><div class="code-block" data-lang="cpp">
struct Car {
    float x, y, speed, angle;
    int n; // Índice do próximo checkpoint alvo
    int lastCheckpoint;

    // Construtor: valores iniciais quando um novo Car é criado
    Car() {
        speed = 2;
        angle = 0;
        n = 0;
        lastCheckpoint = 0;
    }

    void move();
    void findTarget();
};
</div><ul class="list _bullet" id="-2otnp9_82"><li class="list__item" id="-2otnp9_87"><p id="-2otnp9_92"><code class="code" id="-2otnp9_93">x</code>, <code class="code" id="-2otnp9_94">y</code>: A posi&ccedil;&atilde;o exata do carro no mundo do jogo (coordenadas de mundo).</p></li><li class="list__item" id="-2otnp9_88"><p id="-2otnp9_95"><code class="code" id="-2otnp9_96">speed</code>: A velocidade atual.</p></li><li class="list__item" id="-2otnp9_89"><p id="-2otnp9_97"><code class="code" id="-2otnp9_98">angle</code>: O &acirc;ngulo para o qual o carro est&aacute; virado. <span class="control" id="-2otnp9_99">Importante:</span> Em programa&ccedil;&atilde;o de jogos e matem&aacute;tica, &acirc;ngulos s&atilde;o quase sempre medidos em <span class="control" id="-2otnp9_100">radianos</span>, n&atilde;o em graus.</p></li><li class="list__item" id="-2otnp9_90"><p id="-2otnp9_101"><code class="code" id="-2otnp9_102">n</code>: O &iacute;ndice do pr&oacute;ximo checkpoint que este carro est&aacute; perseguindo. Para o <code class="code" id="-2otnp9_103">car[0]</code> (jogador), isso nos diz em que parte da pista ele est&aacute;.</p></li><li class="list__item" id="-2otnp9_91"><p id="-2otnp9_104"><code class="code" id="-2otnp9_105">lastCheckpoint</code>: O &uacute;ltimo checkpoint que o carro passou. Isso &eacute; crucial para a nossa l&oacute;gica de contagem de voltas.</p></li></ul></section></section><section class="chapter"><h2 id="passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros" data-toc="passo-3-as-mec-nicas-do-jogo-dando-vida-aos-carros">Passo 3: As Mec&acirc;nicas do Jogo - Dando Vida aos Carros</h2><p id="-2otnp9_106">Esta &eacute; a parte mais emocionante, onde implementamos a f&iacute;sica, a IA e os controles.</p><section class="chapter"><h3 id="controle-e-f-sica-do-jogador" data-toc="controle-e-f-sica-do-jogador">Controle e F&iacute;sica do Jogador</h3><p id="-2otnp9_111">O carro do jogador (<code class="code" id="-2otnp9_115">car[0]</code>) &eacute; especial. Ele n&atilde;o usa a IA. Em vez disso, ele responde diretamente &agrave;s suas teclas.</p><div class="code-block" data-lang="cpp">
// Detecta quais teclas estão pressionadas
bool Up = Keyboard::isKeyPressed(Keyboard::Up);
// ...

// 1. Aceleração e Desaceleração
if (Up &amp;&amp; speed &lt; maxSpeed) {
    if (speed &lt; 0) speed += dec; // Se estava de ré, freia
    else speed += acc;           // Se estava indo para frente, acelera
}
// ...

// 2. Atrito (Fricção)
if (!Up &amp;&amp; !Down) {
    if (speed - dec &gt; 0) speed -= dec; // Perde velocidade gradualmente
    else if (speed + dec &lt; 0) speed += dec;
    else speed = 0; // Para completamente
}

// 3. Virar o Carro
if (Right &amp;&amp; speed != 0) angle += turnSpeed * speed / maxSpeed;
</div><p id="-2otnp9_113"><span class="control" id="-2otnp9_116">An&aacute;lise detalhada:</span></p><ul class="list _bullet" id="-2otnp9_114"><li class="list__item" id="-2otnp9_117"><p id="-2otnp9_119"><code class="code" id="-2otnp9_120">acc</code> (acelera&ccedil;&atilde;o) e <code class="code" id="-2otnp9_121">dec</code> (desacelera&ccedil;&atilde;o) s&atilde;o pequenas constantes que controlam qu&atilde;o r&aacute;pido o carro ganha ou perde velocidade. Isso cria uma sensa&ccedil;&atilde;o de <span class="control" id="-2otnp9_122">in&eacute;rcia</span>.</p></li><li class="list__item" id="-2otnp9_118"><p id="-2otnp9_123">A l&oacute;gica de virar &eacute; interessante: <code class="code" id="-2otnp9_124">turnSpeed * speed / maxSpeed</code>. Isso faz com que o carro vire mais lentamente em baixas velocidades e mais rapidamente em altas velocidades, o que &eacute; o oposto do realismo, mas torna o jogo mais divertido e control&aacute;vel no estilo arcade.</p></li></ul></section><section class="chapter"><h3 id="movimento-f-sico-move" data-toc="movimento-f-sico-move">Movimento F&iacute;sico (<code class="code" id="-2otnp9_130">move</code>)</h3><p id="-2otnp9_126">Uma vez que a velocidade e o &acirc;ngulo s&atilde;o definidos, a fun&ccedil;&atilde;o <code class="code" id="-2otnp9_131">move</code> atualiza a posi&ccedil;&atilde;o do carro.</p><div class="code-block" data-lang="cpp">
void move() {
    x += sin(angle) * speed;
    y -= cos(angle) * speed;
}
</div><p id="-2otnp9_128">Isto &eacute; trigonometria. <code class="code" id="-2otnp9_132">sin(angle)</code> e <code class="code" id="-2otnp9_133">cos(angle)</code> decomp&otilde;em o movimento diagonal em seus componentes horizontal (X) e vertical (Y).</p><ul class="list _bullet" id="-2otnp9_129"><li class="list__item" id="-2otnp9_134"><p id="-2otnp9_135"><span class="control" id="-2otnp9_136">Por que <code class="code" id="-2otnp9_138">y -= ...</code>?</span> Em muitos sistemas gr&aacute;ficos, incluindo o do SFML, a coordenada (0,0) fica no canto superior esquerdo. O eixo Y aumenta para <span class="control" id="-2otnp9_137">baixo</span>. No entanto, matematicamente, o eixo Y aumenta para cima. Subtrair o cosseno corrige essa diferen&ccedil;a, fazendo o carro se mover &quot;para cima&quot; na tela quando o &acirc;ngulo &eacute; 0.</p></li></ul></section><section class="chapter"><h3 id="a-intelig-ncia-artificial-findtarget" data-toc="a-intelig-ncia-artificial-findtarget">A Intelig&ecirc;ncia Artificial (<code class="code" id="-2otnp9_144">findTarget</code>)</h3><p id="-2otnp9_140">Esta &eacute; a fun&ccedil;&atilde;o que faz os carros oponentes parecerem vivos. O objetivo deles &eacute; simples: virar-se para o pr&oacute;ximo checkpoint e avan&ccedil;ar.</p><div class="code-block" data-lang="cpp">
void findTarget() {
    // 1. Pega as coordenadas do checkpoint alvo
    float tx = points[n][0];
    float ty = points[n][1];

    // 2. Calcula o ângulo exato do carro até o alvo
    float beta = angle - atan2(tx - x, -ty + y);

    // 3. Vira o carro na direção certa
    if (sin(beta) &lt; 0) angle += 0.005 * speed;
    else angle -= 0.005 * speed;

    // 4. Verifica se chegou ao alvo
    if ((x - tx) * (x - tx) + (y - ty) * (y - ty) &lt; 25 * 25) {
        lastCheckpoint = n;
        n = (n + 1) % num; // Passa para o próximo checkpoint
    }
}
</div><p id="-2otnp9_142"><span class="control" id="-2otnp9_145">An&aacute;lise detalhada:</span></p><ul class="list _bullet" id="-2otnp9_143"><li class="list__item" id="-2otnp9_146"><p id="-2otnp9_151"><code class="code" id="-2otnp9_152">atan2(delta_x, -delta_y)</code>: Esta fun&ccedil;&atilde;o &eacute; m&aacute;gica. Ela nos d&aacute; o &acirc;ngulo exato de um ponto a outro. Usamos <code class="code" id="-2otnp9_153">-ty + y</code> para o componente <code class="code" id="-2otnp9_154">y</code> para corrigir a invers&atilde;o do eixo Y que mencionamos antes.</p></li><li class="list__item" id="-2otnp9_147"><p id="-2otnp9_155"><code class="code" id="-2otnp9_156">beta</code>: &Eacute; a diferen&ccedil;a entre o &acirc;ngulo atual do carro e o &acirc;ngulo que ele <span class="emphasis" id="-2otnp9_157">deveria</span> ter.</p></li><li class="list__item" id="-2otnp9_148"><p id="-2otnp9_158"><code class="code" id="-2otnp9_159">if (sin(beta) &lt; 0)</code>: Este &eacute; um truque inteligente. O sinal do seno de <code class="code" id="-2otnp9_160">beta</code> nos diz se o alvo est&aacute; &agrave; esquerda ou &agrave; direita da dire&ccedil;&atilde;o atual do carro. Se for negativo, viramos em uma dire&ccedil;&atilde;o; se for positivo, na outra. Isso garante que o carro sempre tome o caminho mais curto para se alinhar com o alvo.</p></li><li class="list__item" id="-2otnp9_149"><p id="-2otnp9_161"><span class="control" id="-2otnp9_162">Verifica&ccedil;&atilde;o de Dist&acirc;ncia:</span> A linha <code class="code" id="-2otnp9_163">(x-tx)*(x-tx) + ...</code> &eacute; a f&oacute;rmula da dist&acirc;ncia ao quadrado (<code class="code" id="-2otnp9_164">d&sup2; = dx&sup2; + dy&sup2;</code>). Usamos a dist&acirc;ncia ao quadrado para evitar o c&aacute;lculo da raiz quadrada (<code class="code" id="-2otnp9_165">sqrt</code>), que &eacute; uma opera&ccedil;&atilde;o computacionalmente &quot;cara&quot;. Como s&oacute; queremos saber se a dist&acirc;ncia &eacute; <span class="emphasis" id="-2otnp9_166">menor</span> que um valor, comparar os quadrados funciona perfeitamente e &eacute; mais r&aacute;pido.</p></li><li class="list__item" id="-2otnp9_150"><p id="-2otnp9_167"><code class="code" id="-2otnp9_168">n = (n + 1) % num;</code>: O operador m&oacute;dulo (<code class="code" id="-2otnp9_169">%</code>) &eacute; perfeito para criar ciclos. Quando <code class="code" id="-2otnp9_170">n</code> chega ao &uacute;ltimo checkpoint, <code class="code" id="-2otnp9_171">(n + 1)</code> se torna <code class="code" id="-2otnp9_172">num</code>, e <code class="code" id="-2otnp9_173">num % num</code> &eacute; <code class="code" id="-2otnp9_174">0</code>. Isso faz a IA voltar ao primeiro checkpoint e continuar o ciclo.</p></li></ul></section><section class="chapter"><h3 id="sistema-de-colis-o" data-toc="sistema-de-colis-o">Sistema de Colis&atilde;o</h3><p id="-2otnp9_175">A colis&atilde;o &eacute; simples: se dois carros est&atilde;o muito pr&oacute;ximos, n&oacute;s os empurramos para longe um do outro.</p><div class="code-block" data-lang="cpp">
// Loop dentro de loop para comparar cada carro com todos os outros
for (int i = 0; i &lt; N; i++) {
    for (int j = 0; j &lt; N; j++) {
        // ...
        // Calcula a distância ao quadrado
        while (dx * dx + dy * dy &lt; 4 * R * R) {
            // Empurra os carros um pouco para longe um do outro
            car[i].x += dx / 10.0;
            car[j].x -= dx / 10.0;
            // ... e atualiza a distância para a próxima verificação do while
        }
    }
}
</div><p id="-2otnp9_177">Este m&eacute;todo &eacute; chamado de &quot;resolu&ccedil;&atilde;o por impulso&quot; e &eacute; muito b&aacute;sico. Ele funciona, mas pode fazer os carros tremerem um pouco quando colidem. Para um jogo simples, &eacute; suficiente.</p></section></section><section class="chapter"><h2 id="passo-4-renderiza-o-e-interface" data-toc="passo-4-renderiza-o-e-interface">Passo 4: Renderiza&ccedil;&atilde;o e Interface</h2><p id="-2otnp9_179">Agora que nossa l&oacute;gica est&aacute; pronta, vamos mostrar tudo na tela.</p><section class="chapter"><h3 id="a-c-mera-que-segue-o-jogador" data-toc="a-c-mera-que-segue-o-jogador">A C&acirc;mera que Segue o Jogador</h3><p id="-2otnp9_183">N&atilde;o movemos a c&acirc;mera. Em vez disso, movemos o <span class="control" id="-2otnp9_186">mundo inteiro</span> na dire&ccedil;&atilde;o oposta.</p><ol class="list _decimal" id="-2otnp9_184" type="1"><li class="list__item" id="-2otnp9_187"><p id="-2otnp9_189">Calculamos um &quot;deslocamento&quot; (<code class="code" id="-2otnp9_191">offset</code>) para manter o carro do jogador (<code class="code" id="-2otnp9_192">car[0]</code>) no centro da tela.</p><div class="code-block" data-lang="cpp">
int offsetX = 0, offsetY = 0;
if (car[0].x &gt; 320) offsetX = car[0].x - 320;
if (car[0].y &gt; 240) offsetY = car[0].y - 240;
</div></li><li class="list__item" id="-2otnp9_188"><p id="-2otnp9_193">Ao desenhar qualquer objeto do mundo (o fundo, os carros), subtra&iacute;mos esse offset de sua posi&ccedil;&atilde;o.</p><div class="code-block" data-lang="cpp">
sBackground.setPosition(-offsetX, -offsetY);
sCar.setPosition(car[i].x - offsetX, car[i].y - offsetY);
</div></li></ol><p id="-2otnp9_185">O resultado &eacute; que o jogador parece ficar parado no centro enquanto o mundo se move ao seu redor.</p></section><section class="chapter"><h3 id="a-interface-do-usu-rio-ui" data-toc="a-interface-do-usu-rio-ui">A Interface do Usu&aacute;rio (UI)</h3><p id="-2otnp9_195">A UI (texto de velocidade, voltas, etc.) &eacute; desenhada por &uacute;ltimo e <span class="control" id="-2otnp9_197">sem</span> o deslocamento da c&acirc;mera. Isso garante que ela permane&ccedil;a fixa na tela, como um painel de controle.</p><div class="code-block" data-lang="cpp">
// Converte a velocidade (float) para uma string
std::string speedStr = &quot;Speed: &quot; + std::to_string(static_cast&lt;int&gt;(car[0].speed * 10));
speedText.setString(speedStr);
app.draw(speedText); // Desenhado em coordenadas de tela fixas
</div></section><section class="chapter"><h3 id="l-gica-de-contagem-de-voltas" data-toc="l-gica-de-contagem-de-voltas">L&oacute;gica de Contagem de Voltas</h3><p id="-2otnp9_198">Esta &eacute; uma das partes mais importantes da l&oacute;gica de um jogo de corrida.</p><div class="code-block" data-lang="cpp">
if (car[0].n == 0 &amp;&amp; car[0].lastCheckpoint == num - 1) {
    laps++;
    car[0].lastCheckpoint = 0; // Reseta para a próxima volta
}
</div><p id="-2otnp9_200">Vamos traduzir esta condi&ccedil;&atilde;o:</p><ul class="list _bullet" id="-2otnp9_201"><li class="list__item" id="-2otnp9_204"><p id="-2otnp9_206"><code class="code" id="-2otnp9_207">car[0].n == 0</code>: O pr&oacute;ximo alvo do meu carro &eacute; o checkpoint inicial (o n&uacute;mero 0).</p></li><li class="list__item" id="-2otnp9_205"><p id="-2otnp9_208"><code class="code" id="-2otnp9_209">car[0].lastCheckpoint == num - 1</code>: O &uacute;ltimo checkpoint que eu passei foi o &uacute;ltimo da pista.</p></li></ul><p id="-2otnp9_202">Quando ambas as condi&ccedil;&otilde;es s&atilde;o verdadeiras, significa que o jogador acabou de cruzar a linha de chegada, completando uma volta. Ent&atilde;o, incrementamos <code class="code" id="-2otnp9_210">laps</code> e resetamos <code class="code" id="-2otnp9_211">lastCheckpoint</code> para evitar contar a mesma volta v&aacute;rias vezes.</p></section></section><section class="chapter"><h2 id="conclus-o-o-que-voc-aprendeu" data-toc="conclus-o-o-que-voc-aprendeu">Conclus&atilde;o: O Que Voc&ecirc; Aprendeu?</h2><p id="-2otnp9_212">Parab&eacute;ns! Se voc&ecirc; seguiu at&eacute; aqui, voc&ecirc; dissecou um jogo completo. Vamos revisar os conceitos-chave:</p><ul class="list _bullet" id="-2otnp9_213"><li class="list__item" id="-2otnp9_215"><p id="-2otnp9_222"><span class="control" id="-2otnp9_223">Game Loop:</span> A estrutura fundamental de <code class="code" id="-2otnp9_224">Entrada -&gt; L&oacute;gica -&gt; Renderiza&ccedil;&atilde;o</code>.</p></li><li class="list__item" id="-2otnp9_216"><p id="-2otnp9_225"><span class="control" id="-2otnp9_226">M&aacute;quinas de Estado:</span> Como organizar seu jogo em se&ccedil;&otilde;es l&oacute;gicas (<code class="code" id="-2otnp9_227">Menu</code>, <code class="code" id="-2otnp9_228">Playing</code>).</p></li><li class="list__item" id="-2otnp9_217"><p id="-2otnp9_229"><span class="control" id="-2otnp9_230">Trigonometria para Movimento:</span> Como usar <code class="code" id="-2otnp9_231">sin</code> e <code class="code" id="-2otnp9_232">cos</code> para um movimento suave em 2D.</p></li><li class="list__item" id="-2otnp9_218"><p id="-2otnp9_233"><span class="control" id="-2otnp9_234">IA Simples:</span> Como fazer um objeto seguir uma s&eacute;rie de pontos de forma aut&ocirc;noma usando <code class="code" id="-2otnp9_235">atan2</code>.</p></li><li class="list__item" id="-2otnp9_219"><p id="-2otnp9_236"><span class="control" id="-2otnp9_237">Otimiza&ccedil;&atilde;o:</span> Como evitar c&aacute;lculos caros (como <code class="code" id="-2otnp9_238">sqrt</code>) usando a dist&acirc;ncia ao quadrado.</p></li><li class="list__item" id="-2otnp9_220"><p id="-2otnp9_239"><span class="control" id="-2otnp9_240">C&acirc;mera 2D:</span> A t&eacute;cnica de mover o mundo para simular uma c&acirc;mera que segue o jogador.</p></li><li class="list__item" id="-2otnp9_221"><p id="-2otnp9_241"><span class="control" id="-2otnp9_242">L&oacute;gica de Jogo Espec&iacute;fica:</span> Como implementar um sistema de contagem de voltas preciso.</p></li></ul><p id="-2otnp9_214">Espero que este guia detalhado tenha sido &uacute;til. A melhor maneira de aprender &eacute; experimentar. Tente mudar os valores de acelera&ccedil;&atilde;o, a velocidade de curva, ou adicione mais checkpoints &agrave; pista. Divirta-se programando!</p></section><div class="last-modified">13 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="fifteen-puzzle.html" class="navigation-links__prev">Fifteen-Puzzle</a><a href="outrun.html" class="navigation-links__next">Outrun</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>