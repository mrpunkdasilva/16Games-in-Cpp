<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-09-07T20:49:16.205675779"><title>Fifteen-Puzzle | 16 Games in C++</title><script type="application/json" id="virtual-toc-data">[{"id":"o-que-o-fifteen-puzzle","level":0,"title":"O que é o Fifteen-Puzzle?","anchor":"#o-que-o-fifteen-puzzle"},{"id":"a-estrutura-do-c-digo-main-cpp","level":0,"title":"A Estrutura do Código (main.cpp)","anchor":"#a-estrutura-do-c-digo-main-cpp"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="images/logo.svg"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Fifteen-Puzzle | 16 Games in C++"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="16 Games in C++ Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/fifteen-puzzle.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Fifteen-Puzzle | 16 Games in C++"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/fifteen-puzzle.html#webpage",
    "url": "writerside-documentation/fifteen-puzzle.html",
    "name": "Fifteen-Puzzle | 16 Games in C++",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "16 Games in C++ Help"
}</script><!-- End Schema.org --></head><body data-id="fifteen-puzzle" data-main-title="Fifteen-Puzzle" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="jogos.md|Jogos"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>16 Games in C++  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="fifteen-puzzle" id="fifteen-puzzle.md">Fifteen-Puzzle</h1><p id="ebpgcq_3">Este tutorial ensina como criar o jogo Fifteen-Puzzle do zero usando C++ e SFML, com foco nas melhorias de UI e no sistema de dicas. Vamos explorar o c&oacute;digo-fonte principal (<code class="code" id="ebpgcq_6">main.cpp</code>) passo a passo, explicando cada componente e sua fun&ccedil;&atilde;o.</p><section class="chapter"><h2 id="o-que-o-fifteen-puzzle" data-toc="o-que-o-fifteen-puzzle">O que &eacute; o Fifteen-Puzzle?</h2><p id="ebpgcq_7">O Fifteen-Puzzle &eacute; um quebra-cabe&ccedil;a deslizante cl&aacute;ssico, tamb&eacute;m conhecido como Quebra-Cabe&ccedil;a de 15. Ele consiste em uma moldura de pe&ccedil;as quadradas numeradas de 1 a 15, com uma pe&ccedil;a faltando, dispostas em uma grade 4x4.</p><section class="chapter"><h3 id="como-o-jogo-funciona" data-toc="como-o-jogo-funciona">Como o Jogo Funciona</h3><ul class="list _bullet" id="ebpgcq_9"><li class="list__item" id="ebpgcq_10"><p id="ebpgcq_15"><span class="control" id="ebpgcq_16">Tabuleiro 4x4</span>: O jogo &eacute; jogado em uma grade de 4 linhas por 4 colunas.</p></li><li class="list__item" id="ebpgcq_11"><p id="ebpgcq_17"><span class="control" id="ebpgcq_18">Pe&ccedil;as Numeradas</span>: 15 pe&ccedil;as s&atilde;o numeradas de 1 a 15.</p></li><li class="list__item" id="ebpgcq_12"><p id="ebpgcq_19"><span class="control" id="ebpgcq_20">Espa&ccedil;o Vazio</span>: H&aacute; um &uacute;nico espa&ccedil;o vazio no tabuleiro.</p></li><li class="list__item" id="ebpgcq_13"><p id="ebpgcq_21"><span class="control" id="ebpgcq_22">Movimento</span>: O jogador pode mover qualquer pe&ccedil;a adjacente (acima, abaixo, &agrave; esquerda ou &agrave; direita) para o espa&ccedil;o vazio.</p></li><li class="list__item" id="ebpgcq_14"><p id="ebpgcq_23"><span class="control" id="ebpgcq_24">Objetivo</span>: Organizar as pe&ccedil;as em ordem num&eacute;rica crescente (da esquerda para a direita, de cima para baixo), deixando o espa&ccedil;o vazio na &uacute;ltima posi&ccedil;&atilde;o (canto inferior direito).</p></li></ul></section></section><section class="chapter"><h2 id="a-estrutura-do-c-digo-main-cpp" data-toc="a-estrutura-do-c-digo-main-cpp">A Estrutura do C&oacute;digo (<code class="code" id="ebpgcq_33">main.cpp</code>)</h2><p id="ebpgcq_26">O arquivo <code class="code" id="ebpgcq_34">main.cpp</code> cont&eacute;m toda a l&oacute;gica do jogo, desde a inicializa&ccedil;&atilde;o da janela e dos elementos gr&aacute;ficos at&eacute; o manuseio das intera&ccedil;&otilde;es do usu&aacute;rio e a renderiza&ccedil;&atilde;o na tela.</p><section class="chapter"><h3 id="1-inclus-es-e-namespace" data-toc="1-inclus-es-e-namespace">1. Inclus&otilde;es e Namespace</h3><p id="ebpgcq_35">Come&ccedil;amos incluindo as bibliotecas necess&aacute;rias. <code class="code" id="ebpgcq_37">SFML/Graphics.hpp</code> &eacute; fundamental para todas as opera&ccedil;&otilde;es gr&aacute;ficas e de janela. <code class="code" id="ebpgcq_38">iostream</code> &eacute; para entrada/sa&iacute;da b&aacute;sica, e <code class="code" id="ebpgcq_39">vector</code>, <code class="code" id="ebpgcq_40">random</code>, <code class="code" id="ebpgcq_41">algorithm</code> s&atilde;o usados para o embaralhamento das pe&ccedil;as.</p><div class="code-block" data-lang="cpp">
#include &lt;SFML/Graphics.hpp&gt; // Funcionalidades gráficas e de janela
#include &lt;iostream&gt;          // Entrada/saída de console
#include &lt;vector&gt;            // Para usar std::vector
#include &lt;random&gt;            // Para geração de números aleatórios
#include &lt;algorithm&gt;         // Para usar std::shuffle

using namespace sf; // Simplifica o uso de classes e funções da SFML
</div></section><section class="chapter"><h3 id="2-estados-do-jogo-gamestate" data-toc="2-estados-do-jogo-gamestate">2. Estados do Jogo (<code class="code" id="ebpgcq_46">GameState</code>)</h3><p id="ebpgcq_43">Para gerenciar as diferentes telas e comportamentos do jogo (menu, jogabilidade), utilizamos um <code class="code" id="ebpgcq_47">enum</code> simples chamado <code class="code" id="ebpgcq_48">GameState</code>. Isso permite que o programa saiba em qual &quot;modo&quot; ele est&aacute; operando.</p><div class="code-block" data-lang="cpp">
enum GameState { MENU, GAME };
</div><ul class="list _bullet" id="ebpgcq_45"><li class="list__item" id="ebpgcq_49"><p id="ebpgcq_51"><code class="code" id="ebpgcq_52">MENU</code>: O jogo est&aacute; na tela inicial, onde o jogador pode escolher &quot;Play&quot; ou &quot;Exit&quot;.</p></li><li class="list__item" id="ebpgcq_50"><p id="ebpgcq_53"><code class="code" id="ebpgcq_54">GAME</code>: O jogador est&aacute; ativamente jogando o quebra-cabe&ccedil;a.</p></li></ul></section><section class="chapter"><h3 id="3-embaralhamento-do-tabuleiro-shufflegrid" data-toc="3-embaralhamento-do-tabuleiro-shufflegrid">3. Embaralhamento do Tabuleiro (<code class="code" id="ebpgcq_60">shuffleGrid</code>)</h3><p id="ebpgcq_56">A fun&ccedil;&atilde;o <code class="code" id="ebpgcq_61">shuffleGrid</code> &eacute; respons&aacute;vel por randomizar a disposi&ccedil;&atilde;o das pe&ccedil;as no tabuleiro no in&iacute;cio de cada nova partida. Ela garante que o quebra-cabe&ccedil;a seja sempre diferente e solucion&aacute;vel.</p><div class="code-block" data-lang="cpp">
void shuffleGrid(int grid[6][6]) {
    std::vector&lt;int&gt; numbers;
    for (int i = 1; i &lt;= 15; ++i) {
        numbers.push_back(i); // Adiciona números de 1 a 15
    }
    std::random_device rd; // Gera uma semente aleatória baseada no hardware
    std::mt19937 g(rd());  // Motor de números aleatórios Mersenne Twister
    std::shuffle(numbers.begin(), numbers.end(), g); // Embaralha a ordem dos números

    int k = 0;
    for (int i = 1; i &lt;= 4; ++i) {
        for (int j = 1; j &lt;= 4; ++j) {
            if (i == 4 &amp;&amp; j == 4) {
                grid[i][j] = 16; // A última posição (4,4) é o espaço vazio
            } else {
                grid[i][j] = numbers[k++]; // Preenche o grid com os números embaralhados
            }
        }
    }
}
</div><p id="ebpgcq_58"><span class="control" id="ebpgcq_62">Explica&ccedil;&atilde;o:</span></p><ul class="list _bullet" id="ebpgcq_59"><li class="list__item" id="ebpgcq_63"><p id="ebpgcq_67">Um <code class="code" id="ebpgcq_68">std::vector&lt;int&gt; numbers</code> &eacute; criado e preenchido com os valores de 1 a 15.</p></li><li class="list__item" id="ebpgcq_64"><p id="ebpgcq_69"><code class="code" id="ebpgcq_70">std::random_device</code> e <code class="code" id="ebpgcq_71">std::mt19937</code> s&atilde;o usados para gerar uma sequ&ecirc;ncia de n&uacute;meros aleat&oacute;rios de alta qualidade.</p></li><li class="list__item" id="ebpgcq_65"><p id="ebpgcq_72"><code class="code" id="ebpgcq_73">std::shuffle</code> reorganiza os elementos do vetor <code class="code" id="ebpgcq_74">numbers</code> aleatoriamente.</p></li><li class="list__item" id="ebpgcq_66"><p id="ebpgcq_75">O tabuleiro (<code class="code" id="ebpgcq_76">grid</code>) &eacute; ent&atilde;o preenchido com esses n&uacute;meros embaralhados. A posi&ccedil;&atilde;o <code class="code" id="ebpgcq_77">grid[4][4]</code> (que corresponde &agrave; &uacute;ltima c&eacute;lula do tabuleiro 4x4) &eacute; reservada para o espa&ccedil;o vazio, representado pelo n&uacute;mero <code class="code" id="ebpgcq_78">16</code>.</p></li></ul></section><section class="chapter"><h3 id="4-verifica-o-de-solu-o-issolved" data-toc="4-verifica-o-de-solu-o-issolved">4. Verifica&ccedil;&atilde;o de Solu&ccedil;&atilde;o (<code class="code" id="ebpgcq_84">isSolved</code>)</h3><p id="ebpgcq_80">A fun&ccedil;&atilde;o <code class="code" id="ebpgcq_85">isSolved</code> verifica se o jogador conseguiu organizar todas as pe&ccedil;as na ordem correta. Ela percorre o tabuleiro e compara o valor de cada pe&ccedil;a com o valor que deveria estar naquela posi&ccedil;&atilde;o em um tabuleiro resolvido.</p><div class="code-block" data-lang="cpp">
bool isSolved(int grid[6][6]) {
    int k = 1; // Valor esperado para a peça na posição atual
    for (int i = 1; i &lt;= 4; ++i) {
        for (int j = 1; j &lt;= 4; ++j) {
            if (k == 16) k = 0; // O valor 16 (espaço vazio) não é verificado
            if (grid[i][j] != k &amp;&amp; k != 0) {
                return false; // Se uma peça estiver fora de lugar, o puzzle não está resolvido
            }
            k++; // Incrementa o valor esperado para a próxima posição
        }
    }
    return true; // Se todas as verificações passarem, o puzzle está resolvido
}
</div><p id="ebpgcq_82"><span class="control" id="ebpgcq_86">Explica&ccedil;&atilde;o:</span></p><ul class="list _bullet" id="ebpgcq_83"><li class="list__item" id="ebpgcq_87"><p id="ebpgcq_92">A vari&aacute;vel <code class="code" id="ebpgcq_93">k</code> atua como um contador, representando o valor esperado para a pe&ccedil;a na c&eacute;lula atual (come&ccedil;ando de 1).</p></li><li class="list__item" id="ebpgcq_88"><p id="ebpgcq_94">O loop itera por todas as c&eacute;lulas do tabuleiro.</p></li><li class="list__item" id="ebpgcq_89"><p id="ebpgcq_95">Se <code class="code" id="ebpgcq_96">k</code> for 16 (o valor do espa&ccedil;o vazio), ele &eacute; temporariamente ajustado para 0 para que a compara&ccedil;&atilde;o seja ignorada para o espa&ccedil;o vazio.</p></li><li class="list__item" id="ebpgcq_90"><p id="ebpgcq_97">Se o valor da pe&ccedil;a atual (<code class="code" id="ebpgcq_98">grid[i][j]</code>) n&atilde;o corresponder ao valor esperado (<code class="code" id="ebpgcq_99">k</code>), a fun&ccedil;&atilde;o retorna <code class="code" id="ebpgcq_100">false</code>.</p></li><li class="list__item" id="ebpgcq_91"><p id="ebpgcq_101">Se o loop for conclu&iacute;do sem encontrar nenhuma pe&ccedil;a fora de lugar, o tabuleiro est&aacute; resolvido e a fun&ccedil;&atilde;o retorna <code class="code" id="ebpgcq_102">true</code>.</p></li></ul></section><section class="chapter"><h3 id="5-sistema-de-dicas-findhintmove" data-toc="5-sistema-de-dicas-findhintmove">5. Sistema de Dicas (<code class="code" id="ebpgcq_108">findHintMove</code>)</h3><p id="ebpgcq_104">A fun&ccedil;&atilde;o <code class="code" id="ebpgcq_109">findHintMove</code> &eacute; a intelig&ecirc;ncia por tr&aacute;s do sistema de dicas. Ela localiza o espa&ccedil;o vazio e, em seguida, procura por uma pe&ccedil;a adjacente a ele que esteja fora de sua posi&ccedil;&atilde;o final correta. Se tal pe&ccedil;a for encontrada, suas coordenadas s&atilde;o retornadas como uma dica.</p><div class="code-block" data-lang="cpp">
Vector2i findHintMove(int grid[6][6]) {
    int emptyX = -1, emptyY = -1;
    // 1. Encontra a posição do espaço vazio (valor 16)
    for (int i = 1; i &lt;= 4; ++i) {
        for (int j = 1; j &lt;= 4; ++j) {
            if (grid[i][j] == 16) {
                emptyX = i;
                emptyY = j;
                break;
            }
        }
        if (emptyX != -1) break;
    }

    // 2. Define as direções para verificar peças adjacentes (direita, esquerda, baixo, cima)
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    for (int i = 0; i &lt; 4; ++i) {
        int nx = emptyX + dx[i]; // Coordenada X da peça adjacente
        int ny = emptyY + dy[i]; // Coordenada Y da peça adjacente

        // 3. Verifica se a peça adjacente está dentro dos limites do tabuleiro
        if (nx &gt;= 1 &amp;&amp; nx &lt;= 4 &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= 4) {
            int tileValue = grid[nx][ny]; // Valor da peça adjacente
            // 4. Calcula o valor correto que deveria estar na posição (nx, ny)
            // A fórmula (nx - 1) * 4 + ny converte coordenadas 1-baseadas (nx, ny)
            // para o valor esperado em um tabuleiro resolvido (1 a 16).
            if (tileValue != (nx - 1) * 4 + ny) {
                return Vector2i(nx, ny); // Retorna a posição da peça que pode ser movida
            }
        }
    }
    return Vector2i(-1, -1); // Nenhuma dica útil encontrada
}
</div><p id="ebpgcq_106"><span class="control" id="ebpgcq_110">Explica&ccedil;&atilde;o:</span></p><ul class="list _bullet" id="ebpgcq_107"><li class="list__item" id="ebpgcq_111"><p id="ebpgcq_116">A fun&ccedil;&atilde;o primeiro localiza as coordenadas <code class="code" id="ebpgcq_117">(emptyX, emptyY)</code> do espa&ccedil;o vazio.</p></li><li class="list__item" id="ebpgcq_112"><p id="ebpgcq_118">Em seguida, ela itera sobre as quatro dire&ccedil;&otilde;es poss&iacute;veis (<code class="code" id="ebpgcq_119">dx</code>, <code class="code" id="ebpgcq_120">dy</code>) para encontrar pe&ccedil;as adjacentes.</p></li><li class="list__item" id="ebpgcq_113"><p id="ebpgcq_121">Para cada pe&ccedil;a adjacente, ela verifica se a pe&ccedil;a est&aacute; dentro dos limites do tabuleiro.</p></li><li class="list__item" id="ebpgcq_114"><p id="ebpgcq_122">A parte crucial &eacute; a condi&ccedil;&atilde;o <code class="code" id="ebpgcq_123">tileValue != (nx - 1) * 4 + ny</code>. Isso compara o valor atual da pe&ccedil;a com o valor que ela <span class="emphasis" id="ebpgcq_124">deveria</span> ter se o tabuleiro estivesse resolvido. Se eles n&atilde;o corresponderem, e a pe&ccedil;a puder ser movida para o espa&ccedil;o vazio, ela &eacute; considerada uma dica.</p></li><li class="list__item" id="ebpgcq_115"><p id="ebpgcq_125">Se nenhuma dica for encontrada, <code class="code" id="ebpgcq_126">Vector2i(-1, -1)</code> &eacute; retornado.</p></li></ul></section><section class="chapter"><h3 id="6-fun-o-principal-main" data-toc="6-fun-o-principal-main">6. Fun&ccedil;&atilde;o Principal (<code class="code" id="ebpgcq_130">main</code>)</h3><p id="ebpgcq_128">A fun&ccedil;&atilde;o <code class="code" id="ebpgcq_131">main</code> &eacute; o ponto de entrada do programa. Ela inicializa a janela, carrega recursos, configura os elementos da UI e cont&eacute;m o loop principal do jogo, que gerencia eventos, atualiza o estado do jogo e renderiza tudo na tela.</p><div class="code-block" data-lang="cpp">
int main() {
    // 1. Inicialização da Janela
    RenderWindow app(VideoMode(256, 350), &quot;15-Puzzle!&quot;); // Cria a janela do jogo
    app.setFramerateLimit(60); // Define o limite de quadros por segundo

    GameState gameState = MENU; // O jogo começa no estado de menu

    // 2. Carregamento da Fonte
    Font font;
    if (!font.loadFromFile(&quot;fonts/Carlito-Regular.ttf&quot;)) {
        return -1; // Erro se a fonte não puder ser carregada
    }

    // 3. Configuração dos Textos da UI (Menu, Vitória, Dica)
    // Cada texto é configurado com sua string, fonte, tamanho, cor, origem (para centralização) e posição.
    Text playText(&quot;Play&quot;, font, 50);
    // ... (configurações de playText, exitText, winText, backToMenuText, hintText) ...

    // 4. Carregamento da Textura das Peças
    Texture t;
    t.loadFromFile(&quot;images/15.png&quot;); // Carrega a imagem que contém todas as peças

    int w = 64; // Largura/altura de cada peça (64x64 pixels)
    int grid[6][6] = {0}; // Representação interna do tabuleiro (com bordas para simplificar cálculos)
    Sprite sprite[20]; // Array de sprites, um para cada peça (1 a 16)

    // 5. Inicialização dos Sprites das Peças
    int n=0;
    for (int i=0; i&lt;4; i++)
        for (int j=0; j&lt;4; j++) {
            n++;
            sprite[n].setTexture(t); // Define a textura para o sprite
            // Define qual parte da imagem '15.png' corresponde a esta peça
            sprite[n].setTextureRect( IntRect(i*w,j*w,w,w) );
            grid[i+1][j+1]=n; // Preenche o grid inicial em ordem (para referência)
        }

    // Variáveis para o sistema de dicas
    Vector2i hintedTile(-1, -1); // Armazena a posição da peça sugerida (-1,-1 se nenhuma)
    Clock hintClock; // Cronômetro para controlar a duração da dica
    float hintDuration = 2.0f; // Duração da dica em segundos

    // 6. Loop Principal do Jogo
    while (app.isOpen()) { // O loop continua enquanto a janela estiver aberta
        Event e;
        while (app.pollEvent(e)) { // Processa todos os eventos pendentes
            if (e.type == Event::Closed){
                app.close(); // Fecha a janela se o botão 'X' for clicado
            }

            // 7. Manuseio de Eventos de Mouse (Movimento e Clique)
            // Lógica para efeitos de hover (mudar cor do texto ao passar o mouse)
            if (e.type == Event::MouseMoved) {
                // ... (lógica de hover para playText, exitText, backToMenuText, hintText) ...
            }

            // Lógica para cliques do mouse
            if (e.type == Event::MouseButtonPressed) {
                if (e.key.code == Mouse::Left) { // Se o botão esquerdo do mouse for clicado
                    Vector2i mousePos = Mouse::getPosition(app); // Posição do clique

                    if (gameState == MENU) {
                        // Transição para o estado GAME ao clicar em &quot;Play&quot;
                        if (playText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                            gameState = GAME;
                            shuffleGrid(grid); // Embaralha o tabuleiro para iniciar o jogo
                        }
                        // Fecha o aplicativo ao clicar em &quot;Exit&quot;
                        else if (exitText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                            app.close();
                        }
                    } else if (gameState == GAME) { // Se estiver no estado de jogo
                        if (isSolved(grid)) { // Se o puzzle estiver resolvido
                            // Volta para o menu se &quot;Back to Menu&quot; for clicado
                            if (backToMenuText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                                gameState = MENU;
                            }
                        }
                        // Ativa a dica ao clicar em &quot;Hint&quot;
                        else if (hintText.getGlobalBounds().contains(mousePos.x, mousePos.y)) {
                            hintedTile = findHintMove(grid); // Encontra a dica
                            hintClock.restart(); // Reinicia o cronômetro da dica
                        }
                        // Lógica de movimento das peças do quebra-cabeça
                        else {
                            int x = mousePos.x/w + 1; // Coluna clicada (1-baseada)
                            int y = mousePos.y/w + 1; // Linha clicada (1-baseada)

                            int dx=0; // Deslocamento em X para o espaço vazio
                            int dy=0; // Deslocamento em Y para o espaço vazio

                            // Verifica se a peça clicada é adjacente ao espaço vazio (16)
                            if (grid[x+1][y]==16) { dx=1; dy=0; }; // Espaço vazio à direita
                            if (grid[x][y+1]==16) { dx=0; dy=1; }; // Espaço vazio abaixo
                            if (grid[x][y-1]==16) { dx=0; dy=-1; }; // Espaço vazio acima
                            if (grid[x-1][y]==16) { dx=-1; dy=0; }; // Espaço vazio à esquerda

                            // Se a peça clicada pode se mover (dx ou dy não são 0)
                            if (dx != 0 || dy != 0) {
                                int n = grid[x][y]; // Valor da peça clicada
                                grid[x][y] = 16; // A posição da peça clicada se torna o espaço vazio
                                grid[x+dx][y+dy] = n; // A peça clicada se move para a posição do espaço vazio

                                // Animação do movimento da peça
                                sprite[16].move(-dx*w,-dy*w); // Move o sprite do espaço vazio na direção oposta
                                float speed=3; // Velocidade da animação

                                for (int i=0; i&lt;w; i+=speed) { // Loop para animar o movimento
                                    sprite[n].move(speed*dx,speed*dy);
                                    app.draw(sprite[16]);
                                    app.draw(sprite[n]);
                                    app.display();
                                }
                            }
                        }
                    }
                }
            }
        }

        // 8. Lógica de Renderização (Desenho na Tela)
        app.clear(Color::White); // Limpa a tela com a cor branca

        if (gameState == MENU) {
            app.draw(playText); // Desenha o texto &quot;Play&quot;
            app.draw(exitText); // Desenha o texto &quot;Exit&quot;
        } else if (gameState == GAME) {
            // Desenha as peças do quebra-cabeça
            for (int i=0; i&lt;4; i++) {
                for (int j=0; j&lt;4; j++) {
                    int n = grid[i+1][j+1]; // Obtém o valor da peça na posição
                    sprite[n].setPosition(i*w,j*w); // Define a posição do sprite na tela
                    app.draw(sprite[n]); // Desenha o sprite da peça
                }
            }
            // Se o jogo estiver resolvido, exibe a mensagem de vitória e o botão &quot;Back to Menu&quot;
            if (isSolved(grid)) {
                app.draw(winText);
                app.draw(backToMenuText);
            }
            else {
                app.draw(hintText); // Caso contrário, exibe o botão &quot;Hint&quot;
            }

            // Desenha o destaque da dica se houver uma dica ativa e dentro do tempo
            if (hintedTile.x != -1 &amp;&amp; hintClock.getElapsedTime().asSeconds() &lt; hintDuration) {
                RectangleShape hintRect(Vector2f(w, w)); // Cria um retângulo para o destaque
                hintRect.setFillColor(Color::Transparent); // Fundo transparente
                hintRect.setOutlineThickness(5); // Espessura da borda
                hintRect.setOutlineColor(Color::Yellow); // Cor da borda
                // Define a posição do destaque sobre a peça sugerida
                hintRect.setPosition((hintedTile.x - 1) * w, (hintedTile.y - 1) * w);
                app.draw(hintRect); // Desenha o destaque
            }
        }

        app.display(); // Exibe o que foi desenhado na tela (troca o buffer)
    }

    return 0; // O programa termina com sucesso
}
</div></section></section><div class="last-modified">28 August 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="minesweeper.html" class="navigation-links__prev">Minesweeper</a><a href="racing.html" class="navigation-links__next">Racing Game Top-Down</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>